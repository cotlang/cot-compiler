// Phase 0: Prerequisites Test Suite
// Verifies Cot language features required for self-hosted compiler
//
// Run with: cot test tests/prerequisites.cot
//
// Each test verifies a specific capability needed for the compiler:
// - P0: Blocking (must work before starting)
// - P1: Important (need during development)

fn main() {
    println("=== Cot Compiler Prerequisites ===")
    println("")
    println("Run 'cot test tests/prerequisites.cot' to execute all tests")
}

// ============================================================
// P0.1: String Length
// ============================================================

test "P0.1 - len() on strings" {
    const s = "hello"
    assert(len(s) == 5, "len('hello') should be 5")

    const empty = ""
    assert(len(empty) == 0, "len('') should be 0")

    const with_spaces = "  hi  "
    assert(len(with_spaces) == 6, "len('  hi  ') should be 6")
}

// ============================================================
// P0.2: Substring Access (1-based indexing)
// ============================================================

test "P0.2a - substring with (start:length) syntax" {
    const s = "hello world"

    // Extract "hello" - positions 1-5, length 5
    const first = s(1:5)
    assert(first == "hello", "s(1:5) should be 'hello'")

    // Extract "world" - positions 7-11, length 5
    const second = s(7:5)
    assert(second == "world", "s(7:5) should be 'world'")

    // Single character
    const char = s(1:1)
    assert(char == "h", "s(1:1) should be 'h'")
}

test "P0.2b - substring with (start,end) syntax" {
    const s = "hello world"

    // Extract "hello" - positions 1 to 5
    const first = s(1,5)
    assert(first == "hello", "s(1,5) should be 'hello'")

    // Extract "world" - positions 7 to 11
    const second = s(7,11)
    assert(second == "world", "s(7,11) should be 'world'")
}

test "P0.2c - iterate string characters" {
    const s = "abc"
    var result = ""
    var i: i64 = 1
    while (i <= len(s)) {
        const ch = s(i:1)
        result = result + ch + "-"
        i += 1
    }
    assert(result == "a-b-c-", "character iteration should work")
}

// ============================================================
// P0.3: Character Code Conversion
// ============================================================

test "P0.3a - char() converts code to character" {
    const a = char(97)
    assert(a == "a", "char(97) should be 'a'")

    const A = char(65)
    assert(A == "A", "char(65) should be 'A'")

    const zero = char(48)
    assert(zero == "0", "char(48) should be '0'")
}

test "P0.3b - string comparison for character classification" {
    // For lexer: check if character is in range
    const ch = "c"
    const is_lower = ch >= "a" and ch <= "z"
    assert(is_lower, "'c' should be lowercase letter")

    const digit = "5"
    const is_digit = digit >= "0" and digit <= "9"
    assert(is_digit, "'5' should be a digit")
}

// ============================================================
// P0.4: Map<string, T> - Symbol Tables
// ============================================================

test "P0.4a - Map creation and basic ops" {
    var m: Map<string, i64> = Map.new()

    // Set values
    m.set("x", 10)
    m.set("y", 20)
    m.set("z", 30)

    // Get values
    assert(m.get("x") == 10, "m.get('x') should be 10")
    assert(m.get("y") == 20, "m.get('y') should be 20")
    assert(m.get("z") == 30, "m.get('z') should be 30")
}

test "P0.4b - Map has() and len()" {
    var m: Map<string, i64> = Map.new()
    m.set("exists", 42)

    assert(m.has("exists"), "m.has('exists') should be true")
    assert(!m.has("missing"), "m.has('missing') should be false")
    assert(m.len() == 1, "m.len() should be 1")
}

test "P0.4c - Map with string values" {
    var keywords: Map<string, string> = Map.new()
    keywords.set("fn", "Function")
    keywords.set("let", "Let")
    keywords.set("if", "If")

    assert(keywords.get("fn") == "Function", "keywords.get('fn')")
    assert(keywords.has("let"), "keywords.has('let')")
    assert(keywords.len() == 3, "should have 3 keywords")
}

// ============================================================
// P0.5: Enum Comparison
// ============================================================

enum TokenType {
    Identifier,
    Number,
    String,
    Plus,
    Minus,
    Star,
    Slash,
    LeftParen,
    RightParen,
}

test "P0.5a - enum creation and comparison" {
    const t1: TokenType = TokenType.Identifier
    const t2: TokenType = TokenType.Identifier
    const t3: TokenType = TokenType.Number

    assert(t1 == t2, "same enum values should be equal")
    assert(t1 != t3, "different enum values should not be equal")
}

test "P0.5b - enum in if conditions" {
    const tok: TokenType = TokenType.Plus
    var is_operator: i64 = 0

    if (tok == TokenType.Plus) {
        is_operator = 1
    } else if (tok == TokenType.Minus) {
        is_operator = 1
    } else if (tok == TokenType.Star) {
        is_operator = 1
    } else if (tok == TokenType.Slash) {
        is_operator = 1
    }

    assert(is_operator == 1, "Plus should be detected as operator")
}

// ============================================================
// P0.6: Struct Definition and Field Access
// ============================================================

struct Token {
    type: TokenType,
    text: string,
    line: i64,
    column: i64,
}

struct SourceLoc {
    line: i64,
    column: i64,
}

test "P0.6a - struct creation" {
    var tok: Token = Token{
        .type = TokenType.Identifier,
        .text = "foo",
        .line = 1,
        .column = 5,
    }

    assert(tok.type == TokenType.Identifier, "tok.type")
    assert(tok.text == "foo", "tok.text")
    assert(tok.line == 1, "tok.line")
    assert(tok.column == 5, "tok.column")
}

test "P0.6b - struct field modification" {
    var loc: SourceLoc = SourceLoc{ .line = 1, .column = 1 }

    loc.line = 10
    loc.column = 25

    assert(loc.line == 10, "modified line")
    assert(loc.column == 25, "modified column")
}

// ============================================================
// P0.7: Array Basics (Fixed Size)
// ============================================================

test "P0.7a - array literal and indexing" {
    const arr = [10, 20, 30, 40, 50]

    assert(arr[0] == 10, "arr[0]")
    assert(arr[1] == 20, "arr[1]")
    assert(arr[4] == 50, "arr[4]")
}

test "P0.7b - mutable array modification" {
    var arr = [1, 2, 3]
    arr[0] = 10
    arr[1] = 20
    arr[2] = 30

    assert(arr[0] == 10, "modified arr[0]")
    assert(arr[1] == 20, "modified arr[1]")
    assert(arr[2] == 30, "modified arr[2]")
}

test "P0.7c - for-in array iteration" {
    const arr = [1, 2, 3, 4, 5]
    var sum: i64 = 0

    for n in arr {
        sum = sum + n
    }

    assert(sum == 15, "sum should be 15")
}

// ============================================================
// P0.8: String Comparison
// ============================================================

test "P0.8 - string equality" {
    const a = "hello"
    const b = "hello"
    const c = "world"

    assert(a == b, "same strings equal")
    assert(a != c, "different strings not equal")

    // Keyword detection
    const text = "fn"
    assert(text == "fn", "text == 'fn'")
    assert(text != "let", "text != 'let'")
}

// ============================================================
// P0.9: Range Iteration
// ============================================================

test "P0.9 - for-in range" {
    var sum: i64 = 0

    for i in 0..5 {
        sum = sum + i
    }

    assert(sum == 10, "0+1+2+3+4 = 10")
}

// ============================================================
// P1.1: String Concatenation
// ============================================================

test "P1.1 - string concatenation" {
    const a = "hello"
    const b = " "
    const c = "world"

    const result = a + b + c
    assert(result == "hello world", "concatenation")
}

// ============================================================
// P1.2: Integer to String
// ============================================================

test "P1.2 - integer in string context" {
    const line: i64 = 42
    const msg = "Error at line " + line
    assert(msg == "Error at line 42", "int to string in concat")
}

// ============================================================
// P1.3: Nested Struct Access
// ============================================================

struct Point {
    x: i64,
    y: i64,
}

struct Rect {
    origin: Point,
    width: i64,
    height: i64,
}

test "P1.3 - nested struct field access" {
    var r: Rect = Rect{
        .origin = Point{ .x = 10, .y = 20 },
        .width = 100,
        .height = 50,
    }

    assert(r.origin.x == 10, "r.origin.x")
    assert(r.origin.y == 20, "r.origin.y")
    assert(r.width == 100, "r.width")
}

// ============================================================
// P1.4: Function Returning Struct
// ============================================================

fn make_token(tt: TokenType, txt: string, ln: i64, col: i64) Token {
    return Token{
        .type = tt,
        .text = txt,
        .line = ln,
        .column = col,
    }
}

test "P1.4 - function returning struct" {
    var tok: Token = make_token(TokenType.Number, "42", 5, 10)

    assert(tok.type == TokenType.Number, "returned type")
    assert(tok.text == "42", "returned text")
    assert(tok.line == 5, "returned line")
}

// ============================================================
// P1.5: Multiple Return via Struct
// ============================================================

struct ParseResult {
    value: i64,
    rest: string,
}

fn parse_int_prefix(s: string) ParseResult {
    // Simple parser: extract leading digits
    var value: i64 = 0
    var i: i64 = 1

    while (i <= len(s)) {
        const ch = s(i:1)
        if (ch >= "0" and ch <= "9") {
            const digit: i64 = integer(ch) - 48  // ASCII '0' = 48
            value = value * 10 + digit
            i += 1
        } else {
            // Non-digit found, stop
            const rest = if (i <= len(s)) s(i:len(s) - i + 1) else ""
            return ParseResult{ .value = value, .rest = rest }
        }
    }

    return ParseResult{ .value = value, .rest = "" }
}

test "P1.5 - struct for multiple returns" {
    var result: ParseResult = parse_int_prefix("123abc")

    assert(result.value == 123, "parsed value")
    assert(result.rest == "abc", "remaining string")
}

// ============================================================
// Summary of Known Gaps (to be fixed)
// ============================================================
//
// CRITICAL GAPS:
// 1. char_at(str, i) - Need native function for character indexing
//    Workaround: use s(i:1) substring syntax
//
// 2. impl block method dispatch - Currently parsed but NOT working
//    Methods defined in impl blocks cannot be called on instances
//    This is BLOCKING for idiomatic compiler code
//
// 3. Dynamic arrays - No push/append for growing arrays
//    May need List<T> or array_push native
//
// 4. match statement - Need to verify full match syntax works
//
// 5. Self-referential structs - Need to verify pointers work
//    e.g., struct Node { left: ?*Node, right: ?*Node }
//
