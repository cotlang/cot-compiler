// Cot IR to Bytecode Emitter
//
// Transforms IR into bytecode that can be executed by the Cot VM.
// This is the final stage of the self-hosted compiler pipeline.

// =============================================================================
// Constants
// =============================================================================

// Module format magic number
const MAGIC_MODULE: string = "CBO1"

// Version
const VERSION_MAJOR: i64 = 0
const VERSION_MINOR: i64 = 1

// Register conventions
const REG_COUNT: i64 = 16
const REG_RESERVED_FP: i64 = 14
const REG_RESERVED_RET: i64 = 15
const REG_USABLE_COUNT: i64 = 14

// Opcode constants - now visible in function scopes
const OP_NOP: i64 = 0
const OP_HALT: i64 = 1
const OP_MOV: i64 = 16
const OP_MOVI: i64 = 17
const OP_MOVI16: i64 = 18
const OP_MOVI32: i64 = 19
const OP_LOAD_CONST: i64 = 20
const OP_LOAD_NULL: i64 = 21
const OP_LOAD_TRUE: i64 = 22
const OP_LOAD_FALSE: i64 = 23
const OP_LOAD_LOCAL: i64 = 32
const OP_STORE_LOCAL: i64 = 33
const OP_LOAD_LOCAL16: i64 = 34
const OP_STORE_LOCAL16: i64 = 35
const OP_LOAD_GLOBAL: i64 = 36
const OP_STORE_GLOBAL: i64 = 37
const OP_ADD: i64 = 48
const OP_SUB: i64 = 49
const OP_MUL: i64 = 50
const OP_DIV: i64 = 51
const OP_MOD: i64 = 52
const OP_NEG: i64 = 53
const OP_CMP_EQ: i64 = 64
const OP_CMP_NE: i64 = 65
const OP_CMP_LT: i64 = 66
const OP_CMP_LE: i64 = 67
const OP_CMP_GT: i64 = 68
const OP_CMP_GE: i64 = 69
const OP_LOG_AND: i64 = 80
const OP_LOG_OR: i64 = 81
const OP_LOG_NOT: i64 = 82
const OP_BIT_AND: i64 = 83
const OP_BIT_OR: i64 = 84
const OP_BIT_XOR: i64 = 85
const OP_BIT_NOT: i64 = 86
const OP_SHL: i64 = 90
const OP_SHR: i64 = 91
const OP_JMP: i64 = 96
const OP_JZ: i64 = 98
const OP_JNZ: i64 = 99
const OP_CALL: i64 = 112
const OP_CALL_NATIVE: i64 = 114
const OP_RET: i64 = 117
const OP_RET_VAL: i64 = 118
const OP_NEW_RECORD: i64 = 128
const OP_LOAD_FIELD: i64 = 130
const OP_STORE_FIELD: i64 = 131
const OP_STR_CONCAT: i64 = 144
const OP_STR_LEN: i64 = 145
const OP_LIST_LEN: i64 = 179
const OP_PRINT: i64 = 208
const OP_PRINTLN: i64 = 209
const OP_MAP_NEW: i64 = 213
const OP_MAP_SET: i64 = 214
const OP_MAP_GET: i64 = 215
const OP_MAP_DELETE: i64 = 216
const OP_MAP_HAS: i64 = 217
const OP_MAP_LEN: i64 = 218
const OP_LIST_NEW: i64 = 237
const OP_LIST_PUSH: i64 = 238
const OP_LIST_POP: i64 = 239
const OP_DEBUG_LINE: i64 = 241
const OP_LIST_GET: i64 = 253
const OP_LIST_SET: i64 = 255
const OP_SET_ERROR_HANDLER: i64 = 106
const OP_CLEAR_ERROR_HANDLER: i64 = 107
const OP_THROW: i64 = 108

// =============================================================================
// P0 Critical Opcodes - Required for Self-Hosting
// =============================================================================

// Stack pointer operations (0x7A-0x7C) - for struct-by-pointer passing
const OP_GET_LOCAL_PTR: i64 = 0x7A
const OP_LOAD_INDIRECT: i64 = 0x7B
const OP_STORE_INDIRECT: i64 = 0x7C
const OP_PTR_OFFSET: i64 = 0x59

// Variant (sum type) operations (0x8A-0x8C)
const OP_VARIANT_CONSTRUCT: i64 = 0x8A
const OP_VARIANT_GET_TAG: i64 = 0x8B
const OP_VARIANT_GET_PAYLOAD: i64 = 0x8C

// ARC operations (0xF5-0xF7) - memory management
const OP_ARC_RETAIN: i64 = 0xF5
const OP_ARC_RELEASE: i64 = 0xF6
const OP_ARC_MOVE: i64 = 0xF7

// Closure operations (0xF8-0xF9)
const OP_MAKE_CLOSURE: i64 = 0xF8
const OP_CALL_CLOSURE: i64 = 0xF9

// =============================================================================
// P1 Important Opcodes - Full Language Support
// =============================================================================

// Comparison jump operations (0x64-0x67) - optimized branching
const OP_JEQ: i64 = 0x64
const OP_JNE: i64 = 0x65
const OP_JLT: i64 = 0x66
const OP_JGE: i64 = 0x67
const OP_JMP32: i64 = 0x61
const OP_LOOP_START: i64 = 0x68
const OP_LOOP_END: i64 = 0x69

// Increment/decrement operations (0x39-0x3A)
const OP_INCR: i64 = 0x39
const OP_DECR: i64 = 0x3A

// Type checking operations
const OP_IS_NULL: i64 = 0x57
const OP_SELECT: i64 = 0x58
const OP_IS_TYPE: i64 = 0x5C

// String operations (0x92-0x9A)
const OP_STR_INDEX: i64 = 0x92
const OP_STR_SLICE: i64 = 0x93
const OP_STR_SLICE_STORE: i64 = 0x94
const OP_STR_TRIM: i64 = 0x95
const OP_STR_UPPER: i64 = 0x96
const OP_STR_LOWER: i64 = 0x97
const OP_STR_FIND: i64 = 0x98
const OP_STR_REPLACE: i64 = 0x99
const OP_STR_SETCHAR: i64 = 0x9A

// String comparison operations (0x46-0x4B)
const OP_CMP_STR_EQ: i64 = 0x46
const OP_CMP_STR_LT: i64 = 0x47
const OP_CMP_STR_NE: i64 = 0x48
const OP_CMP_STR_LE: i64 = 0x49
const OP_CMP_STR_GT: i64 = 0x4A
const OP_CMP_STR_GE: i64 = 0x4B

// Struct-in-collection operations (0xB5-0xBA)
const OP_LIST_PUSH_STRUCT: i64 = 0xB5
const OP_LIST_GET_STRUCT: i64 = 0xB6
const OP_LIST_POP_STRUCT: i64 = 0xB7
const OP_LIST_SET_STRUCT: i64 = 0xB8
const OP_MAP_SET_STRUCT: i64 = 0xB9
const OP_MAP_GET_STRUCT: i64 = 0xBA

// Call variant operations
const OP_CALL_INDIRECT: i64 = 0x73
const OP_CALL_DYNAMIC: i64 = 0x74
const OP_PUSH_ARG: i64 = 0x77
const OP_PUSH_ARG_REG: i64 = 0x78
const OP_POP_ARG: i64 = 0x79

// List extras
const OP_LIST_CLEAR: i64 = 0xB4
const OP_LIST_TO_SLICE: i64 = 0xBD

// Map extras
const OP_MAP_CLEAR: i64 = 0xDB
const OP_MAP_KEYS: i64 = 0xDC
const OP_MAP_VALUES: i64 = 0xDD
const OP_MAP_GET_AT: i64 = 0xDE
const OP_MAP_SET_AT: i64 = 0xDF
const OP_MAP_KEY_AT: i64 = 0xFC

// =============================================================================
// P2 Nice-to-Have Opcodes
// =============================================================================

// Array operations (0xB0-0xBC)
const OP_ARRAY_LOAD: i64 = 0xB0
const OP_ARRAY_STORE: i64 = 0xB1
const OP_ARRAY_LEN: i64 = 0xB2
const OP_ARRAY_SLICE: i64 = 0xBB
const OP_ARRAY_LOAD_OPT: i64 = 0xBC

// Type conversion operations (0xA0-0xA7)
const OP_TO_INT: i64 = 0xA0
const OP_TO_STR: i64 = 0xA1
const OP_TO_BOOL: i64 = 0xA2
const OP_TO_DEC: i64 = 0xA3
const OP_TO_CHAR: i64 = 0xA4
const OP_TO_FIXED_STRING: i64 = 0xA5
const OP_FORMAT_DECIMAL: i64 = 0xA6
const OP_PARSE_DECIMAL: i64 = 0xA7

// Record extras
const OP_FREE_RECORD: i64 = 0x81
const OP_CLEAR_RECORD: i64 = 0x88
const OP_ALLOC_BUFFER: i64 = 0x89

// Weak reference operations
const OP_WEAK_REF: i64 = 0xF3
const OP_WEAK_LOAD: i64 = 0xF4

// Trait object operations
const OP_MAKE_TRAIT_OBJECT: i64 = 0xFA
const OP_CALL_TRAIT_METHOD: i64 = 0xFB

// I/O operations
const OP_READLN: i64 = 0xD2
const OP_READKEY: i64 = 0xD3
const OP_LOG: i64 = 0xD4

// Debug operations
const OP_DEBUG_BREAK: i64 = 0xF0
const OP_ASSERT: i64 = 0xF2

// =============================================================================
// Constant Pool
// =============================================================================

enum ConstantTag {
    Integer,
    Decimal,
    String,
    FixedString,
    Identifier,
    RecordRef,
    RoutineRef,
    Float,
    Boolean,
}

struct ConstantEntry {
    tag: ConstantTag,
    int_val: i64,
    str_val: string,
    float_val: f64,
    bool_val: bool,
    precision: i64,
}

fn newIntConstant(val: i64) ConstantEntry {
    return ConstantEntry{
        .tag = ConstantTag.Integer,
        .int_val = val,
        .str_val = "",
        .float_val = 0.0,
        .bool_val = false,
        .precision = 0,
    }
}

fn newStringConstant(val: string) ConstantEntry {
    return ConstantEntry{
        .tag = ConstantTag.String,
        .int_val = 0,
        .str_val = val,
        .float_val = 0.0,
        .bool_val = false,
        .precision = 0,
    }
}

fn newIdentifierConstant(val: string) ConstantEntry {
    return ConstantEntry{
        .tag = ConstantTag.Identifier,
        .int_val = 0,
        .str_val = val,
        .float_val = 0.0,
        .bool_val = false,
        .precision = 0,
    }
}

fn newFloatConstant(val: f64) ConstantEntry {
    return ConstantEntry{
        .tag = ConstantTag.Float,
        .int_val = 0,
        .str_val = "",
        .float_val = val,
        .bool_val = false,
        .precision = 0,
    }
}

fn newBoolConstant(val: bool) ConstantEntry {
    return ConstantEntry{
        .tag = ConstantTag.Boolean,
        .int_val = 0,
        .str_val = "",
        .float_val = 0.0,
        .bool_val = val,
        .precision = 0,
    }
}

// =============================================================================
// Routine Definition
// =============================================================================

struct RoutineDef {
    name_index: i64,
    is_public: bool,
    is_function: bool,
    code_offset: i64,
    code_length: i64,
    param_count: i64,
    local_count: i64,
    max_stack: i64,
}

fn newRoutineDef(name_idx: i64) RoutineDef {
    return RoutineDef{
        .name_index = name_idx,
        .is_public = false,
        .is_function = false,
        .code_offset = 0,
        .code_length = 0,
        .param_count = 0,
        .local_count = 0,
        .max_stack = 0,
    }
}

// =============================================================================
// Export Entry
// =============================================================================

enum ExportKind {
    Routine,
    Record,
    Global,
}

struct ExportEntry {
    name_index: i64,
    kind: ExportKind,
    index: i64,
}

// =============================================================================
// Register Allocator
// =============================================================================

struct RegisterAllocator {
    free_regs: i64,
    value_to_reg: Map<i64, i64>,
    reg_to_value: List<i64>,
}

fn newRegisterAllocator() RegisterAllocator {
    const value_to_reg= new Map<i64, i64>
    const reg_to_value= new List<i64>

    var i: i64 = 0
    while (i < 16) {
        reg_to_value.push(-1)
        i = i + 1
    }

    return RegisterAllocator{
        .free_regs = 16383,
        .value_to_reg = value_to_reg,
        .reg_to_value = reg_to_value,
    }
}

fn regAllocReset(ra: RegisterAllocator) {
    ra.free_regs = 16383
    var i: i64 = 0
    while (i < 16) {
        ra.reg_to_value.set(i, -1)
        i = i + 1
    }
}

fn regAllocAllocate(ra: RegisterAllocator, value_id: i64) i64 {
    var reg: i64 = 0
    while (reg < 14) {
        const mask: i64 = 1 << reg
        if ((ra.free_regs & mask) != 0) {
            ra.free_regs = ra.free_regs & (~mask)
            ra.value_to_reg.set(value_id, reg)
            ra.reg_to_value.set(reg, value_id)
            return reg
        }
        reg = reg + 1
    }
    return -1
}

fn regAllocGetRegister(ra: RegisterAllocator, value_id: i64) i64 {
    if (ra.value_to_reg.has(value_id)) {
        return ra.value_to_reg.get(value_id)
    }
    return -1
}

fn regAllocFree(ra: RegisterAllocator, reg: i64) {
    if (reg >= 14) {
        return
    }
    const mask: i64 = 1 << reg
    ra.free_regs = ra.free_regs | mask
    const value_id = ra.reg_to_value.get(reg)
    if (value_id >= 0) {
        ra.value_to_reg.delete(value_id)
    }
    ra.reg_to_value.set(reg, -1)
}

fn regAllocFreeValue(ra: RegisterAllocator, value_id: i64) {
    if (ra.value_to_reg.has(value_id)) {
        const reg = ra.value_to_reg.get(value_id)
        regAllocFree(ra, reg)
    }
}

fn regAllocAssign(ra: RegisterAllocator, value_id: i64, reg: i64) {
    if (reg >= 14) {
        return
    }
    const mask: i64 = 1 << reg
    ra.free_regs = ra.free_regs & (~mask)
    ra.value_to_reg.set(value_id, reg)
    ra.reg_to_value.set(reg, value_id)
}

// =============================================================================
// Pending Jump
// =============================================================================

struct PendingJump {
    patch_offset: i64,
    target_block: i64,
    is_wide: bool,
}

// =============================================================================
// Variable Location
// =============================================================================

struct VarLocation {
    slot: i64,
    is_global: bool,
}

// =============================================================================
// Bytecode Emitter
// =============================================================================

struct BytecodeEmitter {
    code: List<i64>,
    constants: List<ConstantEntry>,
    routines: List<RoutineDef>,
    exports: List<ExportEntry>,
    globals: Map<string, VarLocation>,
    locals: Map<string, VarLocation>,
    global_count: i64,
    local_count: i64,
    string_pool: Map<string, i64>,
    int_pool: Map<i64, i64>,
    function_indices: Map<string, i64>,
    block_offsets: Map<i64, i64>,
    pending_jumps: List<PendingJump>,
    value_slots: Map<i64, i64>,
    current_routine_start: i64,
    reg_alloc: RegisterAllocator,
    spill_slot_base: i64,
    next_spill_slot: i64,
    max_spill_slots: i64,
}

fn newBytecodeEmitter() BytecodeEmitter {
    const code= new List<i64>
    const constants= new List<ConstantEntry>
    const routines= new List<RoutineDef>
    const exports= new List<ExportEntry>
    const globals= new Map<string, VarLocation>
    const locals= new Map<string, VarLocation>
    const string_pool= new Map<string, i64>
    const int_pool= new Map<i64, i64>
    const function_indices= new Map<string, i64>
    const block_offsets= new Map<i64, i64>
    const pending_jumps= new List<PendingJump>
    const value_slots= new Map<i64, i64>
    const reg_alloc = newRegisterAllocator()

    return BytecodeEmitter{
        .code = code,
        .constants = constants,
        .routines = routines,
        .exports = exports,
        .globals = globals,
        .locals = locals,
        .global_count = 0,
        .local_count = 0,
        .string_pool = string_pool,
        .int_pool = int_pool,
        .function_indices = function_indices,
        .block_offsets = block_offsets,
        .pending_jumps = pending_jumps,
        .value_slots = value_slots,
        .current_routine_start = 0,
        .reg_alloc = reg_alloc,
        .spill_slot_base = 0,
        .next_spill_slot = 0,
        .max_spill_slots = 0,
    }
}

// =============================================================================
// Constant Pool Management
// =============================================================================

fn emitAddString(e: BytecodeEmitter, s: string) i64 {
    if (e.string_pool.has(s)) {
        return e.string_pool.get(s)
    }
    const idx = e.constants.len()
    const c = newStringConstant(s)
    e.constants.push(c)
    e.string_pool.set(s, idx)
    return idx
}

fn emitAddIdentifier(e: BytecodeEmitter, s: string) i64 {
    if (e.string_pool.has(s)) {
        return e.string_pool.get(s)
    }
    const idx = e.constants.len()
    const c = newIdentifierConstant(s)
    e.constants.push(c)
    e.string_pool.set(s, idx)
    return idx
}

fn emitAddInt(e: BytecodeEmitter, val: i64) i64 {
    if (e.int_pool.has(val)) {
        return e.int_pool.get(val)
    }
    const idx = e.constants.len()
    const c = newIntConstant(val)
    e.constants.push(c)
    e.int_pool.set(val, idx)
    return idx
}

fn emitAddFloat(e: BytecodeEmitter, val: f64) i64 {
    const idx = e.constants.len()
    const c = newFloatConstant(val)
    e.constants.push(c)
    return idx
}

fn emitAddBool(e: BytecodeEmitter, val: bool) i64 {
    const idx = e.constants.len()
    const c = newBoolConstant(val)
    e.constants.push(c)
    return idx
}

// =============================================================================
// Bytecode Emission Primitives
// =============================================================================

fn emitByte(e: BytecodeEmitter, b: i64) {
    e.code.push(b & 255)
}

fn emitU16(e: BytecodeEmitter, val: i64) {
    emitByte(e, val & 255)
    emitByte(e, (val >> 8) & 255)
}

fn emitU32(e: BytecodeEmitter, val: i64) {
    emitByte(e, val & 255)
    emitByte(e, (val >> 8) & 255)
    emitByte(e, (val >> 16) & 255)
    emitByte(e, (val >> 24) & 255)
}

fn emitOpcode(e: BytecodeEmitter, op: i64) {
    emitByte(e, op)
}

fn packRegs(r1: i64, r2: i64) i64 {
    return ((r1 & 15) << 4) | (r2 & 15)
}

fn emitRegReg(e: BytecodeEmitter, op: i64, rd: i64, rs: i64) {
    emitOpcode(e, op)
    emitByte(e, packRegs(rd, rs))
    emitByte(e, 0)
}

fn emitRegImm8(e: BytecodeEmitter, op: i64, rd: i64, imm: i64) {
    emitOpcode(e, op)
    emitByte(e, packRegs(rd, 0))
    emitByte(e, imm & 255)
}

fn emitRegU16(e: BytecodeEmitter, op: i64, rd: i64, val: i64) {
    emitOpcode(e, op)
    emitByte(e, packRegs(rd, 0))
    emitU16(e, val)
}

fn emitReg3(e: BytecodeEmitter, op: i64, rd: i64, rs1: i64, rs2: i64) {
    emitOpcode(e, op)
    emitByte(e, packRegs(rd, rs1))
    emitByte(e, packRegs(rs2, 0))
}

// =============================================================================
// Instruction Emission Helpers
// =============================================================================

fn emitMov(e: BytecodeEmitter, rd: i64, rs: i64) {
    emitRegReg(e, OP_MOV, rd, rs)
}

fn emitMovI(e: BytecodeEmitter, rd: i64, imm: i64) {
    if (imm >= -128 and imm <= 127) {
        emitRegImm8(e, OP_MOVI, rd, imm)
    } else if (imm >= -32768 and imm <= 32767) {
        emitRegU16(e, OP_MOVI16, rd, imm)
    } else {
        emitOpcode(e, OP_MOVI32)
        emitByte(e, packRegs(rd, 0))
        emitU32(e, imm)
    }
}

fn emitLoadConst(e: BytecodeEmitter, rd: i64, idx: i64) {
    emitRegU16(e, OP_LOAD_CONST, rd, idx)
}

fn emitLoadNull(e: BytecodeEmitter, rd: i64) {
    emitRegReg(e, OP_LOAD_NULL, rd, 0)
}

fn emitLoadTrue(e: BytecodeEmitter, rd: i64) {
    emitRegReg(e, OP_LOAD_TRUE, rd, 0)
}

fn emitLoadFalse(e: BytecodeEmitter, rd: i64) {
    emitRegReg(e, OP_LOAD_FALSE, rd, 0)
}

fn emitLoadLocal(e: BytecodeEmitter, rd: i64, slot: i64) {
    if (slot <= 255) {
        emitRegImm8(e, OP_LOAD_LOCAL, rd, slot)
    } else {
        emitRegU16(e, OP_LOAD_LOCAL16, rd, slot)
    }
}

fn emitStoreLocal(e: BytecodeEmitter, rs: i64, slot: i64) {
    if (slot <= 255) {
        emitRegImm8(e, OP_STORE_LOCAL, rs, slot)
    } else {
        emitRegU16(e, OP_STORE_LOCAL16, rs, slot)
    }
}

fn emitLoadGlobal(e: BytecodeEmitter, rd: i64, idx: i64) {
    emitRegU16(e, OP_LOAD_GLOBAL, rd, idx)
}

fn emitStoreGlobal(e: BytecodeEmitter, rs: i64, idx: i64) {
    emitRegU16(e, OP_STORE_GLOBAL, rs, idx)
}

fn emitAdd(e: BytecodeEmitter, rd: i64, rs1: i64, rs2: i64) {
    emitReg3(e, OP_ADD, rd, rs1, rs2)
}

fn emitSub(e: BytecodeEmitter, rd: i64, rs1: i64, rs2: i64) {
    emitReg3(e, OP_SUB, rd, rs1, rs2)
}

fn emitMul(e: BytecodeEmitter, rd: i64, rs1: i64, rs2: i64) {
    emitReg3(e, OP_MUL, rd, rs1, rs2)
}

fn emitDiv(e: BytecodeEmitter, rd: i64, rs1: i64, rs2: i64) {
    emitReg3(e, OP_DIV, rd, rs1, rs2)
}

fn emitMod(e: BytecodeEmitter, rd: i64, rs1: i64, rs2: i64) {
    emitReg3(e, OP_MOD, rd, rs1, rs2)
}

fn emitNeg(e: BytecodeEmitter, rd: i64, rs: i64) {
    emitRegReg(e, OP_NEG, rd, rs)
}

fn emitCmpEq(e: BytecodeEmitter, rd: i64, rs1: i64, rs2: i64) {
    emitReg3(e, OP_CMP_EQ, rd, rs1, rs2)
}

fn emitCmpNe(e: BytecodeEmitter, rd: i64, rs1: i64, rs2: i64) {
    emitReg3(e, OP_CMP_NE, rd, rs1, rs2)
}

fn emitCmpLt(e: BytecodeEmitter, rd: i64, rs1: i64, rs2: i64) {
    emitReg3(e, OP_CMP_LT, rd, rs1, rs2)
}

fn emitCmpLe(e: BytecodeEmitter, rd: i64, rs1: i64, rs2: i64) {
    emitReg3(e, OP_CMP_LE, rd, rs1, rs2)
}

fn emitCmpGt(e: BytecodeEmitter, rd: i64, rs1: i64, rs2: i64) {
    emitReg3(e, OP_CMP_GT, rd, rs1, rs2)
}

fn emitCmpGe(e: BytecodeEmitter, rd: i64, rs1: i64, rs2: i64) {
    emitReg3(e, OP_CMP_GE, rd, rs1, rs2)
}

fn emitLogAnd(e: BytecodeEmitter, rd: i64, rs1: i64, rs2: i64) {
    emitReg3(e, OP_LOG_AND, rd, rs1, rs2)
}

fn emitLogOr(e: BytecodeEmitter, rd: i64, rs1: i64, rs2: i64) {
    emitReg3(e, OP_LOG_OR, rd, rs1, rs2)
}

fn emitLogNot(e: BytecodeEmitter, rd: i64, rs: i64) {
    emitRegReg(e, OP_LOG_NOT, rd, rs)
}

fn emitBitAnd(e: BytecodeEmitter, rd: i64, rs1: i64, rs2: i64) {
    emitReg3(e, OP_BIT_AND, rd, rs1, rs2)
}

fn emitBitOr(e: BytecodeEmitter, rd: i64, rs1: i64, rs2: i64) {
    emitReg3(e, OP_BIT_OR, rd, rs1, rs2)
}

fn emitBitXor(e: BytecodeEmitter, rd: i64, rs1: i64, rs2: i64) {
    emitReg3(e, OP_BIT_XOR, rd, rs1, rs2)
}

fn emitBitNot(e: BytecodeEmitter, rd: i64, rs: i64) {
    emitRegReg(e, OP_BIT_NOT, rd, rs)
}

fn emitShl(e: BytecodeEmitter, rd: i64, rs1: i64, rs2: i64) {
    emitReg3(e, OP_SHL, rd, rs1, rs2)
}

fn emitShr(e: BytecodeEmitter, rd: i64, rs1: i64, rs2: i64) {
    emitReg3(e, OP_SHR, rd, rs1, rs2)
}

fn emitJmp(e: BytecodeEmitter, offset: i64) {
    emitOpcode(e, OP_JMP)
    emitByte(e, 0)
    emitU16(e, offset)
}

fn emitJz(e: BytecodeEmitter, rs: i64, offset: i64) {
    emitOpcode(e, OP_JZ)
    emitByte(e, packRegs(rs, 0))
    emitU16(e, offset)
}

fn emitJnz(e: BytecodeEmitter, rs: i64, offset: i64) {
    emitOpcode(e, OP_JNZ)
    emitByte(e, packRegs(rs, 0))
    emitU16(e, offset)
}

fn emitCall(e: BytecodeEmitter, routine_idx: i64, argc: i64) {
    emitOpcode(e, OP_CALL)
    emitByte(e, packRegs(argc, 0))
    emitU16(e, routine_idx)
}

fn emitCallNative(e: BytecodeEmitter, native_idx: i64, argc: i64) {
    emitOpcode(e, OP_CALL_NATIVE)
    emitByte(e, packRegs(argc, 0))
    emitU16(e, native_idx)
}

fn emitRet(e: BytecodeEmitter) {
    emitRegReg(e, OP_RET, 0, 0)
}

fn emitRetVal(e: BytecodeEmitter, rs: i64) {
    emitRegReg(e, OP_RET_VAL, rs, 0)
}

fn emitNewRecord(e: BytecodeEmitter, rd: i64, type_idx: i64) {
    emitRegU16(e, OP_NEW_RECORD, rd, type_idx)
}

fn emitLoadField(e: BytecodeEmitter, rd: i64, rs: i64, field_idx: i64) {
    emitOpcode(e, OP_LOAD_FIELD)
    emitByte(e, packRegs(rd, rs))
    emitU16(e, field_idx)
}

fn emitStoreField(e: BytecodeEmitter, rd: i64, rs: i64, field_idx: i64) {
    emitOpcode(e, OP_STORE_FIELD)
    emitByte(e, packRegs(rd, rs))
    emitU16(e, field_idx)
}

fn emitStrConcat(e: BytecodeEmitter, rd: i64, rs1: i64, rs2: i64) {
    emitReg3(e, OP_STR_CONCAT, rd, rs1, rs2)
}

fn emitStrLen(e: BytecodeEmitter, rd: i64, rs: i64) {
    emitRegReg(e, OP_STR_LEN, rd, rs)
}

fn emitPrint(e: BytecodeEmitter, rs: i64, argc: i64) {
    emitOpcode(e, OP_PRINT)
    emitByte(e, packRegs(rs, argc))
    emitByte(e, 0)
}

fn emitPrintln(e: BytecodeEmitter, rs: i64, argc: i64) {
    emitOpcode(e, OP_PRINTLN)
    emitByte(e, packRegs(rs, argc))
    emitByte(e, 0)
}

fn emitListNew(e: BytecodeEmitter, rd: i64) {
    emitRegReg(e, OP_LIST_NEW, rd, 0)
}

fn emitListPush(e: BytecodeEmitter, list_reg: i64, val_reg: i64) {
    emitRegReg(e, OP_LIST_PUSH, list_reg, val_reg)
}

fn emitListPop(e: BytecodeEmitter, rd: i64, list_reg: i64) {
    emitRegReg(e, OP_LIST_POP, rd, list_reg)
}

fn emitListGet(e: BytecodeEmitter, rd: i64, list_reg: i64, idx_reg: i64) {
    emitOpcode(e, OP_LIST_GET)
    emitByte(e, packRegs(rd, list_reg))
    emitByte(e, packRegs(idx_reg, 0))
}

fn emitListSet(e: BytecodeEmitter, list_reg: i64, idx_reg: i64, val_reg: i64) {
    emitOpcode(e, OP_LIST_SET)
    emitByte(e, packRegs(list_reg, idx_reg))
    emitByte(e, packRegs(val_reg, 0))
}

fn emitListLen(e: BytecodeEmitter, rd: i64, list_reg: i64) {
    emitRegReg(e, OP_LIST_LEN, rd, list_reg)
}

fn emitMapNew(e: BytecodeEmitter, rd: i64, flags: i64) {
    emitRegReg(e, OP_MAP_NEW, rd, flags)
}

fn emitMapSet(e: BytecodeEmitter, map_reg: i64, key_reg: i64, val_reg: i64) {
    emitOpcode(e, OP_MAP_SET)
    emitByte(e, packRegs(map_reg, key_reg))
    emitByte(e, packRegs(val_reg, 0))
}

fn emitMapGet(e: BytecodeEmitter, rd: i64, map_reg: i64, key_reg: i64) {
    emitOpcode(e, OP_MAP_GET)
    emitByte(e, packRegs(rd, map_reg))
    emitByte(e, packRegs(key_reg, 0))
}

fn emitMapHas(e: BytecodeEmitter, rd: i64, map_reg: i64, key_reg: i64) {
    emitOpcode(e, OP_MAP_HAS)
    emitByte(e, packRegs(rd, map_reg))
    emitByte(e, packRegs(key_reg, 0))
}

fn emitMapLen(e: BytecodeEmitter, rd: i64, map_reg: i64) {
    emitRegReg(e, OP_MAP_LEN, rd, map_reg)
}

fn emitMapDelete(e: BytecodeEmitter, map_reg: i64, key_reg: i64) {
    emitRegReg(e, OP_MAP_DELETE, map_reg, key_reg)
}

fn emitDebugLine(e: BytecodeEmitter, line: i64) {
    emitOpcode(e, OP_DEBUG_LINE)
    emitByte(e, 0)
    emitU16(e, line)
}

fn emitSetErrorHandler(e: BytecodeEmitter, target_block: i64) {
    // Format: [opcode][offset_lo][offset_hi] = 3 bytes
    emitOpcode(e, OP_SET_ERROR_HANDLER)
    emitU16(e, 0)  // Placeholder, will be patched
    emitAddPendingJump(e, target_block, false)
}

fn emitClearErrorHandler(e: BytecodeEmitter) {
    // Format: [opcode] = 1 byte
    emitOpcode(e, OP_CLEAR_ERROR_HANDLER)
}

fn emitThrow(e: BytecodeEmitter, rs: i64) {
    // Format: [opcode][rs:4|0][0] = 3 bytes
    emitOpcode(e, OP_THROW)
    emitByte(e, packRegs(rs, 0))
    emitByte(e, 0)
}

fn emitHalt(e: BytecodeEmitter) {
    emitOpcode(e, OP_HALT)
}

fn emitNop(e: BytecodeEmitter) {
    emitOpcode(e, OP_NOP)
}

// =============================================================================
// P0 Critical Emit Functions - Required for Self-Hosting
// =============================================================================

// Stack pointer operations - for passing structs by pointer

/// get_local_ptr rd, slot - rd = stack pointer to local slot
/// Format: [rd:4|0] [slot:16]
fn emitGetLocalPtr(e: BytecodeEmitter, rd: i64, slot: i64) {
    emitRegU16(e, OP_GET_LOCAL_PTR, rd, slot)
}

/// load_indirect rd, rs, offset - rd = ptr_val[offset]
/// Format: [rd:4|rs:4] [offset:16]
fn emitLoadIndirect(e: BytecodeEmitter, rd: i64, rs: i64, offset: i64) {
    emitOpcode(e, OP_LOAD_INDIRECT)
    emitByte(e, packRegs(rd, rs))
    emitU16(e, offset)
}

/// store_indirect rs_ptr, offset, rs_val - ptr_val[offset] = rs_val
/// Format: [rs_ptr:4|rs_val:4] [offset:16]
fn emitStoreIndirect(e: BytecodeEmitter, rs_ptr: i64, offset: i64, rs_val: i64) {
    emitOpcode(e, OP_STORE_INDIRECT)
    emitByte(e, packRegs(rs_ptr, rs_val))
    emitU16(e, offset)
}

/// ptr_offset rd, rs, offset - pointer arithmetic for derived pointers
/// Format: [rd:4|rs:4] [offset:16]
fn emitPtrOffset(e: BytecodeEmitter, rd: i64, rs: i64, offset: i64) {
    emitOpcode(e, OP_PTR_OFFSET)
    emitByte(e, packRegs(rd, rs))
    emitU16(e, offset)
}

// Variant (sum type) operations

/// variant_construct rd, tag, argc - construct variant with payload
/// Payload values are in r0..r(argc-1)
/// Format: [rd:4|argc:4] [tag:16]
fn emitVariantConstruct(e: BytecodeEmitter, rd: i64, tag: i64, argc: i64) {
    emitOpcode(e, OP_VARIANT_CONSTRUCT)
    emitByte(e, packRegs(rd, argc))
    emitU16(e, tag)
}

/// variant_get_tag rd, src_reg - get the tag from a variant
/// Format: [rd:4|src_reg:4] [0]
fn emitVariantGetTag(e: BytecodeEmitter, rd: i64, src: i64) {
    emitRegReg(e, OP_VARIANT_GET_TAG, rd, src)
}

/// variant_get_payload rd, src_reg, field_idx - get payload field from variant
/// Format: [rd:4|src_reg:4] [field_idx:16]
fn emitVariantGetPayload(e: BytecodeEmitter, rd: i64, src: i64, field_idx: i64) {
    emitOpcode(e, OP_VARIANT_GET_PAYLOAD)
    emitByte(e, packRegs(rd, src))
    emitU16(e, field_idx)
}

// ARC (Automatic Reference Counting) operations

/// arc_retain rs - increment reference count of heap value
/// Format: [rs:4|0] [0]
fn emitArcRetain(e: BytecodeEmitter, rs: i64) {
    emitRegReg(e, OP_ARC_RETAIN, rs, 0)
}

/// arc_release rs - decrement reference count (may free)
/// Format: [rs:4|0] [0]
fn emitArcRelease(e: BytecodeEmitter, rs: i64) {
    emitRegReg(e, OP_ARC_RELEASE, rs, 0)
}

/// arc_move rd, rs - move value without ARC (transfer ownership)
/// Format: [rd:4|rs:4] [0]
fn emitArcMove(e: BytecodeEmitter, rd: i64, rs: i64) {
    emitRegReg(e, OP_ARC_MOVE, rd, rs)
}

// Closure operations

/// make_closure rd, env_reg, fn_idx - create closure from function and environment
/// Format: [rd:4|env_reg:4] [fn_idx:16]
fn emitMakeClosure(e: BytecodeEmitter, rd: i64, env_reg: i64, fn_idx: i64) {
    emitOpcode(e, OP_MAKE_CLOSURE)
    emitByte(e, packRegs(rd, env_reg))
    emitU16(e, fn_idx)
}

/// call_closure rd, closure_reg, argc - call a closure
/// Format: [rd:4|closure_reg:4] [argc:8]
fn emitCallClosure(e: BytecodeEmitter, rd: i64, closure_reg: i64, argc: i64) {
    emitOpcode(e, OP_CALL_CLOSURE)
    emitByte(e, packRegs(rd, closure_reg))
    emitByte(e, argc)
}

// =============================================================================
// P1 Important Emit Functions - Full Language Support
// =============================================================================

// Comparison jump operations

/// jeq rs1, rs2, offset - jump if rs1 == rs2
/// Format: [rs1:4|rs2:4] [offset:16]
fn emitJeq(e: BytecodeEmitter, rs1: i64, rs2: i64, offset: i64) {
    emitOpcode(e, OP_JEQ)
    emitByte(e, packRegs(rs1, rs2))
    emitU16(e, offset)
}

/// jne rs1, rs2, offset - jump if rs1 != rs2
fn emitJne(e: BytecodeEmitter, rs1: i64, rs2: i64, offset: i64) {
    emitOpcode(e, OP_JNE)
    emitByte(e, packRegs(rs1, rs2))
    emitU16(e, offset)
}

/// jlt rs1, rs2, offset - jump if rs1 < rs2
fn emitJlt(e: BytecodeEmitter, rs1: i64, rs2: i64, offset: i64) {
    emitOpcode(e, OP_JLT)
    emitByte(e, packRegs(rs1, rs2))
    emitU16(e, offset)
}

/// jge rs1, rs2, offset - jump if rs1 >= rs2
fn emitJge(e: BytecodeEmitter, rs1: i64, rs2: i64, offset: i64) {
    emitOpcode(e, OP_JGE)
    emitByte(e, packRegs(rs1, rs2))
    emitU16(e, offset)
}

/// jmp32 offset - unconditional jump with 32-bit offset
/// Format: [0] [offset:32]
fn emitJmp32(e: BytecodeEmitter, offset: i64) {
    emitOpcode(e, OP_JMP32)
    emitU32(e, offset)
}

/// loop_start - mark start of loop (for profiling)
fn emitLoopStart(e: BytecodeEmitter) {
    emitOpcode(e, OP_LOOP_START)
}

/// loop_end - mark end of loop
fn emitLoopEnd(e: BytecodeEmitter) {
    emitOpcode(e, OP_LOOP_END)
}

// Increment/decrement operations

/// incr rd - rd = rd + 1
/// Format: [rd:4|0] [0]
fn emitIncr(e: BytecodeEmitter, rd: i64) {
    emitRegReg(e, OP_INCR, rd, 0)
}

/// decr rd - rd = rd - 1
/// Format: [rd:4|0] [0]
fn emitDecr(e: BytecodeEmitter, rd: i64) {
    emitRegReg(e, OP_DECR, rd, 0)
}

// Type checking operations

/// is_null rd, rs - rd = (rs == null)
/// Format: [rd:4|rs:4] [0]
fn emitIsNull(e: BytecodeEmitter, rd: i64, rs: i64) {
    emitRegReg(e, OP_IS_NULL, rd, rs)
}

/// select rd, cond, rtrue, rfalse - rd = cond ? rtrue : rfalse
/// Format: [rd:4|cond:4] [rtrue:4|rfalse:4]
fn emitSelect(e: BytecodeEmitter, rd: i64, cond: i64, rtrue: i64, rfalse: i64) {
    emitOpcode(e, OP_SELECT)
    emitByte(e, packRegs(rd, cond))
    emitByte(e, packRegs(rtrue, rfalse))
}

/// is_type rd, rs, type_tag - rd = (rs is type_tag)
/// Format: [rd:4|rs:4] [type_tag:8]
fn emitIsType(e: BytecodeEmitter, rd: i64, rs: i64, type_tag: i64) {
    emitOpcode(e, OP_IS_TYPE)
    emitByte(e, packRegs(rd, rs))
    emitByte(e, type_tag)
}

// String operations

/// str_index rd, rs, idx_reg - rd = rs[idx_reg]
/// Format: [rd:4|rs:4] [idx_reg:4|0]
fn emitStrIndex(e: BytecodeEmitter, rd: i64, rs: i64, idx_reg: i64) {
    emitOpcode(e, OP_STR_INDEX)
    emitByte(e, packRegs(rd, rs))
    emitByte(e, packRegs(idx_reg, 0))
}

/// str_slice rd, rs, start_reg, len_reg - rd = rs[start:start+len]
/// Format: [rd:4|rs:4] [start_reg:4|len_reg:4]
fn emitStrSlice(e: BytecodeEmitter, rd: i64, rs: i64, start_reg: i64, len_reg: i64) {
    emitOpcode(e, OP_STR_SLICE)
    emitByte(e, packRegs(rd, rs))
    emitByte(e, packRegs(start_reg, len_reg))
}

/// str_slice_store rd, start_reg, len_reg, val_reg - rd[start:len] = val
/// Format: [rd:4|start_reg:4] [len_reg:4|val_reg:4]
fn emitStrSliceStore(e: BytecodeEmitter, rd: i64, start_reg: i64, len_reg: i64, val_reg: i64) {
    emitOpcode(e, OP_STR_SLICE_STORE)
    emitByte(e, packRegs(rd, start_reg))
    emitByte(e, packRegs(len_reg, val_reg))
}

/// str_trim rd, rs - rd = trim(rs)
fn emitStrTrim(e: BytecodeEmitter, rd: i64, rs: i64) {
    emitRegReg(e, OP_STR_TRIM, rd, rs)
}

/// str_upper rd, rs - rd = upper(rs)
fn emitStrUpper(e: BytecodeEmitter, rd: i64, rs: i64) {
    emitRegReg(e, OP_STR_UPPER, rd, rs)
}

/// str_lower rd, rs - rd = lower(rs)
fn emitStrLower(e: BytecodeEmitter, rd: i64, rs: i64) {
    emitRegReg(e, OP_STR_LOWER, rd, rs)
}

/// str_find rd, rs1, rs2 - rd = find position of rs2 in rs1
fn emitStrFind(e: BytecodeEmitter, rd: i64, rs1: i64, rs2: i64) {
    emitReg3(e, OP_STR_FIND, rd, rs1, rs2)
}

/// str_replace rd, rs, old_reg, new_reg - rd = replace in rs
/// Format: [rd:4|rs:4] [old_reg:4|new_reg:4]
fn emitStrReplace(e: BytecodeEmitter, rd: i64, rs: i64, old_reg: i64, new_reg: i64) {
    emitOpcode(e, OP_STR_REPLACE)
    emitByte(e, packRegs(rd, rs))
    emitByte(e, packRegs(old_reg, new_reg))
}

/// str_setchar rd, idx_reg, char_reg - rd[idx] = char
/// Format: [rd:4|idx_reg:4] [char_reg:4|0]
fn emitStrSetchar(e: BytecodeEmitter, rd: i64, idx_reg: i64, char_reg: i64) {
    emitOpcode(e, OP_STR_SETCHAR)
    emitByte(e, packRegs(rd, idx_reg))
    emitByte(e, packRegs(char_reg, 0))
}

// String comparison operations

fn emitCmpStrEq(e: BytecodeEmitter, rd: i64, rs1: i64, rs2: i64) {
    emitReg3(e, OP_CMP_STR_EQ, rd, rs1, rs2)
}

fn emitCmpStrLt(e: BytecodeEmitter, rd: i64, rs1: i64, rs2: i64) {
    emitReg3(e, OP_CMP_STR_LT, rd, rs1, rs2)
}

fn emitCmpStrNe(e: BytecodeEmitter, rd: i64, rs1: i64, rs2: i64) {
    emitReg3(e, OP_CMP_STR_NE, rd, rs1, rs2)
}

fn emitCmpStrLe(e: BytecodeEmitter, rd: i64, rs1: i64, rs2: i64) {
    emitReg3(e, OP_CMP_STR_LE, rd, rs1, rs2)
}

fn emitCmpStrGt(e: BytecodeEmitter, rd: i64, rs1: i64, rs2: i64) {
    emitReg3(e, OP_CMP_STR_GT, rd, rs1, rs2)
}

fn emitCmpStrGe(e: BytecodeEmitter, rd: i64, rs1: i64, rs2: i64) {
    emitReg3(e, OP_CMP_STR_GE, rd, rs1, rs2)
}

// Struct-in-collection operations

/// list_push_struct list_reg, base_slot, field_count - push struct from consecutive slots
/// Format: [list:4|0] [field_count:8] [base_slot:16]
fn emitListPushStruct(e: BytecodeEmitter, list_reg: i64, base_slot: i64, field_count: i64) {
    emitOpcode(e, OP_LIST_PUSH_STRUCT)
    emitByte(e, packRegs(list_reg, 0))
    emitByte(e, field_count)
    emitU16(e, base_slot)
}

/// list_get_struct list_reg, idx_reg, field_count, base_reg - get struct to high registers
/// Format: [list:4|idx:4] [field_count:8] [base_reg:8] [0]
fn emitListGetStruct(e: BytecodeEmitter, list_reg: i64, idx_reg: i64, field_count: i64, base_reg: i64) {
    emitOpcode(e, OP_LIST_GET_STRUCT)
    emitByte(e, packRegs(list_reg, idx_reg))
    emitByte(e, field_count)
    emitByte(e, base_reg)
    emitByte(e, 0)
}

/// list_pop_struct dest_slot, list_reg, field_count - pop struct to slots
/// Format: [list:4|0] [field_count:8] [dest_slot:16]
fn emitListPopStruct(e: BytecodeEmitter, list_reg: i64, dest_slot: i64, field_count: i64) {
    emitOpcode(e, OP_LIST_POP_STRUCT)
    emitByte(e, packRegs(list_reg, 0))
    emitByte(e, field_count)
    emitU16(e, dest_slot)
}

/// list_set_struct list_reg, idx_reg, base_slot, field_count - set struct from slots
/// Format: [list:4|idx:4] [field_count:8] [base_slot:16]
fn emitListSetStruct(e: BytecodeEmitter, list_reg: i64, idx_reg: i64, base_slot: i64, field_count: i64) {
    emitOpcode(e, OP_LIST_SET_STRUCT)
    emitByte(e, packRegs(list_reg, idx_reg))
    emitByte(e, field_count)
    emitU16(e, base_slot)
}

/// map_set_struct map_reg, key_reg, base_slot, field_count - store struct to map
/// Format: [map:4|key:4] [field_count:8] [base_slot:16]
fn emitMapSetStruct(e: BytecodeEmitter, map_reg: i64, key_reg: i64, base_slot: i64, field_count: i64) {
    emitOpcode(e, OP_MAP_SET_STRUCT)
    emitByte(e, packRegs(map_reg, key_reg))
    emitByte(e, field_count)
    emitU16(e, base_slot)
}

/// map_get_struct map_reg, key_reg, field_count, base_reg - get struct from map
/// Format: [map:4|key:4] [field_count:8] [base_reg:8] [0]
fn emitMapGetStruct(e: BytecodeEmitter, map_reg: i64, key_reg: i64, field_count: i64, base_reg: i64) {
    emitOpcode(e, OP_MAP_GET_STRUCT)
    emitByte(e, packRegs(map_reg, key_reg))
    emitByte(e, field_count)
    emitByte(e, base_reg)
    emitByte(e, 0)
}

// Call variant operations

/// call_indirect rs, argc - call function pointer in rs
/// Format: [argc:4|rs:4] [0]
fn emitCallIndirect(e: BytecodeEmitter, rs: i64, argc: i64) {
    emitOpcode(e, OP_CALL_INDIRECT)
    emitByte(e, packRegs(argc, rs))
    emitByte(e, 0)
}

/// call_dynamic name_idx, argc - call by name at runtime
/// Format: [argc:4|0] [name_idx:16]
fn emitCallDynamic(e: BytecodeEmitter, name_idx: i64, argc: i64) {
    emitOpcode(e, OP_CALL_DYNAMIC)
    emitByte(e, packRegs(argc, 0))
    emitU16(e, name_idx)
}

/// push_arg slot - push local slot value to stack for overflow args
/// Format: [slot_lo:8] [slot_hi:8]
fn emitPushArg(e: BytecodeEmitter, slot: i64) {
    emitOpcode(e, OP_PUSH_ARG)
    emitU16(e, slot)
}

/// push_arg_reg rs - push register value to stack for overflow args
/// Format: [rs:4|0] [0]
fn emitPushArgReg(e: BytecodeEmitter, rs: i64) {
    emitRegReg(e, OP_PUSH_ARG_REG, rs, 0)
}

/// pop_arg slot - pop stack value to local slot (callee prologue)
/// Format: [slot_lo:8] [slot_hi:8]
fn emitPopArg(e: BytecodeEmitter, slot: i64) {
    emitOpcode(e, OP_POP_ARG)
    emitU16(e, slot)
}

// List extras

/// list_clear list_reg - list.clear()
/// Format: [list:4|0] [0]
fn emitListClear(e: BytecodeEmitter, list_reg: i64) {
    emitRegReg(e, OP_LIST_CLEAR, list_reg, 0)
}

/// list_to_slice rd, list_reg - rd = list.to_slice()
/// Format: [rd:4|list:4] [0]
fn emitListToSlice(e: BytecodeEmitter, rd: i64, list_reg: i64) {
    emitRegReg(e, OP_LIST_TO_SLICE, rd, list_reg)
}

// Map extras

/// map_clear map_reg - map.clear()
/// Format: [map:4|0] [0]
fn emitMapClear(e: BytecodeEmitter, map_reg: i64) {
    emitRegReg(e, OP_MAP_CLEAR, map_reg, 0)
}

/// map_keys rd, map_reg - rd = array of keys
/// Format: [rd:4|map:4] [0]
fn emitMapKeys(e: BytecodeEmitter, rd: i64, map_reg: i64) {
    emitRegReg(e, OP_MAP_KEYS, rd, map_reg)
}

/// map_values rd, map_reg - rd = array of values
/// Format: [rd:4|map:4] [0]
fn emitMapValues(e: BytecodeEmitter, rd: i64, map_reg: i64) {
    emitRegReg(e, OP_MAP_VALUES, rd, map_reg)
}

/// map_get_at rd, map_reg, idx_reg - rd = map entry at position (1-based)
/// Format: [rd:4|map:4] [idx:4|0]
fn emitMapGetAt(e: BytecodeEmitter, rd: i64, map_reg: i64, idx_reg: i64) {
    emitOpcode(e, OP_MAP_GET_AT)
    emitByte(e, packRegs(rd, map_reg))
    emitByte(e, packRegs(idx_reg, 0))
}

/// map_set_at map_reg, idx_reg, val_reg - map[pos] = val (by position)
/// Format: [map:4|idx:4] [val:4|0]
fn emitMapSetAt(e: BytecodeEmitter, map_reg: i64, idx_reg: i64, val_reg: i64) {
    emitOpcode(e, OP_MAP_SET_AT)
    emitByte(e, packRegs(map_reg, idx_reg))
    emitByte(e, packRegs(val_reg, 0))
}

/// map_key_at rd, map_reg, idx_reg - rd = key at position (1-based)
/// Format: [rd:4|map:4] [idx:4|0]
fn emitMapKeyAt(e: BytecodeEmitter, rd: i64, map_reg: i64, idx_reg: i64) {
    emitOpcode(e, OP_MAP_KEY_AT)
    emitByte(e, packRegs(rd, map_reg))
    emitByte(e, packRegs(idx_reg, 0))
}

// =============================================================================
// P2 Nice-to-Have Emit Functions
// =============================================================================

// Array operations

/// array_load idx_reg, slot - load arr[idx] into r0
/// Format: [idx_reg:8] [slot:16]
fn emitArrayLoad(e: BytecodeEmitter, idx_reg: i64, slot: i64) {
    emitOpcode(e, OP_ARRAY_LOAD)
    emitByte(e, idx_reg)
    emitU16(e, slot)
}

/// array_store idx_reg, val_reg, slot - arr[idx] = val
/// Format: [idx_reg:4|val_reg:4] [slot:16]
fn emitArrayStore(e: BytecodeEmitter, idx_reg: i64, val_reg: i64, slot: i64) {
    emitOpcode(e, OP_ARRAY_STORE)
    emitByte(e, packRegs(idx_reg, val_reg))
    emitU16(e, slot)
}

/// array_len rd, slot - rd = len(arr)
/// Format: [rd:8] [slot:16]
fn emitArrayLen(e: BytecodeEmitter, rd: i64, slot: i64) {
    emitOpcode(e, OP_ARRAY_LEN)
    emitByte(e, rd)
    emitU16(e, slot)
}

/// array_slice rd, start_reg, end_reg, slot - rd = arr[start..end]
/// Format: [rd:4|inclusive:1|0:3] [start_reg:4|end_reg:4] [slot_lo:8] [slot_hi:8]
fn emitArraySlice(e: BytecodeEmitter, rd: i64, start_reg: i64, end_reg: i64, slot: i64, inclusive: bool) {
    emitOpcode(e, OP_ARRAY_SLICE)
    var flags: i64 = 0
    if (inclusive) {
        flags = 0x08
    }
    emitByte(e, packRegs(rd, flags))
    emitByte(e, packRegs(start_reg, end_reg))
    emitU16(e, slot)
}

// Type conversion operations

/// to_int rd, rs - rd = int(rs)
fn emitToInt(e: BytecodeEmitter, rd: i64, rs: i64) {
    emitRegReg(e, OP_TO_INT, rd, rs)
}

/// to_str rd, rs - rd = str(rs)
fn emitToStr(e: BytecodeEmitter, rd: i64, rs: i64) {
    emitRegReg(e, OP_TO_STR, rd, rs)
}

/// to_bool rd, rs - rd = bool(rs)
fn emitToBool(e: BytecodeEmitter, rd: i64, rs: i64) {
    emitRegReg(e, OP_TO_BOOL, rd, rs)
}

/// to_dec rd, rs, prec - rd = decimal(rs, precision)
/// Format: [rd:4|rs:4] [prec:8]
fn emitToDec(e: BytecodeEmitter, rd: i64, rs: i64, prec: i64) {
    emitOpcode(e, OP_TO_DEC)
    emitByte(e, packRegs(rd, rs))
    emitByte(e, prec)
}

/// to_char rd, rs - rd = char(rs) (int to single char string)
fn emitToChar(e: BytecodeEmitter, rd: i64, rs: i64) {
    emitRegReg(e, OP_TO_CHAR, rd, rs)
}

/// to_fixed_string rd, rs, size - rd = fixed_string(rs, size)
/// Format: [rd:4|rs:4] [size:16]
fn emitToFixedString(e: BytecodeEmitter, rd: i64, rs: i64, size: i64) {
    emitOpcode(e, OP_TO_FIXED_STRING)
    emitByte(e, packRegs(rd, rs))
    emitU16(e, size)
}

/// format_decimal rd, rs, width - rd = zero-padded decimal string of rs
/// Format: [rd:4|rs:4] [width:8]
fn emitFormatDecimal(e: BytecodeEmitter, rd: i64, rs: i64, width: i64) {
    emitOpcode(e, OP_FORMAT_DECIMAL)
    emitByte(e, packRegs(rd, rs))
    emitByte(e, width)
}

/// parse_decimal rd, rs - rd = integer parsed from string rs
/// Format: [rd:4|rs:4] [0]
fn emitParseDecimal(e: BytecodeEmitter, rd: i64, rs: i64) {
    emitRegReg(e, OP_PARSE_DECIMAL, rd, rs)
}

// Record extras

/// free_record rs - free record in rs
/// Format: [rs:4|0] [0]
fn emitFreeRecord(e: BytecodeEmitter, rs: i64) {
    emitRegReg(e, OP_FREE_RECORD, rs, 0)
}

/// clear_record rs - clear record fields
/// Format: [rs:4|0] [0]
fn emitClearRecord(e: BytecodeEmitter, rs: i64) {
    emitRegReg(e, OP_CLEAR_RECORD, rs, 0)
}

/// alloc_buffer slot, size - allocate mutable buffer of given size
/// Format: [slot:8] [size:16]
fn emitAllocBuffer(e: BytecodeEmitter, slot: i64, size: i64) {
    emitOpcode(e, OP_ALLOC_BUFFER)
    emitByte(e, slot)
    emitU16(e, size)
}

// Weak reference operations

/// weak_ref rd, rs - create weak reference: rd = weak(rs)
/// Format: [rd:4|rs:4] [0]
fn emitWeakRef(e: BytecodeEmitter, rd: i64, rs: i64) {
    emitRegReg(e, OP_WEAK_REF, rd, rs)
}

/// weak_load rd, rs - load from weak reference: rd = *rs (or null if freed)
/// Format: [rd:4|rs:4] [0]
fn emitWeakLoad(e: BytecodeEmitter, rd: i64, rs: i64) {
    emitRegReg(e, OP_WEAK_LOAD, rd, rs)
}

// Trait object operations

/// make_trait_object rd, src_reg, vtable_idx - create trait object from value
/// Format: [rd:4|src_reg:4] [vtable_idx:16]
fn emitMakeTraitObject(e: BytecodeEmitter, rd: i64, src_reg: i64, vtable_idx: i64) {
    emitOpcode(e, OP_MAKE_TRAIT_OBJECT)
    emitByte(e, packRegs(rd, src_reg))
    emitU16(e, vtable_idx)
}

/// call_trait_method rd, obj_reg, method_idx, argc - call method on trait object
/// Format: [rd:4|obj_reg:4] [method_idx:8] [argc:8]
fn emitCallTraitMethod(e: BytecodeEmitter, rd: i64, obj_reg: i64, method_idx: i64, argc: i64) {
    emitOpcode(e, OP_CALL_TRAIT_METHOD)
    emitByte(e, packRegs(rd, obj_reg))
    emitByte(e, method_idx)
    emitByte(e, argc)
}

// I/O operations

/// readln rd - rd = read line from stdin
/// Format: [rd:4|0] [0]
fn emitReadln(e: BytecodeEmitter, rd: i64) {
    emitRegReg(e, OP_READLN, rd, 0)
}

/// readkey rd - rd = read single key
/// Format: [rd:4|0] [0]
fn emitReadkey(e: BytecodeEmitter, rd: i64) {
    emitRegReg(e, OP_READKEY, rd, 0)
}

/// log rs, argc - write to stderr (debugging)
/// Format: [rs:4|argc:4] [0]
fn emitLog(e: BytecodeEmitter, rs: i64, argc: i64) {
    emitOpcode(e, OP_LOG)
    emitByte(e, packRegs(rs, argc))
    emitByte(e, 0)
}

// Debug operations

/// debug_break - debugger breakpoint
fn emitDebugBreak(e: BytecodeEmitter) {
    emitOpcode(e, OP_DEBUG_BREAK)
}

/// assert rs - assert rs is true
/// Format: [rs:4|0] [0]
fn emitAssert(e: BytecodeEmitter, rs: i64) {
    emitRegReg(e, OP_ASSERT, rs, 0)
}

// =============================================================================
// Variable Management
// =============================================================================

fn emitAllocLocal(e: BytecodeEmitter, name: string) i64 {
    const slot = e.local_count
    e.local_count = e.local_count + 1
    const loc = VarLocation{
        .slot = slot,
        .is_global = false,
    }
    e.locals.set(name, loc)
    return slot
}

fn emitAllocGlobal(e: BytecodeEmitter, name: string) i64 {
    const slot = e.global_count
    e.global_count = e.global_count + 1
    const loc = VarLocation{
        .slot = slot,
        .is_global = true,
    }
    e.globals.set(name, loc)
    return slot
}

fn emitLookupVar(e: BytecodeEmitter, name: string) VarLocation {
    if (e.locals.has(name)) {
        return e.locals.get(name)
    }
    if (e.globals.has(name)) {
        return e.globals.get(name)
    }
    return VarLocation{
        .slot = -1,
        .is_global = false,
    }
}

// =============================================================================
// Block/Jump Management
// =============================================================================

fn emitRecordBlockOffset(e: BytecodeEmitter, block_id: i64) {
    e.block_offsets.set(block_id, e.code.len())
}

fn emitGetBlockOffset(e: BytecodeEmitter, block_id: i64) i64 {
    if (e.block_offsets.has(block_id)) {
        return e.block_offsets.get(block_id)
    }
    return -1
}

fn emitAddPendingJump(e: BytecodeEmitter, target_block: i64, is_wide: bool) {
    const jump = PendingJump{
        .patch_offset = e.code.len() - 2,
        .target_block = target_block,
        .is_wide = is_wide,
    }
    e.pending_jumps.push(jump)
}

fn emitPatchJumps(e: BytecodeEmitter) {
    var i: i64 = 0
    while (i < e.pending_jumps.len()) {
        const jump = e.pending_jumps.get(i)
        const target_offset = emitGetBlockOffset(e, jump.target_block)
        if (target_offset >= 0) {
            const patch_pos = jump.patch_offset
            const rel_offset = target_offset - (patch_pos + 2)
            e.code.set(patch_pos, rel_offset & 255)
            e.code.set(patch_pos + 1, (rel_offset >> 8) & 255)
        }
        i = i + 1
    }
}

// =============================================================================
// Current Code Position
// =============================================================================

fn emitCodeLen(e: BytecodeEmitter) i64 {
    return e.code.len()
}

// =============================================================================
// Module Serialization
// =============================================================================

// Section type constants (matches Zig module.zig)
const SECTION_CONSTANTS: i64 = 1
const SECTION_TYPES: i64 = 2
const SECTION_ROUTINES: i64 = 3
const SECTION_CODE: i64 = 4
const SECTION_EXPORTS: i64 = 5
const SECTION_IMPORTS: i64 = 6
const SECTION_DEBUG: i64 = 7

// Constant tag values (matches Zig module.zig)
const CONST_TAG_INTEGER: i64 = 1
const CONST_TAG_DECIMAL: i64 = 2
const CONST_TAG_STRING: i64 = 3
const CONST_TAG_FIXED_STRING: i64 = 4
const CONST_TAG_IDENTIFIER: i64 = 5
const CONST_TAG_RECORD_REF: i64 = 6
const CONST_TAG_ROUTINE_REF: i64 = 7
const CONST_TAG_FLOAT: i64 = 8
const CONST_TAG_BOOLEAN: i64 = 9

struct ModuleBuilder {
    header: List<i64>,
    section_table: List<i64>,
    constants_section: List<i64>,
    types_section: List<i64>,
    routines_section: List<i64>,
    code_section: List<i64>,
    exports_section: List<i64>,
    section_count: i64,
}

fn newModuleBuilder() ModuleBuilder {
    return ModuleBuilder{
        .header = new List<i64>,
        .section_table = new List<i64>,
        .constants_section = new List<i64>,
        .types_section = new List<i64>,
        .routines_section = new List<i64>,
        .code_section = new List<i64>,
        .exports_section = new List<i64>,
        .section_count = 0,
    }
}

fn mbWriteU8(list: List<i64>, val: i64) {
    list.push(val & 255)
}

fn mbWriteU16(list: List<i64>, val: i64) {
    list.push(val & 255)
    list.push((val >> 8) & 255)
}

fn mbWriteU32(list: List<i64>, val: i64) {
    list.push(val & 255)
    list.push((val >> 8) & 255)
    list.push((val >> 16) & 255)
    list.push((val >> 24) & 255)
}

fn mbWriteI64(list: List<i64>, val: i64) {
    mbWriteU32(list, val)
    mbWriteU32(list, val >> 32)
}

fn mbWriteString(list: List<i64>, s: string) {
    const slen = len(s)
    mbWriteU32(list, slen)
    var i: i64 = 0
    while (i < slen) {
        const ch = s[i..i+1]
        const code = ascii(ch)
        list.push(code)
        i = i + 1
    }
}

fn mbWriteHeader(mb: ModuleBuilder, entry_point: i64, source_hash: i64) {
    // Magic: CBO1
    mb.header.push(67)  // 'C'
    mb.header.push(66)  // 'B'
    mb.header.push(79)  // 'O'
    mb.header.push(49)  // '1'

    // Version major (u16)
    mbWriteU16(mb.header, VERSION_MAJOR)
    // Version minor (u16)
    mbWriteU16(mb.header, VERSION_MINOR)

    // Flags (u32) - has_debug_info=1 if we have debug
    mbWriteU32(mb.header, 0)

    // Section count (u32)
    mbWriteU32(mb.header, mb.section_count)

    // Entry point (u32)
    mbWriteU32(mb.header, entry_point)

    // Source hash (u32)
    mbWriteU32(mb.header, source_hash)

    // Reserved (8 bytes)
    var i: i64 = 0
    while (i < 8) {
        mb.header.push(0)
        i = i + 1
    }
}

fn mbWriteSectionEntry(mb: ModuleBuilder, section_type: i64, offset: i64, size_val: i64, entry_count: i64) {
    mbWriteU32(mb.section_table, section_type)
    mbWriteU32(mb.section_table, offset)
    mbWriteU32(mb.section_table, size_val)
    mbWriteU32(mb.section_table, entry_count)
}

fn mbWriteConstant(list: List<i64>, entry: ConstantEntry) {
    switch (entry.tag) {
        ConstantTag.Integer => {
            list.push(CONST_TAG_INTEGER)
            mbWriteI64(list, entry.int_val)
        }
        ConstantTag.Decimal => {
            list.push(CONST_TAG_DECIMAL)
            mbWriteI64(list, entry.int_val)
            list.push(entry.precision)
        }
        ConstantTag.String => {
            list.push(CONST_TAG_STRING)
            mbWriteString(list, entry.str_val)
        }
        ConstantTag.FixedString => {
            list.push(CONST_TAG_FIXED_STRING)
            mbWriteU16(list, len(entry.str_val))
            mbWriteString(list, entry.str_val)
        }
        ConstantTag.Identifier => {
            list.push(CONST_TAG_IDENTIFIER)
            mbWriteString(list, entry.str_val)
        }
        ConstantTag.RecordRef => {
            list.push(CONST_TAG_RECORD_REF)
            mbWriteU16(list, entry.int_val)
        }
        ConstantTag.RoutineRef => {
            list.push(CONST_TAG_ROUTINE_REF)
            mbWriteU16(list, entry.int_val)
        }
        ConstantTag.Float => {
            list.push(CONST_TAG_FLOAT)
            // Float as bits - simplified, just write the f64 as i64 bits
            mbWriteI64(list, entry.int_val)
        }
        ConstantTag.Boolean => {
            list.push(CONST_TAG_BOOLEAN)
            if (entry.bool_val) {
                list.push(1)
            } else {
                list.push(0)
            }
        }
    }
}

fn mbWriteRoutine(list: List<i64>, routine: RoutineDef) {
    mbWriteU32(list, routine.name_index)
    if (routine.is_public) {
        list.push(1)
    } else {
        list.push(0)
    }
    if (routine.is_function) {
        list.push(1)
    } else {
        list.push(0)
    }
    mbWriteU32(list, routine.code_offset)
    mbWriteU32(list, routine.code_length)
    mbWriteU32(list, routine.param_count)
    mbWriteU32(list, routine.local_count)
    mbWriteU32(list, routine.max_stack)
}

fn mbWriteExport(list: List<i64>, export_entry: ExportEntry) {
    mbWriteU32(list, export_entry.name_index)
    switch (export_entry.kind) {
        ExportKind.Routine => { list.push(0) }
        ExportKind.Record => { list.push(1) }
        ExportKind.Global => { list.push(2) }
    }
    mbWriteU32(list, export_entry.index)
}

// =============================================================================
// IR-to-Bytecode Translation
// =============================================================================
// These functions translate IR instructions to bytecode.
// They use value_slots to map IR value IDs to registers/locals.

// IROp enum values (must match ir.cot)
const IR_ALLOCA: i64 = 0
const IR_LOAD: i64 = 1
const IR_STORE: i64 = 2
const IR_FIELD_PTR: i64 = 3
const IR_INDEX_PTR: i64 = 4
const IR_IADD: i64 = 5
const IR_ISUB: i64 = 6
const IR_IMUL: i64 = 7
const IR_SDIV: i64 = 8
const IR_UDIV: i64 = 9
const IR_SREM: i64 = 10
const IR_UREM: i64 = 11
const IR_INEG: i64 = 12
const IR_FADD: i64 = 13
const IR_FSUB: i64 = 14
const IR_FMUL: i64 = 15
const IR_FDIV: i64 = 16
const IR_FNEG: i64 = 17
const IR_BAND: i64 = 18
const IR_BOR: i64 = 19
const IR_BXOR: i64 = 20
const IR_BNOT: i64 = 21
const IR_ISHL: i64 = 22
const IR_SSHR: i64 = 23
const IR_USHR: i64 = 24
const IR_ICMP: i64 = 25
const IR_FCMP: i64 = 26
const IR_LOG_AND: i64 = 27
const IR_LOG_OR: i64 = 28
const IR_LOG_NOT: i64 = 29
const IR_JUMP: i64 = 30
const IR_BRIF: i64 = 31
const IR_BRTABLE: i64 = 32
const IR_RET: i64 = 33
const IR_CALL: i64 = 34
const IR_ICONST: i64 = 35
const IR_FCONST: i64 = 36
const IR_STRCONST: i64 = 37
const IR_BOOLCONST: i64 = 38
const IR_NULLCONST: i64 = 39
const IR_BITCAST: i64 = 40
const IR_SEXTEND: i64 = 41
const IR_UEXTEND: i64 = 42
const IR_IREDUCE: i64 = 43
const IR_INT_TO_FLOAT: i64 = 44
const IR_FLOAT_TO_INT: i64 = 45
const IR_STR_CONCAT: i64 = 46
const IR_STR_COMPARE: i64 = 47
const IR_STR_LEN: i64 = 48
const IR_WRAP_OPTIONAL: i64 = 49
const IR_UNWRAP_OPTIONAL: i64 = 50
const IR_IS_NULL: i64 = 51
const IR_ARRAY_LOAD: i64 = 52
const IR_ARRAY_STORE: i64 = 53
const IR_ARRAY_LEN: i64 = 54
const IR_LIST_NEW: i64 = 55
const IR_LIST_PUSH: i64 = 56
const IR_LIST_POP: i64 = 57
const IR_LIST_GET: i64 = 58
const IR_LIST_SET: i64 = 59
const IR_LIST_LEN: i64 = 60
const IR_MAP_NEW: i64 = 61
const IR_MAP_SET: i64 = 62
const IR_MAP_GET: i64 = 63
const IR_MAP_HAS: i64 = 64
const IR_MAP_DELETE: i64 = 65
const IR_MAP_LEN: i64 = 66
const IR_SELECT: i64 = 67
const IR_DEBUG_LINE: i64 = 68
const IR_SET_HANDLER: i64 = 69
const IR_CLEAR_HANDLER: i64 = 70
const IR_ERR_THROW: i64 = 71

// P0: Slicing and sum type operations (must match ir.cot)
const IR_SLICE_NEW: i64 = 72
const IR_VARIANT_CONSTRUCT: i64 = 73
const IR_VARIANT_GET_TAG: i64 = 74
const IR_VARIANT_GET_PAYLOAD: i64 = 75
const IR_MAKE_CLOSURE: i64 = 76
const IR_PHI: i64 = 77

// Comparison condition codes (must match ir.cot)
const COND_EQ: i64 = 0
const COND_NE: i64 = 1
const COND_SLT: i64 = 2
const COND_SLE: i64 = 3
const COND_SGT: i64 = 4
const COND_SGE: i64 = 5
const COND_ULT: i64 = 6
const COND_ULE: i64 = 7
const COND_UGT: i64 = 8
const COND_UGE: i64 = 9

// Translation context for a single function
struct TranslateContext {
    emitter: BytecodeEmitter,
    value_regs: Map<i64, i64>,
    block_labels: Map<i64, i64>,
    local_slots: Map<string, i64>,
    next_local: i64,
}

fn newTranslateContext(e: BytecodeEmitter) TranslateContext {
    return TranslateContext{
        .emitter = e,
        .value_regs = new Map<i64, i64>,
        .block_labels = new Map<i64, i64>,
        .local_slots = new Map<string, i64>,
        .next_local = 0,
    }
}

fn tcAllocReg(ctx: TranslateContext, value_id: i64) i64 {
    const reg = regAllocAllocate(ctx.emitter.reg_alloc, value_id)
    if (reg >= 0) {
        ctx.value_regs.set(value_id, reg)
    }
    return reg
}

fn tcGetReg(ctx: TranslateContext, value_id: i64) i64 {
    if (ctx.value_regs.has(value_id)) {
        return ctx.value_regs.get(value_id)
    }
    return -1
}

fn tcFreeReg(ctx: TranslateContext, value_id: i64) {
    if (ctx.value_regs.has(value_id)) {
        const reg = ctx.value_regs.get(value_id)
        regAllocFree(ctx.emitter.reg_alloc, reg)
        ctx.value_regs.delete(value_id)
    }
}

fn tcAllocLocal(ctx: TranslateContext, name: string) i64 {
    const slot = ctx.next_local
    ctx.next_local = ctx.next_local + 1
    ctx.local_slots.set(name, slot)
    return slot
}

fn tcGetLocal(ctx: TranslateContext, name: string) i64 {
    if (ctx.local_slots.has(name)) {
        return ctx.local_slots.get(name)
    }
    return -1
}

// Translate a single IR instruction to bytecode
fn translateInst(ctx: TranslateContext, op: i64, result_id: i64, op1_id: i64, op2_id: i64, op3_id: i64, int_val: i64, str_val: string, bool_val: bool, cond: i64, target_block: i64, else_block: i64, callee: string, field_idx: i64, line: i64) {
    const e = ctx.emitter

    switch (op) {
        IR_ICONST => {
            const rd = tcAllocReg(ctx, result_id)
            if (int_val >= -128 and int_val <= 127) {
                emitMovI(e, rd, int_val)
            } else {
                const idx = emitAddInt(e, int_val)
                emitLoadConst(e, rd, idx)
            }
        }

        IR_FCONST => {
            const rd = tcAllocReg(ctx, result_id)
            const idx = emitAddFloat(e, 0.0)  // Note: float_val would need to be passed separately
            emitLoadConst(e, rd, idx)
        }

        IR_STRCONST => {
            const rd = tcAllocReg(ctx, result_id)
            const idx = emitAddString(e, str_val)
            emitLoadConst(e, rd, idx)
        }

        IR_BOOLCONST => {
            const rd = tcAllocReg(ctx, result_id)
            if (bool_val) {
                emitLoadTrue(e, rd)
            } else {
                emitLoadFalse(e, rd)
            }
        }

        IR_NULLCONST => {
            const rd = tcAllocReg(ctx, result_id)
            emitLoadNull(e, rd)
        }

        IR_IADD => {
            const rd = tcAllocReg(ctx, result_id)
            const rs1 = tcGetReg(ctx, op1_id)
            const rs2 = tcGetReg(ctx, op2_id)
            emitAdd(e, rd, rs1, rs2)
        }

        IR_ISUB => {
            const rd = tcAllocReg(ctx, result_id)
            const rs1 = tcGetReg(ctx, op1_id)
            const rs2 = tcGetReg(ctx, op2_id)
            emitSub(e, rd, rs1, rs2)
        }

        IR_IMUL => {
            const rd = tcAllocReg(ctx, result_id)
            const rs1 = tcGetReg(ctx, op1_id)
            const rs2 = tcGetReg(ctx, op2_id)
            emitMul(e, rd, rs1, rs2)
        }

        IR_SDIV => {
            const rd = tcAllocReg(ctx, result_id)
            const rs1 = tcGetReg(ctx, op1_id)
            const rs2 = tcGetReg(ctx, op2_id)
            emitDiv(e, rd, rs1, rs2)
        }

        IR_SREM => {
            const rd = tcAllocReg(ctx, result_id)
            const rs1 = tcGetReg(ctx, op1_id)
            const rs2 = tcGetReg(ctx, op2_id)
            emitMod(e, rd, rs1, rs2)
        }

        IR_UDIV => {
            // Unsigned division - same opcode as signed for now
            const rd = tcAllocReg(ctx, result_id)
            const rs1 = tcGetReg(ctx, op1_id)
            const rs2 = tcGetReg(ctx, op2_id)
            emitDiv(e, rd, rs1, rs2)
        }

        IR_UREM => {
            // Unsigned modulo - same opcode as signed for now
            const rd = tcAllocReg(ctx, result_id)
            const rs1 = tcGetReg(ctx, op1_id)
            const rs2 = tcGetReg(ctx, op2_id)
            emitMod(e, rd, rs1, rs2)
        }

        IR_INEG => {
            const rd = tcAllocReg(ctx, result_id)
            const rs = tcGetReg(ctx, op1_id)
            emitNeg(e, rd, rs)
        }

        IR_BAND => {
            const rd = tcAllocReg(ctx, result_id)
            const rs1 = tcGetReg(ctx, op1_id)
            const rs2 = tcGetReg(ctx, op2_id)
            emitBitAnd(e, rd, rs1, rs2)
        }

        IR_BOR => {
            const rd = tcAllocReg(ctx, result_id)
            const rs1 = tcGetReg(ctx, op1_id)
            const rs2 = tcGetReg(ctx, op2_id)
            emitBitOr(e, rd, rs1, rs2)
        }

        IR_BXOR => {
            const rd = tcAllocReg(ctx, result_id)
            const rs1 = tcGetReg(ctx, op1_id)
            const rs2 = tcGetReg(ctx, op2_id)
            emitBitXor(e, rd, rs1, rs2)
        }

        IR_BNOT => {
            const rd = tcAllocReg(ctx, result_id)
            const rs = tcGetReg(ctx, op1_id)
            emitBitNot(e, rd, rs)
        }

        IR_ISHL => {
            const rd = tcAllocReg(ctx, result_id)
            const rs1 = tcGetReg(ctx, op1_id)
            const rs2 = tcGetReg(ctx, op2_id)
            emitShl(e, rd, rs1, rs2)
        }

        IR_SSHR => {
            const rd = tcAllocReg(ctx, result_id)
            const rs1 = tcGetReg(ctx, op1_id)
            const rs2 = tcGetReg(ctx, op2_id)
            emitShr(e, rd, rs1, rs2)
        }

        IR_USHR => {
            // Unsigned shift right - same opcode for now
            const rd = tcAllocReg(ctx, result_id)
            const rs1 = tcGetReg(ctx, op1_id)
            const rs2 = tcGetReg(ctx, op2_id)
            emitShr(e, rd, rs1, rs2)
        }

        IR_ICMP => {
            const rd = tcAllocReg(ctx, result_id)
            const rs1 = tcGetReg(ctx, op1_id)
            const rs2 = tcGetReg(ctx, op2_id)
            switch (cond) {
                COND_EQ => { emitCmpEq(e, rd, rs1, rs2) }
                COND_NE => { emitCmpNe(e, rd, rs1, rs2) }
                COND_SLT => { emitCmpLt(e, rd, rs1, rs2) }
                COND_SLE => { emitCmpLe(e, rd, rs1, rs2) }
                COND_SGT => { emitCmpGt(e, rd, rs1, rs2) }
                COND_SGE => { emitCmpGe(e, rd, rs1, rs2) }
                else => { emitCmpEq(e, rd, rs1, rs2) }
            }
        }

        IR_LOG_AND => {
            const rd = tcAllocReg(ctx, result_id)
            const rs1 = tcGetReg(ctx, op1_id)
            const rs2 = tcGetReg(ctx, op2_id)
            emitLogAnd(e, rd, rs1, rs2)
        }

        IR_LOG_OR => {
            const rd = tcAllocReg(ctx, result_id)
            const rs1 = tcGetReg(ctx, op1_id)
            const rs2 = tcGetReg(ctx, op2_id)
            emitLogOr(e, rd, rs1, rs2)
        }

        IR_LOG_NOT => {
            const rd = tcAllocReg(ctx, result_id)
            const rs = tcGetReg(ctx, op1_id)
            emitLogNot(e, rd, rs)
        }

        IR_LOAD => {
            const rd = tcAllocReg(ctx, result_id)
            const slot = tcGetLocal(ctx, str_val)
            if (slot >= 0) {
                emitLoadLocal(e, rd, slot)
            }
        }

        IR_STORE => {
            const rs = tcGetReg(ctx, op1_id)
            const slot = tcGetLocal(ctx, str_val)
            if (slot >= 0) {
                emitStoreLocal(e, rs, slot)
            }
        }

        IR_ALLOCA => {
            tcAllocLocal(ctx, str_val)
        }

        IR_FIELD_PTR => {
            // Get pointer to struct field
            const rd = tcAllocReg(ctx, result_id)
            const base_reg = tcGetReg(ctx, op1_id)
            const offset = field_idx
            emitPtrOffset(e, rd, base_reg, offset)
        }

        IR_INDEX_PTR => {
            // Get pointer to array/slice element
            const rd = tcAllocReg(ctx, result_id)
            const base_reg = tcGetReg(ctx, op1_id)
            const idx_reg = tcGetReg(ctx, op2_id)
            // For index_ptr, we use load_indirect with dynamic offset
            emitPtrOffset(e, rd, base_reg, 0)  // Base calculation
        }

        IR_FADD => {
            // Float add - uses same opcode as int add
            const rd = tcAllocReg(ctx, result_id)
            const rs1 = tcGetReg(ctx, op1_id)
            const rs2 = tcGetReg(ctx, op2_id)
            emitAdd(e, rd, rs1, rs2)
        }

        IR_FSUB => {
            const rd = tcAllocReg(ctx, result_id)
            const rs1 = tcGetReg(ctx, op1_id)
            const rs2 = tcGetReg(ctx, op2_id)
            emitSub(e, rd, rs1, rs2)
        }

        IR_FMUL => {
            const rd = tcAllocReg(ctx, result_id)
            const rs1 = tcGetReg(ctx, op1_id)
            const rs2 = tcGetReg(ctx, op2_id)
            emitMul(e, rd, rs1, rs2)
        }

        IR_FDIV => {
            const rd = tcAllocReg(ctx, result_id)
            const rs1 = tcGetReg(ctx, op1_id)
            const rs2 = tcGetReg(ctx, op2_id)
            emitDiv(e, rd, rs1, rs2)
        }

        IR_FNEG => {
            const rd = tcAllocReg(ctx, result_id)
            const rs = tcGetReg(ctx, op1_id)
            emitNeg(e, rd, rs)
        }

        IR_FCMP => {
            // Float compare - uses same opcodes as int compare
            const rd = tcAllocReg(ctx, result_id)
            const rs1 = tcGetReg(ctx, op1_id)
            const rs2 = tcGetReg(ctx, op2_id)
            switch (cond) {
                COND_EQ => { emitCmpEq(e, rd, rs1, rs2) }
                COND_NE => { emitCmpNe(e, rd, rs1, rs2) }
                COND_SLT => { emitCmpLt(e, rd, rs1, rs2) }
                COND_SLE => { emitCmpLe(e, rd, rs1, rs2) }
                COND_SGT => { emitCmpGt(e, rd, rs1, rs2) }
                COND_SGE => { emitCmpGe(e, rd, rs1, rs2) }
                else => { emitCmpEq(e, rd, rs1, rs2) }
            }
        }

        IR_BITCAST => {
            // Bitcast - reinterpret bits, just move for now
            const rd = tcAllocReg(ctx, result_id)
            const rs = tcGetReg(ctx, op1_id)
            emitMov(e, rd, rs)
        }

        IR_SEXTEND => {
            // Sign extend - move for now (VM handles types dynamically)
            const rd = tcAllocReg(ctx, result_id)
            const rs = tcGetReg(ctx, op1_id)
            emitMov(e, rd, rs)
        }

        IR_UEXTEND => {
            // Zero extend - move for now
            const rd = tcAllocReg(ctx, result_id)
            const rs = tcGetReg(ctx, op1_id)
            emitMov(e, rd, rs)
        }

        IR_IREDUCE => {
            // Integer reduce (truncate) - move for now
            const rd = tcAllocReg(ctx, result_id)
            const rs = tcGetReg(ctx, op1_id)
            emitMov(e, rd, rs)
        }

        IR_INT_TO_FLOAT => {
            // Convert int to float
            const rd = tcAllocReg(ctx, result_id)
            const rs = tcGetReg(ctx, op1_id)
            emitToDec(e, rd, rs, 0)  // Default precision
        }

        IR_FLOAT_TO_INT => {
            // Convert float to int
            const rd = tcAllocReg(ctx, result_id)
            const rs = tcGetReg(ctx, op1_id)
            emitToInt(e, rd, rs)
        }

        IR_WRAP_OPTIONAL => {
            // Wrap value in optional (value becomes Some(value))
            const rd = tcAllocReg(ctx, result_id)
            const rs = tcGetReg(ctx, op1_id)
            emitMov(e, rd, rs)  // For now, optionals are transparent
        }

        IR_UNWRAP_OPTIONAL => {
            // Unwrap optional value
            const rd = tcAllocReg(ctx, result_id)
            const rs = tcGetReg(ctx, op1_id)
            emitMov(e, rd, rs)  // For now, just move the value
        }

        IR_ARRAY_LOAD => {
            // Load from array at index
            const rd = tcAllocReg(ctx, result_id)
            const arr_reg = tcGetReg(ctx, op1_id)
            const idx_reg = tcGetReg(ctx, op2_id)
            emitArrayLoad(e, idx_reg, arr_reg)
            emitMov(e, rd, 15)  // Result in r15
        }

        IR_ARRAY_STORE => {
            // Store to array at index
            const arr_reg = tcGetReg(ctx, op1_id)
            const idx_reg = tcGetReg(ctx, op2_id)
            const val_reg = tcGetReg(ctx, op3_id)
            emitArrayStore(e, idx_reg, val_reg, arr_reg)
        }

        IR_ARRAY_LEN => {
            // Get array length
            const rd = tcAllocReg(ctx, result_id)
            const arr_reg = tcGetReg(ctx, op1_id)
            emitArrayLen(e, rd, arr_reg)
        }

        IR_SLICE_NEW => {
            // Create slice from array[start..end]
            const rd = tcAllocReg(ctx, result_id)
            const start_reg = tcGetReg(ctx, op1_id)
            const end_reg = tcGetReg(ctx, op2_id)
            const arr_slot = int_val  // Array source slot
            emitArraySlice(e, rd, start_reg, end_reg, arr_slot, false)
        }

        IR_STR_COMPARE => {
            // String comparison
            const rd = tcAllocReg(ctx, result_id)
            const rs1 = tcGetReg(ctx, op1_id)
            const rs2 = tcGetReg(ctx, op2_id)
            switch (cond) {
                COND_EQ => { emitCmpStrEq(e, rd, rs1, rs2) }
                COND_NE => { emitCmpStrNe(e, rd, rs1, rs2) }
                COND_SLT => { emitCmpStrLt(e, rd, rs1, rs2) }
                COND_SLE => { emitCmpStrLe(e, rd, rs1, rs2) }
                COND_SGT => { emitCmpStrGt(e, rd, rs1, rs2) }
                COND_SGE => { emitCmpStrGe(e, rd, rs1, rs2) }
                else => { emitCmpStrEq(e, rd, rs1, rs2) }
            }
        }

        IR_STR_CONCAT => {
            const rd = tcAllocReg(ctx, result_id)
            const rs1 = tcGetReg(ctx, op1_id)
            const rs2 = tcGetReg(ctx, op2_id)
            emitStrConcat(e, rd, rs1, rs2)
        }

        IR_STR_LEN => {
            const rd = tcAllocReg(ctx, result_id)
            const rs = tcGetReg(ctx, op1_id)
            emitStrLen(e, rd, rs)
        }

        IR_LIST_NEW => {
            const rd = tcAllocReg(ctx, result_id)
            emitListNew(e, rd)
        }

        IR_LIST_PUSH => {
            const list_reg = tcGetReg(ctx, op1_id)
            const val_reg = tcGetReg(ctx, op2_id)
            emitListPush(e, list_reg, val_reg)
        }

        IR_LIST_POP => {
            const rd = tcAllocReg(ctx, result_id)
            const list_reg = tcGetReg(ctx, op1_id)
            emitListPop(e, rd, list_reg)
        }

        IR_LIST_GET => {
            const rd = tcAllocReg(ctx, result_id)
            const list_reg = tcGetReg(ctx, op1_id)
            const idx_reg = tcGetReg(ctx, op2_id)
            emitListGet(e, rd, list_reg, idx_reg)
        }

        IR_LIST_SET => {
            const list_reg = tcGetReg(ctx, op1_id)
            const idx_reg = tcGetReg(ctx, op2_id)
            const val_reg = tcGetReg(ctx, op3_id)
            emitListSet(e, list_reg, idx_reg, val_reg)
        }

        IR_LIST_LEN => {
            const rd = tcAllocReg(ctx, result_id)
            const list_reg = tcGetReg(ctx, op1_id)
            emitListLen(e, rd, list_reg)
        }

        IR_MAP_NEW => {
            const rd = tcAllocReg(ctx, result_id)
            emitMapNew(e, rd, 0)
        }

        IR_MAP_SET => {
            const map_reg = tcGetReg(ctx, op1_id)
            const key_reg = tcGetReg(ctx, op2_id)
            const val_reg = tcGetReg(ctx, op3_id)
            emitMapSet(e, map_reg, key_reg, val_reg)
        }

        IR_MAP_GET => {
            const rd = tcAllocReg(ctx, result_id)
            const map_reg = tcGetReg(ctx, op1_id)
            const key_reg = tcGetReg(ctx, op2_id)
            emitMapGet(e, rd, map_reg, key_reg)
        }

        IR_MAP_HAS => {
            const rd = tcAllocReg(ctx, result_id)
            const map_reg = tcGetReg(ctx, op1_id)
            const key_reg = tcGetReg(ctx, op2_id)
            emitMapHas(e, rd, map_reg, key_reg)
        }

        IR_MAP_DELETE => {
            const map_reg = tcGetReg(ctx, op1_id)
            const key_reg = tcGetReg(ctx, op2_id)
            emitMapDelete(e, map_reg, key_reg)
        }

        IR_MAP_LEN => {
            const rd = tcAllocReg(ctx, result_id)
            const map_reg = tcGetReg(ctx, op1_id)
            emitMapLen(e, rd, map_reg)
        }

        IR_JUMP => {
            emitJmp(e, 0)
            emitAddPendingJump(e, target_block, false)
        }

        IR_BRIF => {
            const cond_reg = tcGetReg(ctx, op1_id)
            emitJnz(e, cond_reg, 0)
            emitAddPendingJump(e, target_block, false)
            emitJmp(e, 0)
            emitAddPendingJump(e, else_block, false)
        }

        IR_BRTABLE => {
            // Branch table for switch statements
            // For now, emit as unconditional jump to default
            // Full implementation would use indexed branch table
            emitJmp(e, 0)
            emitAddPendingJump(e, target_block, false)
        }

        IR_RET => {
            if (op1_id >= 0) {
                const rs = tcGetReg(ctx, op1_id)
                emitRetVal(e, rs)
            } else {
                emitRet(e)
            }
        }

        IR_CALL => {
            // Get function index from function_indices map
            if (e.function_indices.has(callee)) {
                const fn_idx = e.function_indices.get(callee)
                const argc = int_val
                emitCall(e, fn_idx, argc)
                if (result_id >= 0) {
                    const rd = tcAllocReg(ctx, result_id)
                    emitMov(e, rd, 15)  // Move return value from r15
                }
            }
        }

        IR_DEBUG_LINE => {
            emitDebugLine(e, line)
        }

        IR_SET_HANDLER => {
            // Set error handler - target_block contains the catch block
            emitSetErrorHandler(e, target_block)
        }

        IR_CLEAR_HANDLER => {
            // Clear error handler
            emitClearErrorHandler(e)
        }

        IR_ERR_THROW => {
            // Throw error value
            const rs = tcGetReg(ctx, op1_id)
            emitThrow(e, rs)
        }

        IR_IS_NULL => {
            // Check if optional value is null
            const rd = tcAllocReg(ctx, result_id)
            const rs = tcGetReg(ctx, op1_id)
            emitIsNull(e, rd, rs)
        }

        IR_SELECT => {
            // Conditional select: rd = cond ? op1 : op2
            const rd = tcAllocReg(ctx, result_id)
            const cond_reg = tcGetReg(ctx, op1_id)
            const true_reg = tcGetReg(ctx, op2_id)
            const false_reg = tcGetReg(ctx, op3_id)
            emitSelect(e, rd, cond_reg, true_reg, false_reg)
        }

        IR_VARIANT_CONSTRUCT => {
            // Construct a variant (sum type) with tag and payload
            const rd = tcAllocReg(ctx, result_id)
            const tag = int_val
            const argc = field_idx  // Number of payload values
            emitVariantConstruct(e, rd, tag, argc)
        }

        IR_VARIANT_GET_TAG => {
            // Extract tag from variant
            const rd = tcAllocReg(ctx, result_id)
            const src = tcGetReg(ctx, op1_id)
            emitVariantGetTag(e, rd, src)
        }

        IR_VARIANT_GET_PAYLOAD => {
            // Extract payload field from variant
            const rd = tcAllocReg(ctx, result_id)
            const src = tcGetReg(ctx, op1_id)
            const payload_idx = field_idx
            emitVariantGetPayload(e, rd, src, payload_idx)
        }

        IR_MAKE_CLOSURE => {
            // Create closure from function and environment
            const rd = tcAllocReg(ctx, result_id)
            const env_reg = tcGetReg(ctx, op1_id)
            var fn_idx: i64 = 0
            if (e.function_indices.has(callee)) {
                fn_idx = e.function_indices.get(callee)
            }
            emitMakeClosure(e, rd, env_reg, fn_idx)
        }

        IR_PHI => {
            // Phi elimination pattern: load from dedicated alloca instead
            // This case handles any direct phi instructions that weren't eliminated
            // The op1_id contains the entry block value (for first iteration)
            // Just alias to the incoming value from entry block
            const rd = tcAllocReg(ctx, result_id)
            const src = tcGetReg(ctx, op1_id)
            if (src >= 0) {
                emitMov(e, rd, src)
            }
        }

        else => {
            // Unknown instruction, emit NOP
            emitNop(e)
        }
    }
}

// Translate a basic block
fn translateBlock(ctx: TranslateContext, block_id: i64, insts: List<i64>) {
    emitRecordBlockOffset(ctx.emitter, block_id)
    var i: i64 = 0
    while (i < insts.len()) {
        // Each instruction is encoded as a series of values
        // This is a simplified representation
        i = i + 1
    }
}

// Register a function for calling
fn emitRegisterFunction(e: BytecodeEmitter, name: string, idx: i64) {
    e.function_indices.set(name, idx)
}

// Create a routine entry in the bytecode
fn emitBeginRoutine(e: BytecodeEmitter, name: string, is_public: bool, is_function: bool, param_count: i64) i64 {
    const name_idx = emitAddIdentifier(e, name)
    var routine = newRoutineDef(name_idx)
    routine.is_public = is_public
    routine.is_function = is_function
    routine.param_count = param_count
    routine.code_offset = e.code.len()
    const idx = e.routines.len()
    e.routines.push(routine)
    e.function_indices.set(name, idx)
    regAllocReset(e.reg_alloc)
    e.local_count = 0
    e.current_routine_start = e.code.len()
    return idx
}

fn emitEndRoutine(e: BytecodeEmitter, routine_idx: i64, local_count: i64, max_stack: i64) {
    var routine = e.routines.get(routine_idx)
    routine.code_length = e.code.len() - routine.code_offset
    routine.local_count = local_count
    routine.max_stack = max_stack
    e.routines.set(routine_idx, routine)
    emitPatchJumps(e)
}

// Add an export for a routine
fn emitAddExport(e: BytecodeEmitter, name: string, kind: ExportKind, idx: i64) {
    const name_idx = emitAddIdentifier(e, name)
    const entry = ExportEntry{
        .name_index = name_idx,
        .kind = kind,
        .index = idx,
    }
    e.exports.push(entry)
}

// =============================================================================
// Module Building
// =============================================================================

fn emitBuildModule(e: BytecodeEmitter, entry_point: i64, source_hash: i64) List<i64> {
    const mb = newModuleBuilder()

    // Count sections that have content
    var section_count: i64 = 0
    if (e.constants.len() > 0) { section_count = section_count + 1 }
    if (e.routines.len() > 0) { section_count = section_count + 1 }
    if (e.code.len() > 0) { section_count = section_count + 1 }
    if (e.exports.len() > 0) { section_count = section_count + 1 }
    mb.section_count = section_count

    // Write constants section
    var i: i64 = 0
    while (i < e.constants.len()) {
        const c = e.constants.get(i)
        mbWriteConstant(mb.constants_section, c)
        i = i + 1
    }

    // Write routines section
    i = 0
    while (i < e.routines.len()) {
        const r = e.routines.get(i)
        mbWriteRoutine(mb.routines_section, r)
        i = i + 1
    }

    // Write exports section
    i = 0
    while (i < e.exports.len()) {
        const exp = e.exports.get(i)
        mbWriteExport(mb.exports_section, exp)
        i = i + 1
    }

    // Copy code section
    i = 0
    while (i < e.code.len()) {
        mb.code_section.push(e.code.get(i))
        i = i + 1
    }

    // Calculate offsets
    // Header is 32 bytes
    // Section table is 16 bytes per section
    const header_size: i64 = 32
    const section_table_size: i64 = section_count * 16
    var offset: i64 = header_size + section_table_size

    // Write section table entries
    if (e.constants.len() > 0) {
        mbWriteSectionEntry(mb, SECTION_CONSTANTS, offset, mb.constants_section.len(), e.constants.len())
        offset = offset + mb.constants_section.len()
    }
    if (e.routines.len() > 0) {
        mbWriteSectionEntry(mb, SECTION_ROUTINES, offset, mb.routines_section.len(), e.routines.len())
        offset = offset + mb.routines_section.len()
    }
    if (e.code.len() > 0) {
        mbWriteSectionEntry(mb, SECTION_CODE, offset, mb.code_section.len(), 0)
        offset = offset + mb.code_section.len()
    }
    if (e.exports.len() > 0) {
        mbWriteSectionEntry(mb, SECTION_EXPORTS, offset, mb.exports_section.len(), e.exports.len())
        offset = offset + mb.exports_section.len()
    }

    // Write header
    mbWriteHeader(mb, entry_point, source_hash)

    // Assemble final module
    const result= new List<i64>

    // Copy header
    i = 0
    while (i < mb.header.len()) {
        result.push(mb.header.get(i))
        i = i + 1
    }

    // Copy section table
    i = 0
    while (i < mb.section_table.len()) {
        result.push(mb.section_table.get(i))
        i = i + 1
    }

    // Copy sections in order
    i = 0
    while (i < mb.constants_section.len()) {
        result.push(mb.constants_section.get(i))
        i = i + 1
    }
    i = 0
    while (i < mb.routines_section.len()) {
        result.push(mb.routines_section.get(i))
        i = i + 1
    }
    i = 0
    while (i < mb.code_section.len()) {
        result.push(mb.code_section.get(i))
        i = i + 1
    }
    i = 0
    while (i < mb.exports_section.len()) {
        result.push(mb.exports_section.get(i))
        i = i + 1
    }

    return result
}
