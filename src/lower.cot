// AST to IR Lowering for the Cot self-hosted compiler
//
// This module transforms the typed AST into IR form suitable for
// bytecode emission.

import "ast"
import "ir"
import "types"
import "token"

// =============================================================================
// Lowerer Context
// =============================================================================

struct Lowerer {
    // Output IR module
    module: IRModule,

    // Type registry (for IR types)
    ir_types: IRTypeRegistry,

    // AST type registry (for looking up AST types)
    ast_types: TypeRegistry,

    // Current function index (-1 if none)
    current_func_idx: i64,

    // Current block being built
    current_block: i64,

    // Scope stack for variable management
    scopes: List<LowerScope>,

    // Map from AST type ID to IR type ID
    type_map: Map<i64, i64>,

    // Error tracking
    errors: List<string>,
    had_error: bool,
}

// Scope for tracking local variables during lowering
struct LowerScope {
    vars: Map<string, i64>,     // Variable name -> value ID
    is_loop: bool,              // For break/continue
    loop_exit: i64,             // Exit block for loops
    loop_continue: i64,         // Continue block for loops
}

fn newLowerer(ast_types: TypeRegistry) Lowerer {
    const module = newIRModule("main")
    const ir_types = newIRTypeRegistry()
    const scopes: List<LowerScope> = List.new()
    const type_map: Map<i64, i64> = Map.new()
    const errors: List<string> = List.new()

    return Lowerer{
        .module = module,
        .ir_types = ir_types,
        .ast_types = ast_types,
        .current_func_idx = -1,
        .current_block = -1,
        .scopes = scopes,
        .type_map = type_map,
        .errors = errors,
        .had_error = false,
    }
}

// Helper to get current function
fn lowerGetCurrentFunc(l: Lowerer) IRFunction {
    return l.module.functions.get(l.current_func_idx)
}

// =============================================================================
// Scope Management
// =============================================================================

fn lowerEnterScope(l: Lowerer) {
    const vars: Map<string, i64> = Map.new()
    const scope = LowerScope{
        .vars = vars,
        .is_loop = false,
        .loop_exit = -1,
        .loop_continue = -1,
    }
    l.scopes.push(scope)
}

fn lowerEnterLoopScope(l: Lowerer, exit_block: i64, continue_block: i64) {
    const vars: Map<string, i64> = Map.new()
    const scope = LowerScope{
        .vars = vars,
        .is_loop = true,
        .loop_exit = exit_block,
        .loop_continue = continue_block,
    }
    l.scopes.push(scope)
}

fn lowerExitScope(l: Lowerer) {
    if (l.scopes.len() > 0) {
        l.scopes.pop()
    }
}

fn lowerDefineVar(l: Lowerer, name: string, value_id: i64) {
    if (l.scopes.len() > 0) {
        const scope = l.scopes.get(l.scopes.len() - 1)
        scope.vars.set(name, value_id)
    }
}

fn lowerLookupVar(l: Lowerer, name: string) i64 {
    var i = l.scopes.len() - 1
    while (i >= 0) {
        const scope = l.scopes.get(i)
        if (scope.vars.has(name)) {
            return scope.vars.get(name)
        }
        i = i - 1
    }
    return -1
}

fn lowerGetLoopExit(l: Lowerer) i64 {
    var i = l.scopes.len() - 1
    while (i >= 0) {
        const scope = l.scopes.get(i)
        if (scope.is_loop) {
            return scope.loop_exit
        }
        i = i - 1
    }
    return -1
}

fn lowerGetLoopContinue(l: Lowerer) i64 {
    var i = l.scopes.len() - 1
    while (i >= 0) {
        const scope = l.scopes.get(i)
        if (scope.is_loop) {
            return scope.loop_continue
        }
        i = i - 1
    }
    return -1
}

// =============================================================================
// Error Handling
// =============================================================================

fn lowerError(l: Lowerer, line: i64, message: string) {
    const err = "Lower error at line ${line}: ${message}"
    l.errors.push(err)
    l.had_error = true
}

// =============================================================================
// Type Mapping (AST types to IR types)
// =============================================================================

fn lowerMapType(l: Lowerer, ast_type_id: i64) i64 {
    // Check cache
    if (l.type_map.has(ast_type_id)) {
        return l.type_map.get(ast_type_id)
    }

    const ast_type = regGetType(l.ast_types, ast_type_id)
    var ir_type_id: i64 = l.ir_types.error_id

    // Map based on AST type tag
    switch (ast_type.tag) {
        TypeTag.Void => { ir_type_id = l.ir_types.void_id }
        TypeTag.Bool => { ir_type_id = l.ir_types.bool_id }
        TypeTag.I8 => { ir_type_id = l.ir_types.i8_id }
        TypeTag.I16 => { ir_type_id = l.ir_types.i16_id }
        TypeTag.I32 => { ir_type_id = l.ir_types.i32_id }
        TypeTag.I64 => { ir_type_id = l.ir_types.i64_id }
        TypeTag.U8 => { ir_type_id = l.ir_types.u8_id }
        TypeTag.U16 => { ir_type_id = l.ir_types.u16_id }
        TypeTag.U32 => { ir_type_id = l.ir_types.u32_id }
        TypeTag.U64 => { ir_type_id = l.ir_types.u64_id }
        TypeTag.F32 => { ir_type_id = l.ir_types.f32_id }
        TypeTag.F64 => { ir_type_id = l.ir_types.f64_id }
        TypeTag.StringType => { ir_type_id = l.ir_types.string_id }
        TypeTag.Char => { ir_type_id = l.ir_types.char_id }
        TypeTag.Pointer => {
            const inner_id = lowerMapType(l, ast_type.element_type_id)
            ir_type_id = irRegAddPointer(l.ir_types, inner_id)
        }
        TypeTag.Optional => {
            const inner_id = lowerMapType(l, ast_type.element_type_id)
            ir_type_id = irRegAddOptional(l.ir_types, inner_id)
        }
        TypeTag.Slice => {
            const inner_id = lowerMapType(l, ast_type.element_type_id)
            ir_type_id = irRegAddSlice(l.ir_types, inner_id)
        }
        TypeTag.Array => {
            const inner_id = lowerMapType(l, ast_type.element_type_id)
            ir_type_id = irRegAddArray(l.ir_types, inner_id, ast_type.array_size)
        }
    }

    // Cache the mapping
    l.type_map.set(ast_type_id, ir_type_id)
    return ir_type_id
}

// =============================================================================
// IR Building Helpers
// =============================================================================

fn lowerNewValue(l: Lowerer) i64 {
    if (l.current_func_idx >= 0) {
        const func = lowerGetCurrentFunc(l)
        return fnNewValue(func)
    }
    return -1
}

fn lowerEmit(l: Lowerer, inst: IRInst) {
    if (l.current_func_idx >= 0 and l.current_block >= 0) {
        const func = lowerGetCurrentFunc(l)
        const block = fnGetBlock(func, l.current_block)
        blockAppend(block, inst)
    }
}

fn lowerCreateBlock(l: Lowerer, label: string) i64 {
    if (l.current_func_idx >= 0) {
        const func = lowerGetCurrentFunc(l)
        return fnCreateBlock(func, label)
    }
    return -1
}

fn lowerSwitchBlock(l: Lowerer, block_id: i64) {
    l.current_block = block_id
}

// =============================================================================
// Expression Lowering
// =============================================================================

fn lowerExpr(l: Lowerer, expr: Expr) i64 {
    switch (expr.kind) {
        ExprKind.IntLiteral => { return lowerIntLiteral(l, expr) }
        ExprKind.DecLiteral => { return lowerDecLiteral(l, expr) }
        ExprKind.StrLiteral => { return lowerStrLiteral(l, expr) }
        ExprKind.BoolLiteral => { return lowerBoolLiteral(l, expr) }
        ExprKind.NullLiteral => { return lowerNullLiteral(l, expr) }
        ExprKind.IdentifierExpr => { return lowerIdentifier(l, expr) }
        ExprKind.BinaryExpr => { return lowerBinaryExpr(l, expr) }
        ExprKind.UnaryExpr => { return lowerUnaryExpr(l, expr) }
        ExprKind.CallExpr => { return lowerCallExpr(l, expr) }
        ExprKind.FieldExpr => { return lowerFieldExpr(l, expr) }
        ExprKind.IndexExpr => { return lowerIndexExpr(l, expr) }
        ExprKind.StructInitExpr => { return lowerStructInitExpr(l, expr) }
        ExprKind.ArrayInitExpr => { return lowerArrayInitExpr(l, expr) }
        ExprKind.MethodCallExpr => { return lowerMethodCallExpr(l, expr) }
        ExprKind.CastExpr => { return lowerCastExpr(l, expr) }
        ExprKind.IfExpr => { return lowerIfExpr(l, expr) }
        ExprKind.BlockExpr => { return lowerBlockExpr(l, expr) }
        ExprKind.SwitchExpr => { return lowerSwitchExpr(l, expr) }
        ExprKind.LambdaExpr => { return lowerLambdaExpr(l, expr) }
        ExprKind.RangeExpr => { return lowerRangeExpr(l, expr) }
        ExprKind.SliceExpr => { return lowerSliceExpr(l, expr) }
        ExprKind.InterpStringExpr => { return lowerInterpStringExpr(l, expr) }
        else => {
            lowerError(l, expr.loc.line, "Unhandled expression kind in lowering")
            return -1
        }
    }
}

fn lowerIntLiteral(l: Lowerer, expr: Expr) i64 {
    const result_id = lowerNewValue(l)
    var inst = newIRInst(IROp.IConst)
    inst.result_id = result_id
    inst.result_type_id = l.ir_types.i64_id
    inst.int_val = expr.int_value
    inst.line = expr.loc.line
    lowerEmit(l, inst)
    return result_id
}

fn lowerDecLiteral(l: Lowerer, expr: Expr) i64 {
    const result_id = lowerNewValue(l)
    var inst = newIRInst(IROp.FConst)
    inst.result_id = result_id
    inst.result_type_id = l.ir_types.f64_id
    inst.str_val = expr.dec_value  // Store as string for precision
    inst.line = expr.loc.line
    lowerEmit(l, inst)
    return result_id
}

fn lowerStrLiteral(l: Lowerer, expr: Expr) i64 {
    const str_index = modAddString(l.module, expr.str_value)
    const result_id = lowerNewValue(l)
    var inst = newIRInst(IROp.StrConst)
    inst.result_id = result_id
    inst.result_type_id = l.ir_types.string_id
    inst.int_val = str_index
    inst.str_val = expr.str_value
    inst.line = expr.loc.line
    lowerEmit(l, inst)
    return result_id
}

fn lowerBoolLiteral(l: Lowerer, expr: Expr) i64 {
    const result_id = lowerNewValue(l)
    var inst = newIRInst(IROp.BoolConst)
    inst.result_id = result_id
    inst.result_type_id = l.ir_types.bool_id
    inst.bool_val = expr.bool_value
    inst.line = expr.loc.line
    lowerEmit(l, inst)
    return result_id
}

fn lowerNullLiteral(l: Lowerer, expr: Expr) i64 {
    const result_id = lowerNewValue(l)
    var inst = newIRInst(IROp.NullConst)
    inst.result_id = result_id
    inst.result_type_id = l.ir_types.void_id
    inst.line = expr.loc.line
    lowerEmit(l, inst)
    return result_id
}

fn lowerIdentifier(l: Lowerer, expr: Expr) i64 {
    const var_id = lowerLookupVar(l, expr.name)
    if (var_id < 0) {
        lowerError(l, expr.loc.line, "Unknown variable '${expr.name}'")
        return -1
    }

    // Load the variable
    const result_id = lowerNewValue(l)
    var inst = newIRInst(IROp.Load)
    inst.result_id = result_id
    inst.op1_id = var_id
    inst.line = expr.loc.line
    lowerEmit(l, inst)
    return result_id
}

fn lowerBinaryExpr(l: Lowerer, expr: Expr) i64 {
    // Handle assignment specially
    if (expr.op == TokenType.Equals) {
        return lowerAssignment(l, expr)
    }

    // Lower operands
    var left_id: i64 = -1
    var right_id: i64 = -1

    if (expr.left != null) {
        left_id = lowerExpr(l, expr.left.*)
    }
    if (expr.right != null) {
        right_id = lowerExpr(l, expr.right.*)
    }

    const result_id = lowerNewValue(l)
    var inst = newIRInst(IROp.IAdd)

    // Map operator to IR op
    switch (expr.op) {
        TokenType.Plus => { inst.op = IROp.IAdd }
        TokenType.Minus => { inst.op = IROp.ISub }
        TokenType.Star => { inst.op = IROp.IMul }
        TokenType.Slash => { inst.op = IROp.SDiv }
        TokenType.Percent => { inst.op = IROp.SRem }
        TokenType.EqualEqual => {
            inst.op = IROp.ICmp
            inst.cond = CondCode.Eq
        }
        TokenType.BangEqual => {
            inst.op = IROp.ICmp
            inst.cond = CondCode.Ne
        }
        TokenType.Less => {
            inst.op = IROp.ICmp
            inst.cond = CondCode.Slt
        }
        TokenType.LessEqual => {
            inst.op = IROp.ICmp
            inst.cond = CondCode.Sle
        }
        TokenType.Greater => {
            inst.op = IROp.ICmp
            inst.cond = CondCode.Sgt
        }
        TokenType.GreaterEqual => {
            inst.op = IROp.ICmp
            inst.cond = CondCode.Sge
        }
        TokenType.KwAnd => { inst.op = IROp.LogAnd }
        TokenType.KwOr => { inst.op = IROp.LogOr }
        TokenType.Ampersand => { inst.op = IROp.BAnd }
        TokenType.Pipe => { inst.op = IROp.BOr }
        TokenType.Caret => { inst.op = IROp.BXor }
        else => {
            lowerError(l, expr.loc.line, "Unknown binary operator")
            return -1
        }
    }

    inst.result_id = result_id
    inst.op1_id = left_id
    inst.op2_id = right_id
    inst.line = expr.loc.line
    lowerEmit(l, inst)
    return result_id
}

fn lowerUnaryExpr(l: Lowerer, expr: Expr) i64 {
    var operand_id: i64 = -1
    if (expr.operand != null) {
        operand_id = lowerExpr(l, expr.operand.*)
    }

    const result_id = lowerNewValue(l)
    var inst = newIRInst(IROp.INeg)

    switch (expr.op) {
        TokenType.Minus => { inst.op = IROp.INeg }
        TokenType.Bang => { inst.op = IROp.LogNot }
        TokenType.Tilde => { inst.op = IROp.BNot }
        else => {
            lowerError(l, expr.loc.line, "Unknown unary operator")
            return -1
        }
    }

    inst.result_id = result_id
    inst.op1_id = operand_id
    inst.line = expr.loc.line
    lowerEmit(l, inst)
    return result_id
}

fn lowerCallExpr(l: Lowerer, expr: Expr) i64 {
    // Get callee name
    var callee_name = ""
    if (expr.callee != null) {
        const callee = expr.callee.*
        if (callee.kind == ExprKind.IdentifierExpr) {
            callee_name = callee.name
        }
    }

    const result_id = lowerNewValue(l)
    var inst = newIRInst(IROp.Call)
    inst.result_id = result_id
    inst.callee = callee_name
    inst.line = expr.loc.line

    // Note: In a full implementation, we'd store arg IDs in a list
    // For now, we store the first few args in op1_id, op2_id, op3_id
    if (len(expr.args) > 0) {
        inst.op1_id = lowerExpr(l, expr.args[0].*)
    }
    if (len(expr.args) > 1) {
        inst.op2_id = lowerExpr(l, expr.args[1].*)
    }
    if (len(expr.args) > 2) {
        inst.op3_id = lowerExpr(l, expr.args[2].*)
    }

    lowerEmit(l, inst)
    return result_id
}

fn lowerFieldExpr(l: Lowerer, expr: Expr) i64 {
    var obj_id: i64 = -1
    if (expr.object != null) {
        obj_id = lowerExpr(l, expr.object.*)
    }

    const result_id = lowerNewValue(l)
    var inst = newIRInst(IROp.FieldPtr)
    inst.result_id = result_id
    inst.op1_id = obj_id
    inst.field_name = expr.field_name
    inst.line = expr.loc.line
    lowerEmit(l, inst)

    // Load the field value
    const load_id = lowerNewValue(l)
    var load_inst = newIRInst(IROp.Load)
    load_inst.result_id = load_id
    load_inst.op1_id = result_id
    load_inst.line = expr.loc.line
    lowerEmit(l, load_inst)

    return load_id
}

fn lowerIndexExpr(l: Lowerer, expr: Expr) i64 {
    var obj_id: i64 = -1
    var idx_id: i64 = -1

    if (expr.object != null) {
        obj_id = lowerExpr(l, expr.object.*)
    }
    if (expr.index != null) {
        idx_id = lowerExpr(l, expr.index.*)
    }

    const result_id = lowerNewValue(l)
    var inst = newIRInst(IROp.ArrayLoad)
    inst.result_id = result_id
    inst.op1_id = obj_id
    inst.op2_id = idx_id
    inst.line = expr.loc.line
    lowerEmit(l, inst)
    return result_id
}

fn lowerStructInitExpr(l: Lowerer, expr: Expr) i64 {
    // Allocate space for the struct
    const alloc_id = lowerNewValue(l)
    var alloc_inst = newIRInst(IROp.Alloca)
    alloc_inst.result_id = alloc_id
    alloc_inst.line = expr.loc.line
    lowerEmit(l, alloc_inst)

    // Initialize each field
    var i: i64 = 0
    while (i < len(expr.field_inits)) {
        const field_init = expr.field_inits[i]

        // Get field pointer
        const field_ptr_id = lowerNewValue(l)
        var field_inst = newIRInst(IROp.FieldPtr)
        field_inst.result_id = field_ptr_id
        field_inst.op1_id = alloc_id
        field_inst.field_name = field_init.name
        field_inst.field_index = i
        field_inst.line = field_init.loc.line
        lowerEmit(l, field_inst)

        // Lower the value and store it
        if (field_init.value != null) {
            const val_id = lowerExpr(l, field_init.value.*)
            var store_inst = newIRInst(IROp.Store)
            store_inst.op1_id = field_ptr_id
            store_inst.op2_id = val_id
            store_inst.line = field_init.loc.line
            lowerEmit(l, store_inst)
        }
        i = i + 1
    }

    // Load the struct value
    const result_id = lowerNewValue(l)
    var load_inst = newIRInst(IROp.Load)
    load_inst.result_id = result_id
    load_inst.op1_id = alloc_id
    load_inst.line = expr.loc.line
    lowerEmit(l, load_inst)
    return result_id
}

fn lowerArrayInitExpr(l: Lowerer, expr: Expr) i64 {
    // Create a new list/array
    const list_id = lowerNewValue(l)
    var list_inst = newIRInst(IROp.ListNew)
    list_inst.result_id = list_id
    list_inst.line = expr.loc.line
    lowerEmit(l, list_inst)

    // Push each element
    var i: i64 = 0
    while (i < len(expr.elements)) {
        const elem_id = lowerExpr(l, expr.elements[i].*)
        var push_inst = newIRInst(IROp.ListPush)
        push_inst.op1_id = list_id
        push_inst.op2_id = elem_id
        push_inst.line = expr.loc.line
        lowerEmit(l, push_inst)
        i = i + 1
    }

    return list_id
}

fn lowerMethodCallExpr(l: Lowerer, expr: Expr) i64 {
    // Lower the receiver object
    var obj_id: i64 = -1
    if (expr.object != null) {
        obj_id = lowerExpr(l, expr.object.*)
    }

    const result_id = lowerNewValue(l)
    var inst = newIRInst(IROp.Call)
    inst.result_id = result_id
    inst.callee = expr.field_name  // Method name
    inst.op1_id = obj_id           // Self/receiver as first arg
    inst.line = expr.loc.line

    // Add remaining arguments
    if (len(expr.args) > 0) {
        inst.op2_id = lowerExpr(l, expr.args[0].*)
    }
    if (len(expr.args) > 1) {
        inst.op3_id = lowerExpr(l, expr.args[1].*)
    }

    lowerEmit(l, inst)
    return result_id
}

fn lowerCastExpr(l: Lowerer, expr: Expr) i64 {
    // Lower the expression being cast
    var val_id: i64 = -1
    if (expr.operand != null) {
        val_id = lowerExpr(l, expr.operand.*)
    }

    // For now, emit a bitcast - actual conversion depends on types
    const result_id = lowerNewValue(l)
    var inst = newIRInst(IROp.Bitcast)
    inst.result_id = result_id
    inst.op1_id = val_id
    inst.line = expr.loc.line
    lowerEmit(l, inst)
    return result_id
}

fn lowerIfExpr(l: Lowerer, expr: Expr) i64 {
    // Lower condition
    var cond_id: i64 = -1
    if (expr.condition != null) {
        cond_id = lowerExpr(l, expr.condition.*)
    }

    // Create blocks
    const then_block = lowerCreateBlock(l, "if_then")
    const else_block = lowerCreateBlock(l, "if_else")
    const merge_block = lowerCreateBlock(l, "if_merge")

    // Allocate result variable
    const result_alloc = lowerNewValue(l)
    var alloc_inst = newIRInst(IROp.Alloca)
    alloc_inst.result_id = result_alloc
    alloc_inst.line = expr.loc.line
    lowerEmit(l, alloc_inst)

    // Branch
    var br_inst = newIRInst(IROp.BrIf)
    br_inst.op1_id = cond_id
    br_inst.target_block = then_block
    br_inst.else_block = else_block
    br_inst.line = expr.loc.line
    lowerEmit(l, br_inst)

    // Then block
    lowerSwitchBlock(l, then_block)
    if (expr.then_branch != null) {
        const then_val = lowerExpr(l, expr.then_branch.*)
        var store_inst = newIRInst(IROp.Store)
        store_inst.op1_id = result_alloc
        store_inst.op2_id = then_val
        lowerEmit(l, store_inst)
    }
    var jmp = newIRInst(IROp.Jump)
    jmp.target_block = merge_block
    lowerEmit(l, jmp)

    // Else block
    lowerSwitchBlock(l, else_block)
    if (expr.else_branch != null) {
        const else_val = lowerExpr(l, expr.else_branch.*)
        var store_inst = newIRInst(IROp.Store)
        store_inst.op1_id = result_alloc
        store_inst.op2_id = else_val
        lowerEmit(l, store_inst)
    }
    jmp = newIRInst(IROp.Jump)
    jmp.target_block = merge_block
    lowerEmit(l, jmp)

    // Merge block - load result
    lowerSwitchBlock(l, merge_block)
    const result_id = lowerNewValue(l)
    var load_inst = newIRInst(IROp.Load)
    load_inst.result_id = result_id
    load_inst.op1_id = result_alloc
    load_inst.line = expr.loc.line
    lowerEmit(l, load_inst)

    return result_id
}

fn lowerBlockExpr(l: Lowerer, expr: Expr) i64 {
    lowerEnterScope(l)

    // Lower all statements in the block
    var i: i64 = 0
    while (i < len(expr.stmts)) {
        lowerStmt(l, expr.stmts[i].*)
        i = i + 1
    }

    // Lower the result expression
    var result_id: i64 = -1
    if (expr.result != null) {
        result_id = lowerExpr(l, expr.result.*)
    }

    lowerExitScope(l)
    return result_id
}

fn lowerSwitchExpr(l: Lowerer, expr: Expr) i64 {
    // Lower the switch condition
    var switch_val: i64 = -1
    if (expr.condition != null) {
        switch_val = lowerExpr(l, expr.condition.*)
    }

    const exit_block = lowerCreateBlock(l, "switch_exit")

    // Allocate result variable
    const result_alloc = lowerNewValue(l)
    var alloc_inst = newIRInst(IROp.Alloca)
    alloc_inst.result_id = result_alloc
    alloc_inst.line = expr.loc.line
    lowerEmit(l, alloc_inst)

    // Note: For a full implementation, we'd handle arms similar to switch statement
    // For now, just use the first value as result
    var jmp = newIRInst(IROp.Jump)
    jmp.target_block = exit_block
    lowerEmit(l, jmp)

    lowerSwitchBlock(l, exit_block)
    const result_id = lowerNewValue(l)
    var load_inst = newIRInst(IROp.Load)
    load_inst.result_id = result_id
    load_inst.op1_id = result_alloc
    load_inst.line = expr.loc.line
    lowerEmit(l, load_inst)

    return result_id
}

fn lowerLambdaExpr(l: Lowerer, expr: Expr) i64 {
    // For lambdas, we create a closure/function reference
    // For now, create a placeholder value
    const result_id = lowerNewValue(l)
    var inst = newIRInst(IROp.IConst)
    inst.result_id = result_id
    inst.result_type_id = l.ir_types.i64_id
    inst.int_val = 0  // Placeholder
    inst.line = expr.loc.line
    lowerEmit(l, inst)

    // Note: Full lambda support would create a closure struct with captures
    return result_id
}

fn lowerRangeExpr(l: Lowerer, expr: Expr) i64 {
    // Lower start and end
    var start_id: i64 = -1
    var end_id: i64 = -1

    if (expr.range_start != null) {
        start_id = lowerExpr(l, expr.range_start.*)
    }
    if (expr.range_end != null) {
        end_id = lowerExpr(l, expr.range_end.*)
    }

    // Create a range struct (or tuple) with start and end
    // For now, allocate and store both values
    const alloc_id = lowerNewValue(l)
    var inst = newIRInst(IROp.Alloca)
    inst.result_id = alloc_id
    inst.line = expr.loc.line
    lowerEmit(l, inst)

    // Store start at field 0
    const start_ptr = lowerNewValue(l)
    inst = newIRInst(IROp.FieldPtr)
    inst.result_id = start_ptr
    inst.op1_id = alloc_id
    inst.field_index = 0
    inst.line = expr.loc.line
    lowerEmit(l, inst)

    inst = newIRInst(IROp.Store)
    inst.op1_id = start_ptr
    inst.op2_id = start_id
    lowerEmit(l, inst)

    // Store end at field 1
    const end_ptr = lowerNewValue(l)
    inst = newIRInst(IROp.FieldPtr)
    inst.result_id = end_ptr
    inst.op1_id = alloc_id
    inst.field_index = 1
    inst.line = expr.loc.line
    lowerEmit(l, inst)

    inst = newIRInst(IROp.Store)
    inst.op1_id = end_ptr
    inst.op2_id = end_id
    lowerEmit(l, inst)

    // Load and return the range struct
    const result_id = lowerNewValue(l)
    inst = newIRInst(IROp.Load)
    inst.result_id = result_id
    inst.op1_id = alloc_id
    inst.line = expr.loc.line
    lowerEmit(l, inst)

    return result_id
}

fn lowerSliceExpr(l: Lowerer, expr: Expr) i64 {
    // Lower the source object
    var obj_id: i64 = -1
    if (expr.object != null) {
        obj_id = lowerExpr(l, expr.object.*)
    }

    // Lower start and end indices
    var start_id: i64 = -1
    var end_id: i64 = -1

    if (expr.slice_start != null) {
        start_id = lowerExpr(l, expr.slice_start.*)
    } else {
        // Default start is 0
        start_id = lowerNewValue(l)
        var inst = newIRInst(IROp.IConst)
        inst.result_id = start_id
        inst.int_val = 0
        lowerEmit(l, inst)
    }

    if (expr.slice_end != null) {
        end_id = lowerExpr(l, expr.slice_end.*)
    }

    // Emit SliceNew instruction
    const result_id = lowerNewValue(l)
    var inst = newIRInst(IROp.SliceNew)
    inst.result_id = result_id
    inst.op1_id = obj_id
    inst.op2_id = start_id
    inst.op3_id = end_id
    inst.line = expr.loc.line
    lowerEmit(l, inst)

    return result_id
}

fn lowerInterpStringExpr(l: Lowerer, expr: Expr) i64 {
    // Interpolated strings: "Hello ${name}!"
    // Build the string by concatenating parts

    if (len(expr.elements) == 0) {
        // Empty string
        const str_index = modAddString(l.module, "")
        const result_id = lowerNewValue(l)
        var inst = newIRInst(IROp.StrConst)
        inst.result_id = result_id
        inst.result_type_id = l.ir_types.string_id
        inst.int_val = str_index
        inst.str_val = ""
        inst.line = expr.loc.line
        lowerEmit(l, inst)
        return result_id
    }

    // Lower first part
    var result_id = lowerExpr(l, expr.elements[0].*)

    // Concatenate remaining parts
    var i: i64 = 1
    while (i < len(expr.elements)) {
        const part_id = lowerExpr(l, expr.elements[i].*)

        // String concatenation
        const concat_id = lowerNewValue(l)
        var inst = newIRInst(IROp.StrConcat)
        inst.result_id = concat_id
        inst.op1_id = result_id
        inst.op2_id = part_id
        inst.line = expr.loc.line
        lowerEmit(l, inst)

        result_id = concat_id
        i = i + 1
    }

    return result_id
}

fn lowerAssignment(l: Lowerer, expr: Expr) i64 {
    // Get the target (left side)
    var target_id: i64 = -1
    if (expr.left != null) {
        const left = expr.left.*
        // For simple identifier, look up the variable
        if (left.kind == ExprKind.IdentifierExpr) {
            target_id = lowerLookupVar(l, left.name)
        } else if (left.kind == ExprKind.FieldExpr) {
            // Field assignment - get field pointer
            var obj_id: i64 = -1
            if (left.object != null) {
                obj_id = lowerExpr(l, left.object.*)
            }
            target_id = lowerNewValue(l)
            var field_inst = newIRInst(IROp.FieldPtr)
            field_inst.result_id = target_id
            field_inst.op1_id = obj_id
            field_inst.field_name = left.field_name
            field_inst.line = expr.loc.line
            lowerEmit(l, field_inst)
        } else if (left.kind == ExprKind.IndexExpr) {
            // Index assignment - lower object and index, use ArrayStore
            var obj_id: i64 = -1
            var idx_id: i64 = -1
            if (left.object != null) {
                obj_id = lowerExpr(l, left.object.*)
            }
            if (left.index != null) {
                idx_id = lowerExpr(l, left.index.*)
            }
            // Lower value and store
            var val_id: i64 = -1
            if (expr.right != null) {
                val_id = lowerExpr(l, expr.right.*)
            }
            var store_inst = newIRInst(IROp.ArrayStore)
            store_inst.op1_id = obj_id
            store_inst.op2_id = idx_id
            store_inst.op3_id = val_id
            store_inst.line = expr.loc.line
            lowerEmit(l, store_inst)
            return val_id
        }
    }

    // Lower the value (right side)
    var val_id: i64 = -1
    if (expr.right != null) {
        val_id = lowerExpr(l, expr.right.*)
    }

    // Store the value
    var store_inst = newIRInst(IROp.Store)
    store_inst.op1_id = target_id
    store_inst.op2_id = val_id
    store_inst.line = expr.loc.line
    lowerEmit(l, store_inst)

    return val_id
}

// =============================================================================
// Statement Lowering
// =============================================================================

fn lowerStmt(l: Lowerer, stmt: Stmt) {
    switch (stmt.kind) {
        StmtKind.ExpressionStmt => {
            if (stmt.expr != null) {
                lowerExpr(l, stmt.expr.*)
            }
        }
        StmtKind.VarDecl => { lowerVarDecl(l, stmt) }
        StmtKind.ConstDecl => { lowerVarDecl(l, stmt) }
        StmtKind.ReturnStmt => { lowerReturnStmt(l, stmt) }
        StmtKind.IfStmt => { lowerIfStmt(l, stmt) }
        StmtKind.WhileStmt => { lowerWhileStmt(l, stmt) }
        StmtKind.ForStmt => { lowerForStmt(l, stmt) }
        StmtKind.LoopStmt => { lowerLoopStmt(l, stmt) }
        StmtKind.SwitchStmt => { lowerSwitchStmt(l, stmt) }
        StmtKind.BlockStmt => { lowerBlockStmt(l, stmt) }
        StmtKind.BreakStmt => { lowerBreakStmt(l, stmt) }
        StmtKind.ContinueStmt => { lowerContinueStmt(l, stmt) }
        StmtKind.DeferStmt => { lowerDeferStmt(l, stmt) }
        StmtKind.TryStmt => { lowerTryStmt(l, stmt) }
        StmtKind.ThrowStmt => { lowerThrowStmt(l, stmt) }
        StmtKind.ImplDecl => { lowerImplDecl(l, stmt) }
        StmtKind.TestDecl => { lowerTestDecl(l, stmt) }
        StmtKind.ViewDecl => { lowerViewDecl(l, stmt) }
        StmtKind.ComptimeStmt => { lowerComptimeStmt(l, stmt) }
        StmtKind.ImportStmt => { lowerImportStmt(l, stmt) }
        StmtKind.StructDecl => { lowerStructDecl(l, stmt) }
        StmtKind.EnumDecl => { lowerEnumDecl(l, stmt) }
        StmtKind.UnionDecl => { lowerUnionDecl(l, stmt) }
        StmtKind.TraitDecl => { lowerTraitDecl(l, stmt) }
        StmtKind.TypeAliasDecl => { lowerTypeAliasDecl(l, stmt) }
        else => {
            // FunctionDecl handled at module level
        }
    }
}

fn lowerVarDecl(l: Lowerer, stmt: Stmt) {
    // Allocate space for the variable
    const alloc_id = lowerNewValue(l)
    var alloc_inst = newIRInst(IROp.Alloca)
    alloc_inst.result_id = alloc_id
    alloc_inst.line = stmt.loc.line
    lowerEmit(l, alloc_inst)

    // Register variable in scope
    lowerDefineVar(l, stmt.var_name, alloc_id)

    // Initialize if there's an init expression
    if (stmt.var_init != null) {
        const init_id = lowerExpr(l, stmt.var_init.*)

        var store_inst = newIRInst(IROp.Store)
        store_inst.op1_id = alloc_id
        store_inst.op2_id = init_id
        store_inst.line = stmt.loc.line
        lowerEmit(l, store_inst)
    }
}

fn lowerReturnStmt(l: Lowerer, stmt: Stmt) {
    var value_id: i64 = -1
    if (stmt.return_value != null) {
        value_id = lowerExpr(l, stmt.return_value.*)
    }

    var inst = newIRInst(IROp.Ret)
    inst.op1_id = value_id
    inst.line = stmt.loc.line
    lowerEmit(l, inst)
}

fn lowerIfStmt(l: Lowerer, stmt: Stmt) {
    // Lower condition
    var cond_id: i64 = -1
    if (stmt.if_cond != null) {
        cond_id = lowerExpr(l, stmt.if_cond.*)
    }

    // Create blocks
    const then_block = lowerCreateBlock(l, "then")
    const else_block = lowerCreateBlock(l, "else")
    const merge_block = lowerCreateBlock(l, "merge")

    // Emit branch
    var br_inst = newIRInst(IROp.BrIf)
    br_inst.op1_id = cond_id
    br_inst.target_block = then_block
    br_inst.else_block = else_block
    br_inst.line = stmt.loc.line
    lowerEmit(l, br_inst)

    // Lower then branch
    lowerSwitchBlock(l, then_block)
    if (stmt.if_then != null) {
        lowerStmt(l, stmt.if_then.*)
    }
    // Jump to merge (if not terminated)
    if (l.current_func_idx >= 0) {
        const func = lowerGetCurrentFunc(l)
        const tb = fnGetBlock(func, then_block)
        if (not blockIsTerminated(tb)) {
            var jmp = newIRInst(IROp.Jump)
            jmp.target_block = merge_block
            lowerEmit(l, jmp)
        }
    }

    // Lower else branch
    lowerSwitchBlock(l, else_block)
    if (stmt.if_else != null) {
        lowerStmt(l, stmt.if_else.*)
    }
    // Jump to merge (if not terminated)
    if (l.current_func_idx >= 0) {
        const func = lowerGetCurrentFunc(l)
        const eb = fnGetBlock(func, else_block)
        if (not blockIsTerminated(eb)) {
            var jmp = newIRInst(IROp.Jump)
            jmp.target_block = merge_block
            lowerEmit(l, jmp)
        }
    }

    // Continue from merge block
    lowerSwitchBlock(l, merge_block)
}

fn lowerWhileStmt(l: Lowerer, stmt: Stmt) {
    // Create blocks
    const cond_block = lowerCreateBlock(l, "while_cond")
    const body_block = lowerCreateBlock(l, "while_body")
    const exit_block = lowerCreateBlock(l, "while_exit")

    // Jump to condition
    var jmp_cond = newIRInst(IROp.Jump)
    jmp_cond.target_block = cond_block
    lowerEmit(l, jmp_cond)

    // Condition block
    lowerSwitchBlock(l, cond_block)
    var cond_id: i64 = -1
    if (stmt.while_cond != null) {
        cond_id = lowerExpr(l, stmt.while_cond.*)
    }
    var br_inst = newIRInst(IROp.BrIf)
    br_inst.op1_id = cond_id
    br_inst.target_block = body_block
    br_inst.else_block = exit_block
    lowerEmit(l, br_inst)

    // Body block (with loop scope for break/continue)
    lowerSwitchBlock(l, body_block)
    lowerEnterLoopScope(l, exit_block, cond_block)
    if (stmt.while_body != null) {
        lowerStmt(l, stmt.while_body.*)
    }
    lowerExitScope(l)

    // Jump back to condition (if not terminated)
    if (l.current_func_idx >= 0) {
        const func = lowerGetCurrentFunc(l)
        const bb = fnGetBlock(func, body_block)
        if (not blockIsTerminated(bb)) {
            var jmp_back = newIRInst(IROp.Jump)
            jmp_back.target_block = cond_block
            lowerEmit(l, jmp_back)
        }
    }

    // Continue from exit block
    lowerSwitchBlock(l, exit_block)
}

fn lowerBlockStmt(l: Lowerer, stmt: Stmt) {
    lowerEnterScope(l)
    var i: i64 = 0
    while (i < len(stmt.block_stmts)) {
        lowerStmt(l, stmt.block_stmts[i].*)
        i = i + 1
    }
    lowerExitScope(l)
}

fn lowerBreakStmt(l: Lowerer, stmt: Stmt) {
    const exit_block = lowerGetLoopExit(l)
    if (exit_block >= 0) {
        var inst = newIRInst(IROp.Jump)
        inst.target_block = exit_block
        inst.line = stmt.loc.line
        lowerEmit(l, inst)
    } else {
        lowerError(l, stmt.loc.line, "break outside of loop")
    }
}

fn lowerContinueStmt(l: Lowerer, stmt: Stmt) {
    const continue_block = lowerGetLoopContinue(l)
    if (continue_block >= 0) {
        var inst = newIRInst(IROp.Jump)
        inst.target_block = continue_block
        inst.line = stmt.loc.line
        lowerEmit(l, inst)
    } else {
        lowerError(l, stmt.loc.line, "continue outside of loop")
    }
}

fn lowerForStmt(l: Lowerer, stmt: Stmt) {
    // For loops: for (x in iter) { body }
    // Simplified lowering - treat as while loop over range

    // Create blocks
    const cond_block = lowerCreateBlock(l, "for_cond")
    const body_block = lowerCreateBlock(l, "for_body")
    const exit_block = lowerCreateBlock(l, "for_exit")

    // Lower the iterator and allocate index
    var iter_id: i64 = -1
    if (stmt.for_iter != null) {
        iter_id = lowerExpr(l, stmt.for_iter.*)
    }

    // Allocate index, init to 0, jump to cond
    const idx_id = lowerNewValue(l)
    var inst = newIRInst(IROp.Alloca)
    inst.result_id = idx_id
    lowerEmit(l, inst)

    const zero_id = lowerNewValue(l)
    inst = newIRInst(IROp.IConst)
    inst.result_id = zero_id
    inst.int_val = 0
    lowerEmit(l, inst)

    inst = newIRInst(IROp.Store)
    inst.op1_id = idx_id
    inst.op2_id = zero_id
    lowerEmit(l, inst)

    inst = newIRInst(IROp.Jump)
    inst.target_block = cond_block
    lowerEmit(l, inst)

    // Condition: idx < len(iter)
    lowerSwitchBlock(l, cond_block)
    lowerForCondition(l, idx_id, iter_id, body_block, exit_block, stmt.loc.line)

    // Body
    lowerSwitchBlock(l, body_block)
    lowerForBody(l, stmt, idx_id, iter_id, cond_block, exit_block)

    // Exit
    lowerSwitchBlock(l, exit_block)
}

fn lowerForCondition(l: Lowerer, idx_id: i64, iter_id: i64, body_block: i64, exit_block: i64, line: i64) {
    const cur_idx = lowerNewValue(l)
    var inst = newIRInst(IROp.Load)
    inst.result_id = cur_idx
    inst.op1_id = idx_id
    lowerEmit(l, inst)

    const len_id = lowerNewValue(l)
    inst = newIRInst(IROp.ListLen)
    inst.result_id = len_id
    inst.op1_id = iter_id
    lowerEmit(l, inst)

    const cmp_id = lowerNewValue(l)
    inst = newIRInst(IROp.ICmp)
    inst.result_id = cmp_id
    inst.op1_id = cur_idx
    inst.op2_id = len_id
    inst.cond = CondCode.Slt
    lowerEmit(l, inst)

    inst = newIRInst(IROp.BrIf)
    inst.op1_id = cmp_id
    inst.target_block = body_block
    inst.else_block = exit_block
    lowerEmit(l, inst)
}

fn lowerForBody(l: Lowerer, stmt: Stmt, idx_id: i64, iter_id: i64, cond_block: i64, exit_block: i64) {
    lowerEnterLoopScope(l, exit_block, cond_block)

    // Load current index for element access
    const cur_idx = lowerNewValue(l)
    var inst = newIRInst(IROp.Load)
    inst.result_id = cur_idx
    inst.op1_id = idx_id
    lowerEmit(l, inst)

    // Get element
    const elem_id = lowerNewValue(l)
    inst = newIRInst(IROp.ListGet)
    inst.result_id = elem_id
    inst.op1_id = iter_id
    inst.op2_id = cur_idx
    lowerEmit(l, inst)

    // Alloc and store loop var
    const var_id = lowerNewValue(l)
    inst = newIRInst(IROp.Alloca)
    inst.result_id = var_id
    lowerEmit(l, inst)

    inst = newIRInst(IROp.Store)
    inst.op1_id = var_id
    inst.op2_id = elem_id
    lowerEmit(l, inst)

    lowerDefineVar(l, stmt.for_var, var_id)

    // Lower body
    if (stmt.for_body != null) {
        lowerStmt(l, stmt.for_body.*)
    }

    lowerExitScope(l)

    // Increment and jump back
    lowerForIncrement(l, idx_id, cond_block)
}

fn lowerForIncrement(l: Lowerer, idx_id: i64, cond_block: i64) {
    const cur = lowerNewValue(l)
    var inst = newIRInst(IROp.Load)
    inst.result_id = cur
    inst.op1_id = idx_id
    lowerEmit(l, inst)

    const one = lowerNewValue(l)
    inst = newIRInst(IROp.IConst)
    inst.result_id = one
    inst.int_val = 1
    lowerEmit(l, inst)

    const next = lowerNewValue(l)
    inst = newIRInst(IROp.IAdd)
    inst.result_id = next
    inst.op1_id = cur
    inst.op2_id = one
    lowerEmit(l, inst)

    inst = newIRInst(IROp.Store)
    inst.op1_id = idx_id
    inst.op2_id = next
    lowerEmit(l, inst)

    inst = newIRInst(IROp.Jump)
    inst.target_block = cond_block
    lowerEmit(l, inst)
}

fn lowerSwitchStmt(l: Lowerer, stmt: Stmt) {
    // Lower the switch expression
    var switch_val: i64 = -1
    if (stmt.switch_expr != null) {
        switch_val = lowerExpr(l, stmt.switch_expr.*)
    }

    const exit_block = lowerCreateBlock(l, "switch_exit")

    // Create blocks for arms
    var arm_blocks: List<i64> = List.new()
    var i: i64 = 0
    while (i < len(stmt.switch_arms)) {
        arm_blocks.push(lowerCreateBlock(l, "switch_arm"))
        i = i + 1
    }

    // Find default block
    var default_block = exit_block
    i = 0
    while (i < len(stmt.switch_arms)) {
        if (stmt.switch_arms[i].is_default) {
            default_block = arm_blocks.get(i)
        }
        i = i + 1
    }

    // Generate comparisons
    i = 0
    while (i < len(stmt.switch_arms)) {
        lowerSwitchArm(l, stmt.switch_arms[i], arm_blocks.get(i), switch_val)
        i = i + 1
    }

    // Jump to default after all comparisons
    var inst = newIRInst(IROp.Jump)
    inst.target_block = default_block
    lowerEmit(l, inst)

    // Lower bodies
    i = 0
    while (i < len(stmt.switch_arms)) {
        lowerSwitchArmBody(l, stmt.switch_arms[i], arm_blocks.get(i), exit_block)
        i = i + 1
    }

    lowerSwitchBlock(l, exit_block)
}

fn lowerSwitchArm(l: Lowerer, arm: SwitchArm, arm_block: i64, switch_val: i64) {
    if (arm.is_default) {
        return
    }

    var pattern_val: i64 = -1
    if (arm.pattern != null) {
        pattern_val = lowerExpr(l, arm.pattern.*)
    }

    const cmp_id = lowerNewValue(l)
    var inst = newIRInst(IROp.ICmp)
    inst.result_id = cmp_id
    inst.op1_id = switch_val
    inst.op2_id = pattern_val
    inst.cond = CondCode.Eq
    lowerEmit(l, inst)

    const next_check = lowerCreateBlock(l, "switch_next")
    inst = newIRInst(IROp.BrIf)
    inst.op1_id = cmp_id
    inst.target_block = arm_block
    inst.else_block = next_check
    lowerEmit(l, inst)

    lowerSwitchBlock(l, next_check)
}

fn lowerSwitchArmBody(l: Lowerer, arm: SwitchArm, arm_block: i64, exit_block: i64) {
    lowerSwitchBlock(l, arm_block)
    if (arm.body != null) {
        lowerExpr(l, arm.body.*)
    }

    // Jump to exit if not terminated
    if (l.current_func_idx >= 0) {
        const func = lowerGetCurrentFunc(l)
        const bb = fnGetBlock(func, arm_block)
        if (not blockIsTerminated(bb)) {
            var inst = newIRInst(IROp.Jump)
            inst.target_block = exit_block
            lowerEmit(l, inst)
        }
    }
}

fn lowerLoopStmt(l: Lowerer, stmt: Stmt) {
    // Infinite loop: loop { body }
    const body_block = lowerCreateBlock(l, "loop_body")
    const exit_block = lowerCreateBlock(l, "loop_exit")

    // Jump to body
    var jmp = newIRInst(IROp.Jump)
    jmp.target_block = body_block
    jmp.line = stmt.loc.line
    lowerEmit(l, jmp)

    // Body block
    lowerSwitchBlock(l, body_block)
    lowerEnterLoopScope(l, exit_block, body_block)

    if (stmt.loop_body != null) {
        lowerStmt(l, stmt.loop_body.*)
    }

    lowerExitScope(l)

    // Jump back to body (if not terminated)
    if (l.current_func_idx >= 0) {
        const func = lowerGetCurrentFunc(l)
        const bb = fnGetBlock(func, body_block)
        if (not blockIsTerminated(bb)) {
            var jmp_back = newIRInst(IROp.Jump)
            jmp_back.target_block = body_block
            lowerEmit(l, jmp_back)
        }
    }

    // Continue from exit block
    lowerSwitchBlock(l, exit_block)
}

fn lowerDeferStmt(l: Lowerer, stmt: Stmt) {
    // Defer: push deferred expression onto a stack, execute at function/scope exit
    // For now, emit the expression at point of defer (simplified)
    // A full implementation would track deferred expressions and emit at scope exit
    if (stmt.defer_expr != null) {
        lowerExpr(l, stmt.defer_expr.*)
    }
}

fn lowerTryStmt(l: Lowerer, stmt: Stmt) {
    // Try/catch statement
    const try_block = lowerCreateBlock(l, "try")
    const catch_block = lowerCreateBlock(l, "catch")
    const exit_block = lowerCreateBlock(l, "try_exit")

    // Jump to try block
    var jmp = newIRInst(IROp.Jump)
    jmp.target_block = try_block
    lowerEmit(l, jmp)

    // Try block
    lowerSwitchBlock(l, try_block)
    lowerEnterScope(l)
    if (stmt.try_body != null) {
        lowerStmt(l, stmt.try_body.*)
    }
    lowerExitScope(l)

    // Jump to exit (no error)
    if (l.current_func_idx >= 0) {
        const func = lowerGetCurrentFunc(l)
        const tb = fnGetBlock(func, try_block)
        if (not blockIsTerminated(tb)) {
            jmp = newIRInst(IROp.Jump)
            jmp.target_block = exit_block
            lowerEmit(l, jmp)
        }
    }

    // Catch block
    lowerSwitchBlock(l, catch_block)
    lowerEnterScope(l)

    // Register catch variable if present
    if (stmt.catch_var != "") {
        const err_id = lowerNewValue(l)
        var alloc_inst = newIRInst(IROp.Alloca)
        alloc_inst.result_id = err_id
        lowerEmit(l, alloc_inst)
        lowerDefineVar(l, stmt.catch_var, err_id)
    }

    if (stmt.catch_body != null) {
        lowerStmt(l, stmt.catch_body.*)
    }
    lowerExitScope(l)

    // Jump to exit from catch
    if (l.current_func_idx >= 0) {
        const func = lowerGetCurrentFunc(l)
        const cb = fnGetBlock(func, catch_block)
        if (not blockIsTerminated(cb)) {
            jmp = newIRInst(IROp.Jump)
            jmp.target_block = exit_block
            lowerEmit(l, jmp)
        }
    }

    // Continue from exit
    lowerSwitchBlock(l, exit_block)
}

fn lowerThrowStmt(l: Lowerer, stmt: Stmt) {
    // Throw statement - emit the error value
    if (stmt.throw_expr != null) {
        const err_id = lowerExpr(l, stmt.throw_expr.*)

        // Emit throw instruction
        var inst = newIRInst(IROp.ErrThrow)
        inst.op1_id = err_id
        inst.line = stmt.loc.line
        lowerEmit(l, inst)
    }
}

fn lowerImplDecl(l: Lowerer, stmt: Stmt) {
    // Impl block - lower each method as a function
    var i: i64 = 0
    while (i < len(stmt.impl_methods)) {
        const method = stmt.impl_methods[i]
        lowerFunction(l, method.*)
        i = i + 1
    }
}

fn lowerTestDecl(l: Lowerer, stmt: Stmt) {
    // Test declaration - create a test function
    var func = newIRFunction("test_${stmt.test_name}")
    // Note: is_test field would be added to IRFunction

    const func_idx = modAddFunction(l.module, func)
    l.current_func_idx = func_idx

    var cur_func = l.module.functions.get(func_idx)
    const entry = fnCreateBlock(cur_func, "entry")
    cur_func.entry_block = entry
    l.current_block = entry

    lowerEnterScope(l)

    if (stmt.test_body != null) {
        lowerStmt(l, stmt.test_body.*)
    }

    lowerExitScope(l)

    l.current_func_idx = -1
    l.current_block = -1
}

fn lowerViewDecl(l: Lowerer, stmt: Stmt) {
    // View declaration - register in IR module
    // Views are handled at type-level, not runtime
    // Just record metadata for later use
}

fn lowerComptimeStmt(l: Lowerer, stmt: Stmt) {
    // Comptime statement - for bootstrap, just lower the body normally
    // Full comptime evaluation would happen during compilation
    if (stmt.comptime_body != null) {
        lowerStmt(l, stmt.comptime_body.*)
    }
}

fn lowerImportStmt(l: Lowerer, stmt: Stmt) {
    // Import statement - record the import path
    // For bootstrap, imports are handled at module resolution level
    // Metadata only - no runtime code emitted
}

fn lowerStructDecl(l: Lowerer, stmt: Stmt) {
    // Struct declaration - metadata only, no runtime code
    // Type information is tracked by the type checker
    // Structs are instantiated via StructInitExpr
}

fn lowerEnumDecl(l: Lowerer, stmt: Stmt) {
    // Enum declaration - metadata only, no runtime code
    // Type information is tracked by the type checker
    // Enum variants are used directly as integer constants
}

fn lowerUnionDecl(l: Lowerer, stmt: Stmt) {
    // Union declaration - metadata only, no runtime code
    // Type information is tracked by the type checker
}

fn lowerTraitDecl(l: Lowerer, stmt: Stmt) {
    // Trait declaration - metadata only, no runtime code
    // Trait information is used at type-check time for validation
}

fn lowerTypeAliasDecl(l: Lowerer, stmt: Stmt) {
    // Type alias - metadata only, no runtime code
    // The type checker resolves aliases to their underlying types
}

// =============================================================================
// Function Lowering
// =============================================================================

fn lowerFunction(l: Lowerer, stmt: Stmt) {
    var func = newIRFunction(stmt.fn_name)
    func.is_public = stmt.fn_public

    // Set up parameters
    var i: i64 = 0
    while (i < len(stmt.fn_params)) {
        const param = stmt.fn_params[i]
        func.param_names.push(param.name)
        // Type mapping would go here
        i = i + 1
    }

    // Add function to module and set as current
    const func_idx = modAddFunction(l.module, func)
    l.current_func_idx = func_idx

    // Get the function from the module (after it's been added)
    var cur_func = l.module.functions.get(func_idx)

    // Create entry block
    const entry = fnCreateBlock(cur_func, "entry")
    cur_func.entry_block = entry
    l.current_block = entry

    // Enter function scope
    lowerEnterScope(l)

    // Add parameters to scope
    i = 0
    while (i < len(stmt.fn_params)) {
        const param = stmt.fn_params[i]
        const param_id = fnNewValue(cur_func)
        lowerDefineVar(l, param.name, param_id)
        i = i + 1
    }

    // Lower function body
    if (stmt.fn_body != null) {
        lowerStmt(l, stmt.fn_body.*)
    }

    // Exit function scope
    lowerExitScope(l)

    // Clear current function
    l.current_func_idx = -1
    l.current_block = -1
}

// =============================================================================
// Module Lowering (Entry Point)
// =============================================================================

fn lowerModule(l: Lowerer, stmts: []Stmt) {
    var i: i64 = 0
    while (i < len(stmts)) {
        const stmt = stmts[i]
        switch (stmt.kind) {
            StmtKind.FunctionDecl => { lowerFunction(l, stmt) }
            else => {
                // Other top-level declarations (struct, enum, etc.) handled later
            }
        }
        i = i + 1
    }
}
