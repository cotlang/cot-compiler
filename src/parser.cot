// Parser for the Cot self-hosted compiler
//
// Implements a Pratt parser (top-down operator precedence) for parsing
// Cot source code into an AST.

import "token"
import "ast"
import "lexer"

// =============================================================================
// Parser State
// =============================================================================

struct Parser {
    lexer: Lexer,
    current: Token,
    previous: Token,
    had_error: bool,
    panic_mode: bool,
    errors: List<string>,
}

// =============================================================================
// Parser Implementation
// =============================================================================

impl Parser {
    // Create a new parser for the given source
    fn create(source: string) Parser {
        println("[Parser.create] 1 creating lexer")
        var lex: Lexer = Lexer.create(source)
        println("[Parser.create] 2 lexer created, scanning first token")
        var first_token: Token = lex.scanToken()
        println("[Parser.create] 3 first token scanned: " + string(first_token.token_type as i64))
        var errs = new List<string>
        println("[Parser.create] 4 returning parser")

        return Parser{
            .lexer = lex,
            .current = first_token,
            .previous = first_token,
            .had_error = false,
            .panic_mode = false,
            .errors = errs,
        }
    }

    // Advance to the next token
    fn advance(self: *Parser) {
        self.previous = self.current

        // Skip error tokens, reporting them
        while (true) {
            self.current = self.lexer.scanToken()
            if (self.current.token_type != TokenType.Invalid) {
                break
            }
            self.errorAtCurrent(self.current.lexeme)
        }
    }

    // Check if current token matches type
    fn check(self: *Parser, token_type: TokenType) bool {
        return self.current.token_type == token_type
    }

    // Check if current token matches and advance if so
    fn match(self: *Parser, token_type: TokenType) bool {
        if (!self.check(token_type)) {
            return false
        }
        self.advance()
        return true
    }

    // Consume a token of expected type or error
    fn consume(self: *Parser, token_type: TokenType, message: string) {
        if (self.current.token_type == token_type) {
            self.advance()
            return
        }
        self.errorAtCurrent(message)
    }

    // Check if we're at end of file
    fn isAtEnd(self: *Parser) bool {
        return self.current.token_type == TokenType.Eof
    }

    // Peek at current token type
    fn peek(self: *Parser) TokenType {
        return self.current.token_type
    }

    // Peek at previous token type
    fn previous(self: *Parser) TokenType {
        return self.previous.token_type
    }

    // =========================================================================
    // Error Handling
    // =========================================================================

    fn errorAt(self: *Parser, token: Token, message: string) {
        if (self.panic_mode) {
            return
        }
        self.panic_mode = true
        self.had_error = true

        var loc: string = "[line " + string(token.line) + "] Error"
        var err_msg: string = ""

        switch (token.token_type) {
            TokenType.Eof => {
                err_msg = loc + " at end: " + message
            }
            TokenType.Invalid => {
                err_msg = loc + ": " + message
            }
        }
        if (err_msg == "") {
            err_msg = loc + " at '" + token.lexeme + "': " + message
        }
        self.errors.push(err_msg)
    }

    fn error(self: *Parser, message: string) {
        self.errorAt(self.previous, message)
    }

    fn errorAtCurrent(self: *Parser, message: string) {
        self.errorAt(self.current, message)
    }

    // Synchronize after an error - skip tokens until we find a statement boundary
    fn synchronize(self: *Parser) {
        self.panic_mode = false

        while (!self.isAtEnd()) {
            // Synchronize on statement-ending semicolons
            if (self.previous.token_type == TokenType.Semicolon) {
                return
            }

            // Synchronize on statement-starting keywords
            switch (self.current.token_type) {
                TokenType.KwFn => { return }
                TokenType.KwStruct => { return }
                TokenType.KwEnum => { return }
                TokenType.KwVar => { return }
                TokenType.KwConst => { return }
                TokenType.KwIf => { return }
                TokenType.KwWhile => { return }
                TokenType.KwFor => { return }
                TokenType.KwReturn => { return }
                TokenType.KwImport => { return }
                TokenType.KwImpl => { return }
            }

            self.advance()
        }
    }
}

// =============================================================================
// Operator Precedence
// =============================================================================

enum Precedence {
    PrecNone,
    PrecAssignment,     // =
    PrecRange,          // .. ..=
    PrecNullCoalesce,   // ??
    PrecOr,             // or ||
    PrecAnd,            // and &&
    PrecBitOr,          // |
    PrecBitXor,         // ^
    PrecBitAnd,         // & (binary)
    PrecEquality,       // == !=
    PrecComparison,     // < > <= >=
    PrecCast,           // as is
    PrecShift,          // << >>
    PrecTerm,           // + - ++
    PrecFactor,         // * / %
    PrecUnary,          // ! - & *
    PrecCall,           // . () []
    PrecPrimary,
}

// Get precedence of a binary operator token
fn getInfixPrecedence(token_type: TokenType) Precedence {
    switch (token_type) {
        // Assignment
        TokenType.Equals => { return Precedence.PrecAssignment }
        TokenType.PlusEquals => { return Precedence.PrecAssignment }
        TokenType.MinusEquals => { return Precedence.PrecAssignment }
        TokenType.StarEquals => { return Precedence.PrecAssignment }
        TokenType.SlashEquals => { return Precedence.PrecAssignment }
        TokenType.PipeEquals => { return Precedence.PrecAssignment }
        TokenType.AmpEquals => { return Precedence.PrecAssignment }

        // Range
        TokenType.Range => { return Precedence.PrecRange }
        TokenType.RangeInclusive => { return Precedence.PrecRange }

        // Null coalescing
        TokenType.QuestionQuestion => { return Precedence.PrecNullCoalesce }

        // Logical
        TokenType.KwOr => { return Precedence.PrecOr }
        TokenType.PipePipe => { return Precedence.PrecOr }
        TokenType.KwAnd => { return Precedence.PrecAnd }
        TokenType.AmpAmp => { return Precedence.PrecAnd }

        // Bitwise
        TokenType.Pipe => { return Precedence.PrecBitOr }
        TokenType.Caret => { return Precedence.PrecBitXor }
        TokenType.Ampersand => { return Precedence.PrecBitAnd }

        // Equality
        TokenType.EqualEqual => { return Precedence.PrecEquality }
        TokenType.BangEqual => { return Precedence.PrecEquality }

        // Comparison
        TokenType.Less => { return Precedence.PrecComparison }
        TokenType.LessEqual => { return Precedence.PrecComparison }
        TokenType.Greater => { return Precedence.PrecComparison }
        TokenType.GreaterEqual => { return Precedence.PrecComparison }

        // Type operators
        TokenType.KwAs => { return Precedence.PrecCast }
        TokenType.KwIs => { return Precedence.PrecCast }

        // Shift
        TokenType.LessLess => { return Precedence.PrecShift }
        TokenType.GreaterGreater => { return Precedence.PrecShift }

        // Term (additive)
        TokenType.Plus => { return Precedence.PrecTerm }
        TokenType.Minus => { return Precedence.PrecTerm }
        TokenType.PlusPlus => { return Precedence.PrecTerm }

        // Factor (multiplicative)
        TokenType.Star => { return Precedence.PrecFactor }
        TokenType.Slash => { return Precedence.PrecFactor }
        TokenType.Percent => { return Precedence.PrecFactor }

        // Call/access
        TokenType.LeftParen => { return Precedence.PrecCall }
        TokenType.LeftBracket => { return Precedence.PrecCall }
        TokenType.Dot => { return Precedence.PrecCall }
        TokenType.QuestionDot => { return Precedence.PrecCall }
        TokenType.QuestionBracket => { return Precedence.PrecCall }
    }

    return Precedence.PrecNone
}

// =============================================================================
// Expression Parsing (Pratt Parser)
// =============================================================================

// Note: Due to limitations with pointer allocation, we use a simplified
// expression representation that returns values instead of pointers.
// For a full AST, we'd need proper memory management.

impl Parser {
    // Parse a primary expression (literals, identifiers, grouping)
    fn parsePrimaryExpr(self: *Parser) *Expr {
        var token: Token = self.current
        var loc: SourceLoc = SourceLoc.fromToken(token)

        switch (token.token_type) {
            // Integer literal
            TokenType.IntegerLiteral => {
                self.advance()
                return makeIntExpr(parseInt(token.lexeme), loc)
            }

            // Decimal literal
            TokenType.DecimalLiteral => {
                self.advance()
                return makeDecExpr(token.lexeme, loc)
            }

            // String literal
            TokenType.StringLiteral => {
                self.advance()
                return makeStrExpr(processStringLiteral(token.lexeme), loc)
            }

            // Interpolated string: "Hello ${name}!"
            TokenType.StringInterpStart => {
                return self.parseInterpString(loc)
            }

            // Boolean literals
            TokenType.KwTrue => {
                self.advance()
                return makeBoolExpr(true, loc)
            }

            TokenType.KwFalse => {
                self.advance()
                return makeBoolExpr(false, loc)
            }

            // Null literal
            TokenType.KwNull => {
                self.advance()
                return makeNullExpr(loc)
            }

            // Identifier (may be followed by struct init)
            TokenType.Identifier => {
                var name: string = token.lexeme
                self.advance()

                // Check for struct init: Type{ .field = val }
                if (self.check(TokenType.LeftBrace)) {
                    return self.parseStructInit(name, loc)
                }

                return makeIdentExpr(name, loc)
            }

            // Grouping expression
            TokenType.LeftParen => {
                self.advance()
                var inner: *Expr = self.parseExpr()
                self.consume(TokenType.RightParen, "Expected ')' after expression")
                return inner
            }

            // Array init: [expr, expr, ...]
            TokenType.LeftBracket => {
                return self.parseArrayInit(loc)
            }

            // Lambda: |params| body
            TokenType.Pipe => {
                return self.parseLambdaExpr(loc)
            }

            // Unary minus
            TokenType.Minus => {
                self.advance()
                var operand: *Expr = self.parsePrimaryExpr()
                return makeUnaryExpr(TokenType.Minus, operand, loc)
            }

            // Unary not
            TokenType.Bang => {
                self.advance()
                var operand: *Expr = self.parsePrimaryExpr()
                return makeUnaryExpr(TokenType.Bang, operand, loc)
            }

            // Address-of
            TokenType.Ampersand => {
                self.advance()
                var operand: *Expr = self.parsePrimaryExpr()
                return makeUnaryExpr(TokenType.Ampersand, operand, loc)
            }

            // Unary bitwise not
            TokenType.Tilde => {
                self.advance()
                var operand: *Expr = self.parsePrimaryExpr()
                return makeUnaryExpr(TokenType.Tilde, operand, loc)
            }
        }

        self.errorAtCurrent("Expected expression")
        return makeNullExpr(loc)
    }

    // Parse an expression (entry point)
    fn parseExpr(self: *Parser) *Expr {
        return self.parseExprPrec(Precedence.PrecAssignment)
    }

    // Parse an expression with minimum precedence (Pratt parser)
    fn parseExprPrec(self: *Parser, min_prec: Precedence) *Expr {
        // Parse prefix (primary expression)
        var left: *Expr = self.parsePrimaryExpr()

        // Parse infix and postfix operators while they have sufficient precedence
        while (true) {
            // Exit if at end of input
            if (self.isAtEnd()) {
                break
            }

            var loc: SourceLoc = SourceLoc.fromToken(self.current)

            // Handle postfix operators (call, field access, index) at PrecCall level
            if (precToInt(min_prec) <= precToInt(Precedence.PrecCall)) {
                // Function call: expr(args...)
                if (self.current.token_type == TokenType.LeftParen) {
                    left = self.parseCallExpr(left, loc)
                    continue
                }

                // Field access: expr.field
                if (self.current.token_type == TokenType.Dot) {
                    left = self.parseFieldExpr(left, loc)
                    continue
                }

                // Index access: expr[index]
                if (self.current.token_type == TokenType.LeftBracket) {
                    left = self.parseIndexExpr(left, loc)
                    continue
                }

                // Optional chaining: expr?.field
                if (self.current.token_type == TokenType.QuestionDot) {
                    left = self.parseOptionalFieldExpr(left, loc)
                    continue
                }

                // Optional index: expr?[index]
                if (self.current.token_type == TokenType.QuestionBracket) {
                    left = self.parseOptionalIndexExpr(left, loc)
                    continue
                }

                // Dereference: expr.*
                if (self.current.token_type == TokenType.Dot) {
                    // Check for .* (peek ahead after the dot)
                    // This case is already handled by parseFieldExpr
                }
            }

            // Handle binary infix operators
            var op_prec: Precedence = getInfixPrecedence(self.current.token_type)

            // Stop if the operator has lower precedence than our minimum
            if (precToInt(op_prec) < precToInt(min_prec)) {
                break
            }

            // Get the operator token and advance
            var op_token: Token = self.current
            self.advance()

            // Handle type operators specially (as, is)
            if (op_token.token_type == TokenType.KwAs) {
                var target_type: *TypeRef = self.parseType()
                left = makeCastExpr(left, target_type, loc)
                continue
            }
            if (op_token.token_type == TokenType.KwIs) {
                var check_type: *TypeRef = self.parseType()
                left = makeTypeCheckExpr(left, check_type, loc)
                continue
            }

            // Handle range operators: start..end or start..=end
            if (op_token.token_type == TokenType.Range) {
                var right: *Expr = self.parseExprPrec(intToPrec(precToInt(op_prec) + 1))
                left = makeRangeExpr(left, right, false, loc)
                continue
            }
            if (op_token.token_type == TokenType.RangeInclusive) {
                var right: *Expr = self.parseExprPrec(intToPrec(precToInt(op_prec) + 1))
                left = makeRangeExpr(left, right, true, loc)
                continue
            }

            // Parse the right-hand side with higher precedence
            // Right-associative for assignment, left-associative for others
            var next_prec: Precedence = op_prec
            if (op_prec != Precedence.PrecAssignment) {
                next_prec = intToPrec(precToInt(op_prec) + 1)
            }
            var right: *Expr = self.parseExprPrec(next_prec)

            // Build binary expression
            left = makeBinaryExpr(op_token.token_type, left, right, loc)
        }

        return left
    }

    // Parse a function call expression: callee(arg1, arg2, ...)
    fn parseCallExpr(self: *Parser, callee: *Expr, loc: SourceLoc) *Expr {
        // Consume the '('
        self.advance()

        // Parse arguments into a list
        var args = new List<*Expr>
        while (!self.check(TokenType.RightParen) and !self.isAtEnd()) {
            if (args.len() > 0) {
                self.consume(TokenType.Comma, "Expected ',' between arguments")
            }
            var arg: *Expr = self.parseExpr()
            args.push(arg)
        }

        self.consume(TokenType.RightParen, "Expected ')' after arguments")

        return makeCallExpr(callee, args.to_slice(), loc)
    }

    // Parse a field access expression: object.field_name or object.*
    fn parseFieldExpr(self: *Parser, object: *Expr, loc: SourceLoc) *Expr {
        // Consume the '.'
        self.advance()

        // Check for dereference: expr.*
        if (self.check(TokenType.Star)) {
            self.advance()
            return makeDerefExpr(object, loc)
        }

        // Expect field name
        if (!self.check(TokenType.Identifier)) {
            self.errorAtCurrent("Expected field name after '.'")
            return makeNullExpr(loc)
        }

        var field_name: string = self.current.lexeme
        self.advance()

        return makeFieldExpr(object, field_name, loc)
    }

    // Parse an index expression: object[index]
    fn parseIndexExpr(self: *Parser, object: *Expr, loc: SourceLoc) *Expr {
        // Consume the '['
        self.advance()

        // Parse index expression
        var index: *Expr = self.parseExpr()

        // Check for slice expression: object[start..end]
        if (self.check(TokenType.Range) or self.check(TokenType.RangeInclusive)) {
            var inclusive: bool = self.check(TokenType.RangeInclusive)
            self.advance()
            var end: *Expr = self.parseExpr()
            self.consume(TokenType.RightBracket, "Expected ']' after slice")
            return makeSliceExpr(object, index, end, inclusive, loc)
        }

        self.consume(TokenType.RightBracket, "Expected ']' after index")

        return makeIndexExpr(object, index, loc)
    }

    // Parse optional field access: object?.field
    fn parseOptionalFieldExpr(self: *Parser, object: *Expr, loc: SourceLoc) *Expr {
        // Consume the '?.'
        self.advance()

        // Expect field name
        if (!self.check(TokenType.Identifier)) {
            self.errorAtCurrent("Expected field name after '?.'")
            return makeNullExpr(loc)
        }

        var field_name: string = self.current.lexeme
        self.advance()

        return makeOptionalFieldExpr(object, field_name, loc)
    }

    // Parse optional index access: object?[index]
    fn parseOptionalIndexExpr(self: *Parser, object: *Expr, loc: SourceLoc) *Expr {
        // Consume the '?['
        self.advance()

        // Parse index expression
        var index: *Expr = self.parseExpr()

        self.consume(TokenType.RightBracket, "Expected ']' after index")

        return makeOptionalIndexExpr(object, index, loc)
    }

    // Parse struct initialization: Type{ .field = val, ... }
    fn parseStructInit(self: *Parser, type_name: string, loc: SourceLoc) *Expr {
        // Consume the '{'
        self.advance()

        var field_inits = new List<FieldInit>
        while (!self.check(TokenType.RightBrace) and !self.isAtEnd()) {
            if (field_inits.len() > 0) {
                self.consume(TokenType.Comma, "Expected ',' between field initializers")
            }

            // Expect .field = value
            self.consume(TokenType.Dot, "Expected '.' before field name")

            if (!self.check(TokenType.Identifier)) {
                self.errorAtCurrent("Expected field name")
                break
            }
            var field_name: string = self.current.lexeme
            var field_loc: SourceLoc = SourceLoc.fromToken(self.current)
            self.advance()

            self.consume(TokenType.Equals, "Expected '=' after field name")

            var value: *Expr = self.parseExpr()
            field_inits.push(FieldInit{
                .name = field_name,
                .value = value,
                .loc = field_loc,
            })
        }

        self.consume(TokenType.RightBrace, "Expected '}' after struct initializer")

        // Create a simple named type ref for the struct type
        var type_ref: *TypeRef = makeNamedTypeRef(type_name, loc)
        return makeStructInitExpr(type_ref, field_inits.to_slice(), loc)
    }

    // Parse array initialization: [expr, expr, ...]
    fn parseArrayInit(self: *Parser, loc: SourceLoc) *Expr {
        // Consume the '['
        self.advance()

        var elements = new List<*Expr>
        while (!self.check(TokenType.RightBracket) and !self.isAtEnd()) {
            if (elements.len() > 0) {
                self.consume(TokenType.Comma, "Expected ',' between array elements")
            }

            var elem: *Expr = self.parseExpr()
            elements.push(elem)
        }

        self.consume(TokenType.RightBracket, "Expected ']' after array elements")

        return makeArrayInitExpr(elements.to_slice(), loc)
    }

    // Parse lambda expression: |params| body or |params| { stmts }
    fn parseLambdaExpr(self: *Parser, loc: SourceLoc) *Expr {
        // Consume the opening '|'
        self.advance()

        // Parse parameters
        var params = new List<Param>
        while (!self.check(TokenType.Pipe) and !self.isAtEnd()) {
            if (params.len() > 0) {
                self.consume(TokenType.Comma, "Expected ',' between lambda parameters")
            }

            // Parameter name
            if (!self.check(TokenType.Identifier)) {
                self.errorAtCurrent("Expected parameter name")
                break
            }
            var param_name: string = self.current.lexeme
            var param_loc: SourceLoc = SourceLoc.fromToken(self.current)
            self.advance()

            // Optional type annotation
            var param_type: ?*TypeRef = null
            if (self.match(TokenType.Colon)) {
                param_type = self.parseType()
            }

            params.push(Param{
                .name = param_name,
                .param_type = param_type,
                .loc = param_loc,
            })
        }

        self.consume(TokenType.Pipe, "Expected '|' after lambda parameters")

        // Parse body - either a block or a single expression
        var body: *Expr = makeNullExpr(loc)  // Default if parsing fails
        if (self.check(TokenType.LeftBrace)) {
            // Block body - wrap it in a block expression
            var block_stmt: *Stmt = self.parseBlock()
            // For lambda with block body, we use a block expression
            body = makeBlockExpr(block_stmt, loc)
        } else {
            body = self.parseExpr()
        }

        return makeLambdaExpr(params.to_slice(), body, loc)
    }

    // Parse an interpolated string: "Hello ${name}!"
    // Token stream: StringInterpStart, (StringContent | InterpExprStart expr InterpExprEnd)*, StringInterpEnd
    fn parseInterpString(self: *Parser, loc: SourceLoc) *Expr {
        // Consume the opening quote (StringInterpStart)
        self.advance()

        var elements = new List<*Expr>

        // Parse parts until we hit the closing quote
        while (!self.check(TokenType.StringInterpEnd) and !self.isAtEnd()) {
            if (self.check(TokenType.StringContent)) {
                // Literal string part - create a string expression
                var content: string = self.current.lexeme
                var content_loc: SourceLoc = SourceLoc.fromToken(self.current)
                self.advance()
                elements.push(makeStrExpr(content, content_loc))
            } else if (self.check(TokenType.InterpExprStart)) {
                // Expression part: parse until InterpExprEnd
                self.advance()  // consume ${
                var expr: *Expr = self.parseExpr()
                self.consume(TokenType.InterpExprEnd, "Expected '}' after interpolation expression")
                elements.push(expr)
            } else {
                self.errorAtCurrent("Expected string content or interpolation expression")
                break
            }
        }

        self.consume(TokenType.StringInterpEnd, "Expected closing '\"' for interpolated string")

        return makeInterpStringExpr(elements.to_slice(), loc)
    }
}

// Convert precedence enum to integer for comparison
fn precToInt(p: Precedence) i64 {
    switch (p) {
        Precedence.PrecNone => { return 0 }
        Precedence.PrecAssignment => { return 1 }
        Precedence.PrecRange => { return 2 }
        Precedence.PrecNullCoalesce => { return 3 }
        Precedence.PrecOr => { return 4 }
        Precedence.PrecAnd => { return 5 }
        Precedence.PrecBitOr => { return 6 }
        Precedence.PrecBitXor => { return 7 }
        Precedence.PrecBitAnd => { return 8 }
        Precedence.PrecEquality => { return 9 }
        Precedence.PrecComparison => { return 10 }
        Precedence.PrecCast => { return 11 }
        Precedence.PrecShift => { return 12 }
        Precedence.PrecTerm => { return 13 }
        Precedence.PrecFactor => { return 14 }
        Precedence.PrecUnary => { return 15 }
        Precedence.PrecCall => { return 16 }
        Precedence.PrecPrimary => { return 17 }
    }
    return 0
}

// Convert integer back to precedence
fn intToPrec(i: i64) Precedence {
    switch (i) {
        0 => { return Precedence.PrecNone }
        1 => { return Precedence.PrecAssignment }
        2 => { return Precedence.PrecRange }
        3 => { return Precedence.PrecNullCoalesce }
        4 => { return Precedence.PrecOr }
        5 => { return Precedence.PrecAnd }
        6 => { return Precedence.PrecBitOr }
        7 => { return Precedence.PrecBitXor }
        8 => { return Precedence.PrecBitAnd }
        9 => { return Precedence.PrecEquality }
        10 => { return Precedence.PrecComparison }
        11 => { return Precedence.PrecCast }
        12 => { return Precedence.PrecShift }
        13 => { return Precedence.PrecTerm }
        14 => { return Precedence.PrecFactor }
        15 => { return Precedence.PrecUnary }
        16 => { return Precedence.PrecCall }
    }
    return Precedence.PrecPrimary
}

// =============================================================================
// Expression Constructors
// =============================================================================

// Helper to create an Expr with all default/null values
fn makeDefaultExpr(kind: ExprKind, loc: SourceLoc) *Expr {
    var empty_exprs: []*Expr = []
    var empty_stmts: []*Stmt = []
    var empty_field_inits: []FieldInit = []
    var empty_params: []Param = []

    return new Expr{
        .kind = kind,
        .loc = loc,
        .int_value = 0,
        .dec_value = "",
        .str_value = "",
        .bool_value = false,
        .name = "",
        .op = TokenType.Invalid,
        .left = null,
        .right = null,
        .operand = null,
        .callee = null,
        .args = empty_exprs,
        .object = null,
        .field_name = "",
        .index = null,
        .struct_type = null,
        .field_inits = empty_field_inits,
        .elements = empty_exprs,
        .condition = null,
        .then_branch = null,
        .else_branch = null,
        .stmts = empty_stmts,
        .result = null,
        .params = empty_params,
        .body = null,
        .range_start = null,
        .range_end = null,
        .range_inclusive = false,
        .cast_type = null,
        .slice_start = null,
        .slice_end = null,
    }
}

fn makeIntExpr(value: i64, loc: SourceLoc) *Expr {
    var e = makeDefaultExpr(ExprKind.IntLiteral, loc)
    e.int_value = value
    return e
}

fn makeDecExpr(value: string, loc: SourceLoc) *Expr {
    var e = makeDefaultExpr(ExprKind.DecLiteral, loc)
    e.dec_value = value
    return e
}

fn makeStrExpr(value: string, loc: SourceLoc) *Expr {
    var e = makeDefaultExpr(ExprKind.StrLiteral, loc)
    e.str_value = value
    return e
}

// Process a string literal: strip quotes and handle escape sequences
fn processStringLiteral(lexeme: string) string {
    // Strip quotes if present
    var str = lexeme
    if (len(str) >= 2) {
        str = str[1..len(str) - 1]
    }

    // Check if there are any backslashes (quick path)
    var has_escape = false
    var i: i64 = 0
    while (i < len(str)) {
        if (str[i..i + 1] == "\\") {
            has_escape = true
            break
        }
        i += 1
    }

    if (!has_escape) {
        return str
    }

    // Process escape sequences
    var result = ""
    var j: i64 = 0
    while (j < len(str)) {
        if (str[j..j + 1] == "\\" and j + 1 < len(str)) {
            var next = str[j + 1..j + 2]
            if (next == "n") {
                result = result + char(10)  // newline
            } else if (next == "t") {
                result = result + char(9)   // tab
            } else if (next == "r") {
                result = result + char(13)  // carriage return
            } else if (next == "\\") {
                result = result + "\\"
            } else if (next == char(34)) {  // double quote
                result = result + char(34)
            } else if (next == "0") {
                result = result + char(0)   // null
            } else {
                // Unknown escape, keep as-is
                result = result + next
            }
            j += 2
        } else {
            result = result + str[j..j + 1]
            j += 1
        }
    }

    return result
}

fn makeBoolExpr(value: bool, loc: SourceLoc) *Expr {
    var e = makeDefaultExpr(ExprKind.BoolLiteral, loc)
    e.bool_value = value
    return e
}

fn makeNullExpr(loc: SourceLoc) *Expr {
    return makeDefaultExpr(ExprKind.NullLiteral, loc)
}

fn makeIdentExpr(name: string, loc: SourceLoc) *Expr {
    var e = makeDefaultExpr(ExprKind.IdentifierExpr, loc)
    e.name = name
    return e
}

fn makeUnaryExpr(op: TokenType, operand: *Expr, loc: SourceLoc) *Expr {
    var e = makeDefaultExpr(ExprKind.UnaryExpr, loc)
    e.op = op
    e.operand = operand
    return e
}

fn makeBinaryExpr(op: TokenType, left: *Expr, right: *Expr, loc: SourceLoc) *Expr {
    var e = makeDefaultExpr(ExprKind.BinaryExpr, loc)
    e.op = op
    e.left = left
    e.right = right
    return e
}

fn makeCallExpr(callee: *Expr, args: []*Expr, loc: SourceLoc) *Expr {
    var e = makeDefaultExpr(ExprKind.CallExpr, loc)
    e.callee = callee
    e.args = args
    return e
}

fn makeFieldExpr(object: *Expr, field_name: string, loc: SourceLoc) *Expr {
    var e = makeDefaultExpr(ExprKind.FieldExpr, loc)
    e.field_name = field_name
    e.object = object
    return e
}

fn makeIndexExpr(object: *Expr, index: *Expr, loc: SourceLoc) *Expr {
    var e = makeDefaultExpr(ExprKind.IndexExpr, loc)
    e.object = object
    e.index = index
    return e
}

fn makeDerefExpr(operand: *Expr, loc: SourceLoc) *Expr {
    var e = makeDefaultExpr(ExprKind.UnaryExpr, loc)
    e.op = TokenType.Star  // .* dereference uses Star token
    e.operand = operand
    return e
}

fn makeSliceExpr(object: *Expr, start: *Expr, end: *Expr, inclusive: bool, loc: SourceLoc) *Expr {
    var e = makeDefaultExpr(ExprKind.SliceExpr, loc)
    e.range_inclusive = inclusive
    e.object = object
    e.slice_start = start
    e.slice_end = end
    return e
}

fn makeOptionalFieldExpr(object: *Expr, field_name: string, loc: SourceLoc) *Expr {
    var e = makeDefaultExpr(ExprKind.FieldExpr, loc)
    e.field_name = field_name
    e.bool_value = true  // Flag to indicate optional access
    e.object = object
    return e
}

fn makeOptionalIndexExpr(object: *Expr, index: *Expr, loc: SourceLoc) *Expr {
    var e = makeDefaultExpr(ExprKind.IndexExpr, loc)
    e.bool_value = true  // Flag to indicate optional access
    e.object = object
    e.index = index
    return e
}

fn makeRangeExpr(start: ?*Expr, end: ?*Expr, inclusive: bool, loc: SourceLoc) *Expr {
    var e = makeDefaultExpr(ExprKind.RangeExpr, loc)
    e.range_inclusive = inclusive
    e.range_start = start
    e.range_end = end
    return e
}

fn makeCastExpr(expr: *Expr, target_type: *TypeRef, loc: SourceLoc) *Expr {
    var e = makeDefaultExpr(ExprKind.CastExpr, loc)
    e.operand = expr
    e.cast_type = target_type
    return e
}

fn makeTypeCheckExpr(expr: *Expr, check_type: *TypeRef, loc: SourceLoc) *Expr {
    // Use a binary expr with KwIs as the operator
    var e = makeDefaultExpr(ExprKind.BinaryExpr, loc)
    e.op = TokenType.KwIs
    e.left = expr
    e.cast_type = check_type  // Store the type in cast_type field
    return e
}

fn makeStructInitExpr(type_ref: *TypeRef, field_inits: []FieldInit, loc: SourceLoc) *Expr {
    var e = makeDefaultExpr(ExprKind.StructInitExpr, loc)
    e.struct_type = type_ref
    e.field_inits = field_inits
    return e
}

fn makeArrayInitExpr(elements: []*Expr, loc: SourceLoc) *Expr {
    var e = makeDefaultExpr(ExprKind.ArrayInitExpr, loc)
    e.elements = elements
    return e
}

fn makeLambdaExpr(params: []Param, body: *Expr, loc: SourceLoc) *Expr {
    var e = makeDefaultExpr(ExprKind.LambdaExpr, loc)
    e.params = params
    e.body = body
    return e
}

fn makeBlockExpr(block_stmt: *Stmt, loc: SourceLoc) *Expr {
    var e = makeDefaultExpr(ExprKind.BlockExpr, loc)
    e.stmts = block_stmt.block_stmts
    return e
}

// =============================================================================
// TypeRef Constructors
// =============================================================================

fn makeDefaultTypeRef(kind: TypeKind, loc: SourceLoc) *TypeRef {
    var empty_types: []*TypeRef = []
    return new TypeRef{
        .kind = kind,
        .loc = loc,
        .name = "",
        .inner = null,
        .array_size = 0,
        .param_types = empty_types,
        .return_type = null,
        .type_args = empty_types,
    }
}

fn makeNamedTypeRef(name: string, loc: SourceLoc) *TypeRef {
    var t = makeDefaultTypeRef(TypeKind.Named, loc)
    t.name = name
    return t
}

fn makePointerTypeRef(inner: *TypeRef, loc: SourceLoc) *TypeRef {
    var t = makeDefaultTypeRef(TypeKind.Pointer, loc)
    t.inner = inner
    return t
}

fn makeOptionalTypeRef(inner: *TypeRef, loc: SourceLoc) *TypeRef {
    var t = makeDefaultTypeRef(TypeKind.Optional, loc)
    t.inner = inner
    return t
}

fn makeArrayTypeRef(inner: *TypeRef, size: i64, loc: SourceLoc) *TypeRef {
    var t = makeDefaultTypeRef(TypeKind.Array, loc)
    t.inner = inner
    t.array_size = size
    return t
}

fn makeSliceTypeRef(inner: *TypeRef, loc: SourceLoc) *TypeRef {
    var t = makeDefaultTypeRef(TypeKind.Slice, loc)
    t.inner = inner
    return t
}

fn makeFunctionTypeRef(param_types: []*TypeRef, return_type: ?*TypeRef, loc: SourceLoc) *TypeRef {
    var t = makeDefaultTypeRef(TypeKind.Function, loc)
    t.param_types = param_types
    t.return_type = return_type
    return t
}

fn makeGenericTypeRef(name: string, type_args: []*TypeRef, loc: SourceLoc) *TypeRef {
    var t = makeDefaultTypeRef(TypeKind.Generic, loc)
    t.name = name
    t.type_args = type_args
    return t
}

fn makeInferredTypeRef(loc: SourceLoc) *TypeRef {
    return makeDefaultTypeRef(TypeKind.Inferred, loc)
}

fn makeInterpStringExpr(elements: []*Expr, loc: SourceLoc) *Expr {
    // elements alternates between string literal exprs and interpolated exprs
    var e = makeDefaultExpr(ExprKind.InterpStringExpr, loc)
    e.elements = elements
    return e
}

// =============================================================================
// Statement Constructors
// =============================================================================

// Helper to create a Stmt with all default/null values
fn makeDefaultStmt(kind: StmtKind, loc: SourceLoc) *Stmt {
    var empty_stmts: []*Stmt = []
    var empty_fields: []Field = []
    var empty_variants: []EnumVariant = []
    var empty_params: []Param = []
    var empty_arms: []SwitchArm = []

    return new Stmt{
        .kind = kind,
        .loc = loc,
        .expr = null,
        .var_name = "",
        .var_type = null,
        .var_init = null,
        .var_mutable = false,
        .return_value = null,
        .if_cond = null,
        .if_then = null,
        .if_else = null,
        .while_cond = null,
        .while_body = null,
        .for_var = "",
        .for_iter = null,
        .for_body = null,
        .block_stmts = empty_stmts,
        .fn_name = "",
        .fn_params = empty_params,
        .fn_return_type = null,
        .fn_body = null,
        .fn_public = false,
        .struct_name = "",
        .struct_fields = empty_fields,
        .enum_name = "",
        .enum_variants = empty_variants,
        .impl_type = null,
        .impl_trait = null,
        .impl_methods = empty_stmts,
        .import_path = "",
        .switch_expr = null,
        .switch_arms = empty_arms,
        .alias_name = "",
        .alias_type = null,
        .loop_body = null,
        .union_name = "",
        .union_fields = empty_fields,
        .defer_expr = null,
        .try_body = null,
        .catch_body = null,
        .catch_var = "",
        .throw_expr = null,
        .test_name = "",
        .test_body = null,
        .view_name = "",
        .view_type = null,
        .view_base_field = "",
        .view_offset = 0,
        .trait_name = "",
        .trait_methods = empty_stmts,
        .comptime_body = null,
        .comptime_cond = null,
        .comptime_else = null,
    }
}

// =============================================================================
// Statement Parsing
// =============================================================================

impl Parser {
    // Parse a statement (main dispatch)
    fn parseStatement(self: *Parser) *Stmt {
        var loc: SourceLoc = SourceLoc.fromToken(self.current)

        // Dispatch based on leading keyword
        switch (self.current.token_type) {
            // Visibility modifier
            TokenType.KwPub => {
                return self.parsePubDecl()
            }

            // Declarations
            TokenType.KwFn => {
                return self.parseFunctionDecl()
            }
            TokenType.KwStruct => {
                return self.parseStructDecl()
            }
            TokenType.KwEnum => {
                return self.parseEnumDecl()
            }
            TokenType.KwImpl => {
                return self.parseImplDecl()
            }
            TokenType.KwImport => {
                return self.parseImportStmt()
            }

            // Variable declarations
            TokenType.KwVar => {
                return self.parseVarDecl()
            }
            TokenType.KwConst => {
                return self.parseConstDecl()
            }

            // Control flow
            TokenType.KwReturn => {
                return self.parseReturnStmt()
            }
            TokenType.KwIf => {
                return self.parseIfStmt()
            }
            TokenType.KwWhile => {
                return self.parseWhileStmt()
            }
            TokenType.KwFor => {
                return self.parseForStmt()
            }
            TokenType.KwSwitch => {
                return self.parseSwitchStmt()
            }
            TokenType.KwLoop => {
                return self.parseLoopStmt()
            }
            TokenType.KwDefer => {
                return self.parseDeferStmt()
            }
            TokenType.KwTry => {
                return self.parseTryStmt()
            }
            TokenType.KwThrow => {
                return self.parseThrowStmt()
            }
            TokenType.KwTest => {
                return self.parseTestDecl()
            }
            TokenType.KwUnion => {
                return self.parseUnionDecl()
            }
            TokenType.KwType => {
                return self.parseTypeAliasDecl()
            }
            TokenType.KwView => {
                return self.parseViewDecl()
            }
            TokenType.KwTrait => {
                return self.parseTraitDecl()
            }
            TokenType.KwComptime => {
                return self.parseComptimeStmt()
            }
            TokenType.KwBreak => {
                self.advance()
                return makeBreakStmt(loc)
            }
            TokenType.KwContinue => {
                self.advance()
                return makeContinueStmt(loc)
            }
            TokenType.LeftBrace => {
                return self.parseBlock()
            }
        }

        // Default: expression statement
        return self.parseExpressionStmt()
    }

    // Parse a pub declaration: pub fn/struct/enum/const/var
    fn parsePubDecl(self: *Parser) *Stmt {
        var loc: SourceLoc = SourceLoc.fromToken(self.current)
        self.consume(TokenType.KwPub, "Expected 'pub'")

        // Parse the actual declaration and mark it as public
        var stmt: *Stmt = self.parseStatement()
        stmt.fn_public = true  // Mark as public (reuse fn_public for all decls)
        return stmt
    }

    // Parse a variable declaration: var name: Type = expr
    fn parseVarDecl(self: *Parser) *Stmt {
        var loc: SourceLoc = SourceLoc.fromToken(self.current)
        self.consume(TokenType.KwVar, "Expected 'var'")

        // Get variable name
        if (!self.check(TokenType.Identifier)) {
            self.errorAtCurrent("Expected variable name")
            return makeExprStmt(makeNullExpr(loc), loc)
        }
        var name: string = self.current.lexeme
        self.advance()

        // Optional type annotation
        var var_type: ?*TypeRef = null
        if (self.match(TokenType.Colon)) {
            var_type = self.parseType()
        }

        // Optional initializer
        var var_init: ?*Expr = null
        if (self.match(TokenType.Equals)) {
            var_init = self.parseExpr()
        }

        return makeVarDeclStmt(name, true, var_type, var_init, loc)
    }

    // Parse a constant declaration: const name: Type = expr
    fn parseConstDecl(self: *Parser) *Stmt {
        var loc: SourceLoc = SourceLoc.fromToken(self.current)
        self.consume(TokenType.KwConst, "Expected 'const'")

        // Get constant name
        if (!self.check(TokenType.Identifier)) {
            self.errorAtCurrent("Expected constant name")
            return makeExprStmt(makeNullExpr(loc), loc)
        }
        var name: string = self.current.lexeme
        self.advance()

        // Optional type annotation
        var const_type: ?*TypeRef = null
        if (self.match(TokenType.Colon)) {
            const_type = self.parseType()
        }

        // Required initializer for const
        self.consume(TokenType.Equals, "Expected '=' after constant name")
        var init_expr: *Expr = self.parseExpr()

        return makeVarDeclStmt(name, false, const_type, init_expr, loc)
    }

    // Parse a return statement: return expr
    fn parseReturnStmt(self: *Parser) *Stmt {
        var loc: SourceLoc = SourceLoc.fromToken(self.current)
        self.consume(TokenType.KwReturn, "Expected 'return'")

        // Optional return value
        if (self.check(TokenType.RightBrace) or self.check(TokenType.Semicolon) or self.isAtEnd()) {
            return makeReturnStmt(null, loc)
        }

        var value: *Expr = self.parseExpr()
        return makeReturnStmt(value, loc)
    }

    // Parse an if statement: if (cond) { then } else { else }
    fn parseIfStmt(self: *Parser) *Stmt {
        var loc: SourceLoc = SourceLoc.fromToken(self.current)
        self.consume(TokenType.KwIf, "Expected 'if'")

        // Condition (parentheses required)
        self.consume(TokenType.LeftParen, "Expected '(' after 'if'")
        var cond: *Expr = self.parseExpr()
        self.consume(TokenType.RightParen, "Expected ')' after if condition")

        // Then branch
        var then_branch: *Stmt = self.parseBlock()

        // Optional else branch
        var else_branch: ?*Stmt = null
        if (self.match(TokenType.KwElse)) {
            // Check for else if
            if (self.check(TokenType.KwIf)) {
                else_branch = self.parseIfStmt()
            } else {
                else_branch = self.parseBlock()
            }
        }

        return makeIfStmt(cond, then_branch, else_branch, loc)
    }

    // Parse a while loop: while (cond) { body }
    fn parseWhileStmt(self: *Parser) *Stmt {
        var loc: SourceLoc = SourceLoc.fromToken(self.current)
        self.consume(TokenType.KwWhile, "Expected 'while'")

        // Condition (parentheses required)
        self.consume(TokenType.LeftParen, "Expected '(' after 'while'")
        var cond: *Expr = self.parseExpr()
        self.consume(TokenType.RightParen, "Expected ')' after while condition")

        // Body
        var body: *Stmt = self.parseBlock()

        return makeWhileStmt(cond, body, loc)
    }

    // Parse a for loop: for (item in iter) { body }
    fn parseForStmt(self: *Parser) *Stmt {
        var loc: SourceLoc = SourceLoc.fromToken(self.current)
        self.consume(TokenType.KwFor, "Expected 'for'")

        // Loop variable (parentheses optional but we'll require them for now)
        self.consume(TokenType.LeftParen, "Expected '(' after 'for'")

        if (!self.check(TokenType.Identifier)) {
            self.errorAtCurrent("Expected loop variable name")
            return makeExprStmt(makeNullExpr(loc), loc)
        }
        var var_name: string = self.current.lexeme
        self.advance()

        // 'in' keyword
        self.consume(TokenType.KwIn, "Expected 'in' after loop variable")

        // Iterator expression
        var iter: *Expr = self.parseExpr()

        self.consume(TokenType.RightParen, "Expected ')' after for clause")

        // Body
        var body: *Stmt = self.parseBlock()

        return makeForStmt(var_name, iter, body, loc)
    }

    // Parse a block: { statements... }
    fn parseBlock(self: *Parser) *Stmt {
        var loc: SourceLoc = SourceLoc.fromToken(self.current)
        self.consume(TokenType.LeftBrace, "Expected '{'")

        var stmts = new List<*Stmt>
        while (!self.check(TokenType.RightBrace) and !self.isAtEnd()) {
            var stmt: *Stmt = self.parseStatement()
            stmts.push(stmt)

            // Optional semicolon between statements
            self.match(TokenType.Semicolon)
        }

        self.consume(TokenType.RightBrace, "Expected '}' after block")

        return makeBlockStmt(stmts.to_slice(), loc)
    }

    // Parse a switch statement: switch (expr) { arms }
    fn parseSwitchStmt(self: *Parser) *Stmt {
        var loc: SourceLoc = SourceLoc.fromToken(self.current)
        self.consume(TokenType.KwSwitch, "Expected 'switch'")

        // Switch expression (parentheses required)
        self.consume(TokenType.LeftParen, "Expected '(' after 'switch'")
        var switch_expr: *Expr = self.parseExpr()
        self.consume(TokenType.RightParen, "Expected ')' after switch expression")

        // Arms
        self.consume(TokenType.LeftBrace, "Expected '{' before switch arms")

        var arms = new List<SwitchArm>
        while (!self.check(TokenType.RightBrace) and !self.isAtEnd()) {
            var arm_loc: SourceLoc = SourceLoc.fromToken(self.current)

            // Parse pattern
            var pattern: *Expr = self.parseExpr()

            // Arrow
            self.consume(TokenType.FatArrow, "Expected '=>' after pattern")

            // Body (either block or expression)
            var body: *Expr = makeNullExpr(arm_loc)
            if (self.check(TokenType.LeftBrace)) {
                var block_stmt: *Stmt = self.parseBlock()
                body = makeBlockExpr(block_stmt, arm_loc)
            } else {
                body = self.parseExpr()
            }

            // Extract binding names if pattern is a call-like form (e.g., Option.Some(val))
            var binding_names = new List<string>
            if (pattern.kind == ExprKind.CallExpr) {
                // The args of the call are the binding variables
                var i: i64 = 0
                while (i < pattern.args.len()) {
                    var arg: *Expr = pattern.args[i]
                    if (arg.kind == ExprKind.IdentifierExpr) {
                        binding_names.push(arg.name)
                    }
                    i = i + 1
                }
            }

            arms.push(SwitchArm{
                .pattern = pattern,
                .body = body,
                .is_default = false,
                .loc = arm_loc,
                .binding_names = binding_names.to_slice(),
            })

            // Optional comma between arms
            self.match(TokenType.Comma)
        }

        self.consume(TokenType.RightBrace, "Expected '}' after switch arms")

        return makeSwitchStmt(switch_expr, arms.to_slice(), loc)
    }

    // Parse a loop statement: loop { body }
    fn parseLoopStmt(self: *Parser) *Stmt {
        var loc: SourceLoc = SourceLoc.fromToken(self.current)
        self.consume(TokenType.KwLoop, "Expected 'loop'")

        // Body
        var body: *Stmt = self.parseBlock()

        return makeLoopStmt(body, loc)
    }

    // Parse a defer statement: defer expr
    fn parseDeferStmt(self: *Parser) *Stmt {
        var loc: SourceLoc = SourceLoc.fromToken(self.current)
        self.consume(TokenType.KwDefer, "Expected 'defer'")

        // Deferred expression (usually a function call or block)
        var expr: *Expr = makeNullExpr(loc)
        if (self.check(TokenType.LeftBrace)) {
            var block_stmt: *Stmt = self.parseBlock()
            expr = makeBlockExpr(block_stmt, loc)
        } else {
            expr = self.parseExpr()
        }

        return makeDeferStmt(expr, loc)
    }

    // Parse a try statement: try { body } catch (err) { handler }
    fn parseTryStmt(self: *Parser) *Stmt {
        var loc: SourceLoc = SourceLoc.fromToken(self.current)
        self.consume(TokenType.KwTry, "Expected 'try'")

        // Try body
        var try_body: *Stmt = self.parseBlock()

        // Catch clause
        var catch_var: string = ""
        var catch_body: *Stmt = makeBlockStmt([], loc)  // Empty block as default
        if (self.match(TokenType.KwCatch)) {
            // Optional error binding: catch (err)
            if (self.check(TokenType.LeftParen)) {
                self.advance()
                if (self.check(TokenType.Identifier)) {
                    catch_var = self.current.lexeme
                    self.advance()
                }
                self.consume(TokenType.RightParen, "Expected ')' after catch variable")
            }

            // Catch body
            catch_body = self.parseBlock()
        }

        return makeTryStmt(try_body, catch_var, catch_body, loc)
    }

    // Parse a throw statement: throw expr
    fn parseThrowStmt(self: *Parser) *Stmt {
        var loc: SourceLoc = SourceLoc.fromToken(self.current)
        self.consume(TokenType.KwThrow, "Expected 'throw'")

        // Thrown expression
        var expr: *Expr = self.parseExpr()

        return makeThrowStmt(expr, loc)
    }

    // Parse a test declaration: test "name" { body }
    fn parseTestDecl(self: *Parser) *Stmt {
        var loc: SourceLoc = SourceLoc.fromToken(self.current)
        self.consume(TokenType.KwTest, "Expected 'test'")

        // Test name (string literal)
        if (!self.check(TokenType.StringLiteral)) {
            self.errorAtCurrent("Expected test name string")
            return makeExprStmt(makeNullExpr(loc), loc)
        }
        var name: string = self.current.lexeme
        self.advance()

        // Test body
        var body: *Stmt = self.parseBlock()

        return makeTestDeclStmt(name, body, loc)
    }

    // Parse a union declaration: union Name { fields }
    fn parseUnionDecl(self: *Parser) *Stmt {
        var loc: SourceLoc = SourceLoc.fromToken(self.current)
        self.consume(TokenType.KwUnion, "Expected 'union'")

        // Union name
        if (!self.check(TokenType.Identifier)) {
            self.errorAtCurrent("Expected union name")
            return makeExprStmt(makeNullExpr(loc), loc)
        }
        var name: string = self.current.lexeme
        self.advance()

        // Fields
        self.consume(TokenType.LeftBrace, "Expected '{' after union name")

        var fields = new List<Field>
        while (!self.check(TokenType.RightBrace) and !self.isAtEnd()) {
            // Field name
            if (!self.check(TokenType.Identifier)) {
                self.errorAtCurrent("Expected field name")
                break
            }
            var field_name: string = self.current.lexeme
            var field_loc: SourceLoc = SourceLoc.fromToken(self.current)
            self.advance()

            // Field type
            self.consume(TokenType.Colon, "Expected ':' after field name")
            var field_type: *TypeRef = self.parseType()

            fields.push(Field{
                .name = field_name,
                .field_type = field_type,
                .loc = field_loc,
            })

            // Optional comma between fields
            self.match(TokenType.Comma)
        }

        self.consume(TokenType.RightBrace, "Expected '}' after union fields")

        return makeUnionDeclStmt(name, fields.to_slice(), loc)
    }

    // Parse a type alias: type Name = Type
    fn parseTypeAliasDecl(self: *Parser) *Stmt {
        var loc: SourceLoc = SourceLoc.fromToken(self.current)
        self.consume(TokenType.KwType, "Expected 'type'")

        // Alias name
        if (!self.check(TokenType.Identifier)) {
            self.errorAtCurrent("Expected type alias name")
            return makeExprStmt(makeNullExpr(loc), loc)
        }
        var name: string = self.current.lexeme
        self.advance()

        // Equals and aliased type
        self.consume(TokenType.Equals, "Expected '=' after type name")
        var aliased_type: *TypeRef = self.parseType()

        return makeTypeAliasDeclStmt(name, aliased_type, loc)
    }

    // Parse a view declaration: view name: Type = @base_field or view name: Type = @base_field + offset
    fn parseViewDecl(self: *Parser) *Stmt {
        var loc: SourceLoc = SourceLoc.fromToken(self.current)
        self.consume(TokenType.KwView, "Expected 'view'")

        // View name
        if (!self.check(TokenType.Identifier)) {
            self.errorAtCurrent("Expected view name")
            return makeExprStmt(makeNullExpr(loc), loc)
        }
        var name: string = self.current.lexeme
        self.advance()

        // Type annotation is required
        self.consume(TokenType.Colon, "Expected ':'")
        var view_type: *TypeRef = self.parseType()

        self.consume(TokenType.Equals, "Expected '='")

        // Expect @ followed by base field name
        self.consume(TokenType.At, "Expected '@' before base field name")

        if (!self.check(TokenType.Identifier)) {
            self.errorAtCurrent("Expected base field name")
            return makeExprStmt(makeNullExpr(loc), loc)
        }
        var base_field: string = self.current.lexeme
        self.advance()

        // Parse optional offset: + or - followed by number
        var offset: i64 = 0
        if (self.match(TokenType.Plus)) {
            if (self.check(TokenType.IntegerLiteral)) {
                offset = parseInt(self.current.lexeme)
                self.advance()
            } else {
                self.errorAtCurrent("Expected offset value")
            }
        } else if (self.match(TokenType.Minus)) {
            if (self.check(TokenType.IntegerLiteral)) {
                offset = 0 - parseInt(self.current.lexeme)
                self.advance()
            } else {
                self.errorAtCurrent("Expected offset value")
            }
        }

        return makeViewDeclStmt(name, view_type, base_field, offset, loc)
    }

    // Parse a trait declaration: trait Name { fn method(self: Self) RetType; ... }
    fn parseTraitDecl(self: *Parser) *Stmt {
        var loc: SourceLoc = SourceLoc.fromToken(self.current)
        self.consume(TokenType.KwTrait, "Expected 'trait'")

        // Trait name
        if (!self.check(TokenType.Identifier)) {
            self.errorAtCurrent("Expected trait name")
            return makeExprStmt(makeNullExpr(loc), loc)
        }
        var name: string = self.current.lexeme
        self.advance()

        self.consume(TokenType.LeftBrace, "Expected '{'")

        // Parse method signatures (simplified - collect methods as function declarations without bodies)
        var methods = new List<*Stmt>
        while (!self.check(TokenType.RightBrace) and !self.isAtEnd()) {
            // Each method starts with 'fn'
            if (!self.check(TokenType.KwFn)) {
                self.errorAtCurrent("Expected 'fn' for trait method")
                break
            }
            var method_loc: SourceLoc = SourceLoc.fromToken(self.current)
            self.advance()  // consume 'fn'

            // Method name
            if (!self.check(TokenType.Identifier)) {
                self.errorAtCurrent("Expected method name")
                break
            }
            var method_name: string = self.current.lexeme
            self.advance()  // consume method name

            // Parameters
            self.consume(TokenType.LeftParen, "Expected '('")
            var params = new List<Param>
            while (!self.check(TokenType.RightParen) and !self.isAtEnd()) {
                if (params.len() > 0) {
                    self.consume(TokenType.Comma, "Expected ','")
                }
                if (self.check(TokenType.Identifier)) {
                    var param_name: string = self.current.lexeme
                    var param_loc: SourceLoc = SourceLoc.fromToken(self.current)
                    self.advance()
                    var param_type: ?*TypeRef = null
                    if (self.match(TokenType.Colon)) {
                        param_type = self.parseType()
                    }
                    params.push(Param{
                        .name = param_name,
                        .param_type = param_type,
                        .loc = param_loc,
                    })
                } else {
                    break
                }
            }
            self.consume(TokenType.RightParen, "Expected ')'")

            // Optional return type
            var return_type: ?*TypeRef = null
            if (!self.check(TokenType.Semicolon) and !self.check(TokenType.RightBrace)) {
                return_type = self.parseType()
            }

            // Create method declaration (no body for trait methods)
            methods.push(makeFunctionDeclStmt(method_name, params.to_slice(), return_type, null, method_loc))

            // Optional semicolon
            self.match(TokenType.Semicolon)
        }

        self.consume(TokenType.RightBrace, "Expected '}'")

        return makeTraitDeclStmt(name, methods.to_slice(), loc)
    }

    // Parse a comptime statement: comptime { } or comptime if { }
    fn parseComptimeStmt(self: *Parser) *Stmt {
        var loc: SourceLoc = SourceLoc.fromToken(self.current)
        self.consume(TokenType.KwComptime, "Expected 'comptime'")

        // Check for comptime if
        if (self.check(TokenType.KwIf)) {
            return self.parseComptimeIf(loc)
        }

        // Comptime block
        self.consume(TokenType.LeftBrace, "Expected '{'")
        var body: *Stmt = self.parseBlock()

        return makeComptimeStmt(body, null, null, loc)
    }

    // Parse comptime if: comptime if (cond) { } else { }
    fn parseComptimeIf(self: *Parser, loc: SourceLoc) *Stmt {
        self.consume(TokenType.KwIf, "Expected 'if'")
        self.consume(TokenType.LeftParen, "Expected '('")
        var cond: *Expr = self.parseExpr()
        self.consume(TokenType.RightParen, "Expected ')'")

        self.consume(TokenType.LeftBrace, "Expected '{'")
        var then_body: *Stmt = self.parseBlock()

        // Optional else
        var else_body: ?*Stmt = null
        if (self.match(TokenType.KwElse)) {
            if (self.check(TokenType.KwIf)) {
                else_body = self.parseComptimeIf(SourceLoc.fromToken(self.current))
            } else {
                self.consume(TokenType.LeftBrace, "Expected '{'")
                else_body = self.parseBlock()
            }
        }

        return makeComptimeStmt(then_body, cond, else_body, loc)
    }
}

// Helper to create comptime statement
fn makeComptimeStmt(body: ?*Stmt, cond: ?*Expr, else_branch: ?*Stmt, loc: SourceLoc) *Stmt {
    var s = makeDefaultStmt(StmtKind.ComptimeStmt, loc)
    s.comptime_body = body
    s.comptime_cond = cond
    s.comptime_else = else_branch
    return s
}

// Helper to create trait declaration statement
fn makeTraitDeclStmt(name: string, methods: []*Stmt, loc: SourceLoc) *Stmt {
    var s = makeDefaultStmt(StmtKind.TraitDecl, loc)
    s.trait_name = name
    s.trait_methods = methods
    return s
}

// =============================================================================
// Type Parsing
// =============================================================================

impl Parser {
    // Parse a type reference: T, *T, ?T, [N]T, []T
    fn parseType(self: *Parser) *TypeRef {
        var loc: SourceLoc = SourceLoc.fromToken(self.current)

        // Pointer type: *T
        if (self.check(TokenType.Star)) {
            self.advance()
            var inner: *TypeRef = self.parseType()
            return makePointerTypeRef(inner, loc)
        }

        // Optional type: ?T
        if (self.check(TokenType.Question)) {
            self.advance()
            var inner: *TypeRef = self.parseType()
            return makeOptionalTypeRef(inner, loc)
        }

        // Array or slice type: [N]T or []T
        if (self.check(TokenType.LeftBracket)) {
            self.advance()

            // Check if it's a slice (empty brackets) or array (size specified)
            if (self.check(TokenType.RightBracket)) {
                // Slice type: []T
                self.advance()
                var elem: *TypeRef = self.parseType()
                return makeSliceTypeRef(elem, loc)
            } else {
                // Array type: [N]T
                var size: i64 = 0
                if (self.check(TokenType.IntegerLiteral)) {
                    size = parseInt(self.current.lexeme)
                    self.advance()
                } else {
                    self.errorAtCurrent("Expected array size")
                }
                self.consume(TokenType.RightBracket, "Expected ']' after array size")
                var elem: *TypeRef = self.parseType()
                return makeArrayTypeRef(elem, size, loc)
            }
        }

        // Named type: identifier
        if (self.check(TokenType.Identifier)) {
            var name: string = self.current.lexeme
            self.advance()

            // Check for generic type arguments: Type[T, U]
            if (self.check(TokenType.LeftBracket)) {
                self.advance()
                var type_args = new List<*TypeRef>
                while (!self.check(TokenType.RightBracket) and !self.isAtEnd()) {
                    if (type_args.len() > 0) {
                        self.consume(TokenType.Comma, "Expected ',' between type arguments")
                    }
                    var type_arg: *TypeRef = self.parseType()
                    type_args.push(type_arg)
                }
                self.consume(TokenType.RightBracket, "Expected ']' after type arguments")
                return makeGenericTypeRef(name, type_args.to_slice(), loc)
            }

            return makeNamedTypeRef(name, loc)
        }

        // Function type: fn(A, B) RetType
        if (self.check(TokenType.KwFn)) {
            self.advance()
            self.consume(TokenType.LeftParen, "Expected '(' after 'fn' in type")

            var param_types = new List<*TypeRef>
            while (!self.check(TokenType.RightParen) and !self.isAtEnd()) {
                if (param_types.len() > 0) {
                    self.consume(TokenType.Comma, "Expected ',' between parameter types")
                }
                var param_type: *TypeRef = self.parseType()
                param_types.push(param_type)
            }
            self.consume(TokenType.RightParen, "Expected ')' after parameter types")

            // Return type (optional, defaults to void)
            var return_type: ?*TypeRef = null
            if (!self.check(TokenType.LeftBrace) and !self.check(TokenType.Semicolon) and !self.isAtEnd()) {
                return_type = self.parseType()
            }

            return makeFunctionTypeRef(param_types.to_slice(), return_type, loc)
        }

        self.errorAtCurrent("Expected type")
        return makeNamedTypeRef("void", loc)
    }

    // =========================================================================
    // Declaration Parsing
    // =========================================================================

    // Parse a function declaration: fn name(params) ReturnType { body }
    fn parseFunctionDecl(self: *Parser) *Stmt {
        var loc: SourceLoc = SourceLoc.fromToken(self.current)
        self.consume(TokenType.KwFn, "Expected 'fn'")

        // Function name
        if (!self.check(TokenType.Identifier)) {
            self.errorAtCurrent("Expected function name")
            return makeExprStmt(makeNullExpr(loc), loc)
        }
        var name: string = self.current.lexeme
        self.advance()

        // Parameters
        self.consume(TokenType.LeftParen, "Expected '(' after function name")

        var params = new List<Param>
        while (!self.check(TokenType.RightParen) and !self.isAtEnd()) {
            if (params.len() > 0) {
                self.consume(TokenType.Comma, "Expected ',' between parameters")
            }

            // Parameter name
            if (!self.check(TokenType.Identifier)) {
                self.errorAtCurrent("Expected parameter name")
                break
            }
            var param_name: string = self.current.lexeme
            var param_loc: SourceLoc = SourceLoc.fromToken(self.current)
            self.advance()

            // Parameter type
            self.consume(TokenType.Colon, "Expected ':' after parameter name")
            var param_type: *TypeRef = self.parseType()

            params.push(Param{
                .name = param_name,
                .param_type = param_type,
                .loc = param_loc,
            })
        }

        self.consume(TokenType.RightParen, "Expected ')' after parameters")

        // Optional return type (anything except { starts the body)
        var return_type: ?*TypeRef = null
        if (!self.check(TokenType.LeftBrace)) {
            return_type = self.parseType()
        }

        // Function body
        var body: *Stmt = self.parseBlock()

        return makeFunctionDeclStmt(name, params.to_slice(), return_type, body, loc)
    }

    // Parse a struct declaration: struct Name { fields }
    fn parseStructDecl(self: *Parser) *Stmt {
        var loc: SourceLoc = SourceLoc.fromToken(self.current)
        self.consume(TokenType.KwStruct, "Expected 'struct'")

        // Struct name
        if (!self.check(TokenType.Identifier)) {
            self.errorAtCurrent("Expected struct name")
            return makeExprStmt(makeNullExpr(loc), loc)
        }
        var name: string = self.current.lexeme
        self.advance()

        // Fields
        self.consume(TokenType.LeftBrace, "Expected '{' after struct name")

        var fields = new List<Field>
        while (!self.check(TokenType.RightBrace) and !self.isAtEnd()) {
            // Field name
            if (!self.check(TokenType.Identifier)) {
                self.errorAtCurrent("Expected field name")
                break
            }
            var field_name: string = self.current.lexeme
            var field_loc: SourceLoc = SourceLoc.fromToken(self.current)
            self.advance()

            // Field type
            self.consume(TokenType.Colon, "Expected ':' after field name")
            var field_type: *TypeRef = self.parseType()

            fields.push(Field{
                .name = field_name,
                .field_type = field_type,
                .loc = field_loc,
            })

            // Optional comma between fields
            self.match(TokenType.Comma)
        }

        self.consume(TokenType.RightBrace, "Expected '}' after struct fields")

        return makeStructDeclStmt(name, fields.to_slice(), loc)
    }

    // Parse an enum declaration: enum Name { variants }
    fn parseEnumDecl(self: *Parser) *Stmt {
        var loc: SourceLoc = SourceLoc.fromToken(self.current)
        self.consume(TokenType.KwEnum, "Expected 'enum'")

        // Enum name
        if (!self.check(TokenType.Identifier)) {
            self.errorAtCurrent("Expected enum name")
            return makeExprStmt(makeNullExpr(loc), loc)
        }
        var name: string = self.current.lexeme
        self.advance()

        // Variants
        self.consume(TokenType.LeftBrace, "Expected '{' after enum name")

        var variants = new List<EnumVariant>
        while (!self.check(TokenType.RightBrace) and !self.isAtEnd()) {
            // Variant name
            if (!self.check(TokenType.Identifier)) {
                self.errorAtCurrent("Expected variant name")
                break
            }
            var variant_name: string = self.current.lexeme
            var variant_loc: SourceLoc = SourceLoc.fromToken(self.current)
            self.advance()

            // Check for payload types
            var payload_types = new List<*TypeRef>
            var payload_fields = new List<Field>
            var has_payload: bool = false

            if (self.match(TokenType.LeftParen)) {
                // Tuple payload: Variant(Type1, Type2, ...)
                has_payload = true
                while (!self.check(TokenType.RightParen) and !self.isAtEnd()) {
                    var ptype: *TypeRef = self.parseType()
                    payload_types.push(ptype)
                    if (!self.match(TokenType.Comma)) {
                        break
                    }
                }
                self.consume(TokenType.RightParen, "Expected ')' after payload types")
            } else if (self.check(TokenType.LeftBrace)) {
                // Could be struct payload: Variant { field: Type, ... }
                // But only if not followed by variant body (we need lookahead)
                // For now, parse struct-style payload
                self.advance()  // consume '{'
                has_payload = true
                while (!self.check(TokenType.RightBrace) and !self.isAtEnd()) {
                    // Field name
                    if (!self.check(TokenType.Identifier)) {
                        self.errorAtCurrent("Expected field name")
                        break
                    }
                    var field_name: string = self.current.lexeme
                    var field_loc: SourceLoc = SourceLoc.fromToken(self.current)
                    self.advance()

                    // Colon and type
                    self.consume(TokenType.Colon, "Expected ':' after field name")
                    var field_type: *TypeRef = self.parseType()

                    payload_fields.push(Field{
                        .name = field_name,
                        .field_type = field_type,
                        .loc = field_loc,
                    })

                    if (!self.match(TokenType.Comma)) {
                        break
                    }
                }
                self.consume(TokenType.RightBrace, "Expected '}' after payload fields")
            }

            // Optional explicit value (only for simple enums without payload)
            var variant_value: ?*Expr = null
            if (self.match(TokenType.Equals)) {
                variant_value = self.parseExpr()
            }

            variants.push(EnumVariant{
                .name = variant_name,
                .value = variant_value,
                .loc = variant_loc,
                .payload_types = payload_types.to_slice(),
                .payload_fields = payload_fields.to_slice(),
                .has_payload = has_payload,
            })

            // Optional comma between variants
            self.match(TokenType.Comma)
        }

        self.consume(TokenType.RightBrace, "Expected '}' after enum variants")

        return makeEnumDeclStmt(name, variants.to_slice(), loc)
    }

    // Parse an impl block: impl Type { methods }
    fn parseImplDecl(self: *Parser) *Stmt {
        var loc: SourceLoc = SourceLoc.fromToken(self.current)
        self.consume(TokenType.KwImpl, "Expected 'impl'")

        // Type name
        var impl_type: *TypeRef = self.parseType()

        // Check for trait implementation: impl Trait for Type
        var trait_type: ?*TypeRef = null
        if (self.match(TokenType.KwFor)) {
            trait_type = impl_type
            impl_type = self.parseType()
        }

        // Methods
        self.consume(TokenType.LeftBrace, "Expected '{' after impl type")

        var methods = new List<*Stmt>
        while (!self.check(TokenType.RightBrace) and !self.isAtEnd()) {
            // Each method is a function declaration
            if (self.check(TokenType.KwFn)) {
                var method: *Stmt = self.parseFunctionDecl()
                methods.push(method)
            } else {
                self.errorAtCurrent("Expected 'fn' in impl block")
                self.advance()
            }
        }

        self.consume(TokenType.RightBrace, "Expected '}' after impl methods")

        return makeImplDeclStmt(impl_type, trait_type, methods.to_slice(), loc)
    }

    // Parse an import statement: import "module"
    fn parseImportStmt(self: *Parser) *Stmt {
        var loc: SourceLoc = SourceLoc.fromToken(self.current)
        self.consume(TokenType.KwImport, "Expected 'import'")

        // Module path (string literal)
        if (!self.check(TokenType.StringLiteral)) {
            self.errorAtCurrent("Expected module path string")
            return makeExprStmt(makeNullExpr(loc), loc)
        }
        var path: string = self.current.lexeme
        self.advance()

        return makeImportStmt(path, loc)
    }

    // Parse an expression statement
    fn parseExpressionStmt(self: *Parser) *Stmt {
        var loc: SourceLoc = SourceLoc.fromToken(self.current)
        var expr: *Expr = self.parseExpr()

        // Optional semicolon
        self.match(TokenType.Semicolon)

        return makeExprStmt(expr, loc)
    }
}

// =============================================================================
// Statement Constructors
// =============================================================================

fn makeExprStmt(expr: *Expr, loc: SourceLoc) *Stmt {
    var s = makeDefaultStmt(StmtKind.ExpressionStmt, loc)
    s.expr = expr
    return s
}

fn makeVarDeclStmt(name: string, mutable: bool, var_type: ?*TypeRef, var_init: ?*Expr, loc: SourceLoc) *Stmt {
    var kind: StmtKind = StmtKind.VarDecl
    if (!mutable) {
        kind = StmtKind.ConstDecl
    }
    var s = makeDefaultStmt(kind, loc)
    s.var_name = name
    s.var_mutable = mutable
    s.var_type = var_type
    s.var_init = var_init
    return s
}

fn makeReturnStmt(return_value: ?*Expr, loc: SourceLoc) *Stmt {
    var s = makeDefaultStmt(StmtKind.ReturnStmt, loc)
    s.return_value = return_value
    return s
}

fn makeIfStmt(cond: *Expr, then_branch: *Stmt, else_branch: ?*Stmt, loc: SourceLoc) *Stmt {
    var s = makeDefaultStmt(StmtKind.IfStmt, loc)
    s.if_cond = cond
    s.if_then = then_branch
    s.if_else = else_branch
    return s
}

fn makeWhileStmt(cond: *Expr, body: *Stmt, loc: SourceLoc) *Stmt {
    var s = makeDefaultStmt(StmtKind.WhileStmt, loc)
    s.while_cond = cond
    s.while_body = body
    return s
}

fn makeForStmt(var_name: string, iter: *Expr, body: *Stmt, loc: SourceLoc) *Stmt {
    var s = makeDefaultStmt(StmtKind.ForStmt, loc)
    s.for_var = var_name
    s.for_iter = iter
    s.for_body = body
    return s
}

fn makeBlockStmt(stmts: []*Stmt, loc: SourceLoc) *Stmt {
    var s = makeDefaultStmt(StmtKind.BlockStmt, loc)
    s.block_stmts = stmts
    return s
}

fn makeSwitchStmt(switch_expr: *Expr, arms: []SwitchArm, loc: SourceLoc) *Stmt {
    var s = makeDefaultStmt(StmtKind.SwitchStmt, loc)
    s.switch_expr = switch_expr
    s.switch_arms = arms
    return s
}

fn makeBreakStmt(loc: SourceLoc) *Stmt {
    return makeDefaultStmt(StmtKind.BreakStmt, loc)
}

fn makeContinueStmt(loc: SourceLoc) *Stmt {
    return makeDefaultStmt(StmtKind.ContinueStmt, loc)
}

fn makeLoopStmt(body: *Stmt, loc: SourceLoc) *Stmt {
    var s = makeDefaultStmt(StmtKind.LoopStmt, loc)
    s.loop_body = body
    return s
}

fn makeDeferStmt(expr: *Expr, loc: SourceLoc) *Stmt {
    var s = makeDefaultStmt(StmtKind.DeferStmt, loc)
    s.defer_expr = expr
    return s
}

fn makeTryStmt(try_body: *Stmt, catch_var: string, catch_body: *Stmt, loc: SourceLoc) *Stmt {
    var s = makeDefaultStmt(StmtKind.TryStmt, loc)
    s.try_body = try_body
    s.catch_var = catch_var
    s.catch_body = catch_body
    return s
}

fn makeThrowStmt(expr: *Expr, loc: SourceLoc) *Stmt {
    var s = makeDefaultStmt(StmtKind.ThrowStmt, loc)
    s.throw_expr = expr
    return s
}

fn makeTestDeclStmt(name: string, body: *Stmt, loc: SourceLoc) *Stmt {
    var s = makeDefaultStmt(StmtKind.TestDecl, loc)
    s.test_name = name
    s.test_body = body
    return s
}

fn makeUnionDeclStmt(name: string, fields: []Field, loc: SourceLoc) *Stmt {
    var s = makeDefaultStmt(StmtKind.UnionDecl, loc)
    s.union_name = name
    s.union_fields = fields
    return s
}

fn makeTypeAliasDeclStmt(name: string, alias_type: *TypeRef, loc: SourceLoc) *Stmt {
    var s = makeDefaultStmt(StmtKind.TypeAliasDecl, loc)
    s.alias_name = name
    s.alias_type = alias_type
    return s
}

// =============================================================================
// Utility Functions
// =============================================================================

fn parseInt(s: string) i64 {
    // Handle hex
    if (len(s) > 2 and s[0..2] == "0x") {
        return parseHex(s[2..len(s)])
    }
    // Handle binary
    if (len(s) > 2 and s[0..2] == "0b") {
        return parseBinary(s[2..len(s)])
    }
    // Decimal
    return parseDecimal(s)
}

fn parseDecimal(s: string) i64 {
    var result: i64 = 0
    var i: i64 = 0
    while (i < len(s)) {
        var ch: string = s[i..i+1]
        if (ch >= "0" and ch <= "9") {
            result = result * 10 + (ascii(ch) - ascii("0"))
        }
        i = i + 1
    }
    return result
}

fn parseHex(s: string) i64 {
    var result: i64 = 0
    var i: i64 = 0
    while (i < len(s)) {
        var ch: string = s[i..i+1]
        result = result * 16
        if (ch >= "0" and ch <= "9") {
            result = result + (ascii(ch) - ascii("0"))
        } else if (ch >= "a" and ch <= "f") {
            result = result + (ascii(ch) - ascii("a") + 10)
        } else if (ch >= "A" and ch <= "F") {
            result = result + (ascii(ch) - ascii("A") + 10)
        }
        i = i + 1
    }
    return result
}

fn parseBinary(s: string) i64 {
    var result: i64 = 0
    var i: i64 = 0
    while (i < len(s)) {
        var ch: string = s[i..i+1]
        result = result * 2
        if (ch == "1") {
            result = result + 1
        }
        i = i + 1
    }
    return result
}

// =============================================================================
// Declaration Statement Constructors
// =============================================================================

fn makeFunctionDeclStmt(name: string, params: []Param, return_type: ?*TypeRef, body: ?*Stmt, loc: SourceLoc) *Stmt {
    var s = makeDefaultStmt(StmtKind.FunctionDecl, loc)
    s.fn_name = name
    s.fn_params = params
    s.fn_return_type = return_type
    s.fn_body = body
    return s
}

fn makeStructDeclStmt(name: string, fields: []Field, loc: SourceLoc) *Stmt {
    var s = makeDefaultStmt(StmtKind.StructDecl, loc)
    s.struct_name = name
    s.struct_fields = fields
    return s
}

fn makeEnumDeclStmt(name: string, variants: []EnumVariant, loc: SourceLoc) *Stmt {
    var s = makeDefaultStmt(StmtKind.EnumDecl, loc)
    s.enum_name = name
    s.enum_variants = variants
    return s
}

fn makeImplDeclStmt(impl_type: *TypeRef, trait_type: ?*TypeRef, methods: []*Stmt, loc: SourceLoc) *Stmt {
    var s = makeDefaultStmt(StmtKind.ImplDecl, loc)
    s.impl_type = impl_type
    s.impl_trait = trait_type
    s.impl_methods = methods
    return s
}

fn makeImportStmt(path: string, loc: SourceLoc) *Stmt {
    var s = makeDefaultStmt(StmtKind.ImportStmt, loc)
    s.import_path = path
    return s
}

fn makeViewDeclStmt(name: string, view_type: *TypeRef, base_field: string, offset: i64, loc: SourceLoc) *Stmt {
    var s = makeDefaultStmt(StmtKind.ViewDecl, loc)
    s.view_name = name
    s.view_type = view_type
    s.view_base_field = base_field
    s.view_offset = offset
    return s
}

// =============================================================================
// Module-Level Parsing Entry Point
// =============================================================================

impl Parser {
    // Parse a complete module (file) and return all top-level declarations
    fn parseModule(self: *Parser) Module {
        var mod = Module.init()

        var iter_count: i64 = 0
        while (!self.isAtEnd()) {
            iter_count += 1
            if (iter_count > 10000) {
                // Safety limit to prevent infinite loops
                self.errorAtCurrent("Parser limit exceeded - possible infinite loop")
                break
            }
            var parsed_stmt: ?*Stmt = self.parseTopLevel()
            if (parsed_stmt != null) {
                // Use coalescing with null-returning fallback for type compatibility
                var stmt = parsed_stmt ?? makeDefaultStmt(StmtKind.ExpressionStmt, SourceLoc.init(0, 0, 0, 0))
                mod.statements.push(stmt)
            }

            // If we're in panic mode, synchronize
            if (self.panic_mode) {
                self.synchronize()
            }
        }

        // Copy errors to module
        var i: i64 = 0
        while (i < self.errors.len()) {
            mod.errors.push(self.errors.get(i))
            i += 1
        }

        mod.has_errors = self.had_error
        return mod
    }

    // Parse a single top-level declaration
    fn parseTopLevel(self: *Parser) ?*Stmt {
        const tok_type = self.peek()

        switch (tok_type) {
            TokenType.KwFn => {
                return self.parseFunctionDecl()
            }
            TokenType.KwStruct => {
                return self.parseStructDecl()
            }
            TokenType.KwUnion => {
                return self.parseUnionDecl()
            }
            TokenType.KwEnum => {
                return self.parseEnumDecl()
            }
            TokenType.KwTrait => {
                return self.parseTraitDecl()
            }
            TokenType.KwImpl => {
                return self.parseImplDecl()
            }
            TokenType.KwConst => {
                return self.parseConstDecl()
            }
            TokenType.KwVar => {
                return self.parseVarDecl()
            }
            TokenType.KwType => {
                return self.parseTypeAliasDecl()
            }
            TokenType.KwImport => {
                return self.parseImportStmt()
            }
            TokenType.KwTest => {
                return self.parseTestDecl()
            }
            TokenType.KwPub => {
                return self.parsePubDecl()
            }
            TokenType.KwComptime => {
                return self.parseComptimeStmt()
            }
        }

        // Unexpected token at top level
        self.errorAtCurrent("unexpected token at top level")
        self.advance()
        return null
    }
}
