// Lexer for the Cot self-hosted compiler
//
// Tokenizes Cot source code into a stream of tokens.
// Uses idiomatic Cot patterns: impl blocks and method syntax.

import "token"

// =============================================================================
// Lexer State
// =============================================================================

struct Lexer {
    source: string,
    start: i64,
    current: i64,
    line: i64,
    column: i64,
    start_column: i64,
    // String interpolation state
    in_interp_string: bool,
    interp_brace_depth: i64,
}

// =============================================================================
// Lexer Implementation
// =============================================================================

impl Lexer {
    // Create a new lexer for the given source
    fn create(source: string) Lexer {
        return Lexer{
            .source = source,
            .start = 0,
            .current = 0,
            .line = 1,
            .column = 1,
            .start_column = 1,
            .in_interp_string = false,
            .interp_brace_depth = 0,
        }
    }

    // Check if we've reached the end of source
    fn isAtEnd(self: *Lexer) bool {
        return self.current >= len(self.source)
    }

    // Advance to the next character and return the current one
    fn advance(self: *Lexer) string {
        if (self.isAtEnd()) {
            return ""
        }
        var ch: string = self.source[self.current..self.current + 1]
        self.current = self.current + 1
        if (ch == "\n") {
            self.line = self.line + 1
            self.column = 1
        } else {
            self.column = self.column + 1
        }
        return ch
    }

    // Peek at current character without consuming
    fn peek(self: *Lexer) string {
        if (self.isAtEnd()) {
            return ""
        }
        return self.source[self.current..self.current + 1]
    }

    // Peek at next character (one ahead)
    fn peekNext(self: *Lexer) string {
        if (self.current + 1 >= len(self.source)) {
            return ""
        }
        return self.source[self.current + 1..self.current + 2]
    }

    // Match current character, advance if matches
    fn match(self: *Lexer, expected: string) bool {
        if (self.isAtEnd()) {
            return false
        }
        if (self.peek() != expected) {
            return false
        }
        self.current = self.current + 1
        self.column = self.column + 1
        return true
    }

    // Skip whitespace and comments
    fn skipWhitespace(self: *Lexer) {
        while (!self.isAtEnd()) {
            var ch: string = self.peek()

            // Whitespace characters
            if (ch == " " or ch == "\t" or ch == "\r" or ch == "\n") {
                self.advance()
                continue
            }

            // Comments
            if (ch == "/") {
                if (self.peekNext() == "/") {
                    // Line comment - skip to end of line
                    while (!self.isAtEnd() and self.peek() != "\n") {
                        self.advance()
                    }
                    continue
                } else if (self.peekNext() == "*") {
                    // Block comment
                    self.advance()  // skip /
                    self.advance()  // skip *
                    while (!self.isAtEnd()) {
                        if (self.peek() == "*" and self.peekNext() == "/") {
                            self.advance()  // skip *
                            self.advance()  // skip /
                            break
                        }
                        self.advance()
                    }
                    continue
                }
            }

            // Not whitespace or comment - stop
            return
        }
    }

    // Get current lexeme (from start to current)
    fn currentLexeme(self: *Lexer) string {
        return self.source[self.start..self.current]
    }

    // Make a token with current lexeme
    fn makeToken(self: *Lexer, token_type: TokenType) Token {
        return Token{
            .token_type = token_type,
            .lexeme = self.currentLexeme(),
            .line = self.line,
            .column = self.start_column,
            .span = Span{ .start = self.start, .end = self.current },
        }
    }

    // Make an error token
    fn errorToken(self: *Lexer, message: string) Token {
        return Token{
            .token_type = TokenType.Invalid,
            .lexeme = message,
            .line = self.line,
            .column = self.start_column,
            .span = Span{ .start = self.start, .end = self.current },
        }
    }

    // Scan a string literal
    fn scanString(self: *Lexer) Token {
        var backslash: string = char(92)  // backslash character
        var quote: string = char(34)      // double quote character
        while (!self.isAtEnd() and self.peek() != quote) {
            if (self.peek() == backslash) {
                self.advance()  // skip backslash
                if (!self.isAtEnd()) {
                    self.advance()  // skip escaped char
                }
            } else {
                self.advance()
            }
        }

        if (self.isAtEnd()) {
            return self.errorToken("Unterminated string")
        }

        self.advance()  // closing quote
        return self.makeToken(TokenType.StringLiteral)
    }

    // Scan a number (integer or decimal)
    fn scanNumber(self: *Lexer) Token {
        // Check for hex/binary prefix
        if (self.currentLexeme() == "0" and !self.isAtEnd()) {
            var next: string = self.peek()
            if (next == "x" or next == "X") {
                self.advance()  // consume x
                while (!self.isAtEnd() and isHexDigit(self.peek())) {
                    self.advance()
                }
                return self.makeToken(TokenType.IntegerLiteral)
            }
            if (next == "b" or next == "B") {
                self.advance()  // consume b
                while (!self.isAtEnd()) {
                    var ch: string = self.peek()
                    if (ch == "0" or ch == "1") {
                        self.advance()
                    } else {
                        break
                    }
                }
                return self.makeToken(TokenType.IntegerLiteral)
            }
        }

        // Regular integer/decimal
        while (!self.isAtEnd() and isDigit(self.peek())) {
            self.advance()
        }

        // Check for decimal point
        if (!self.isAtEnd() and self.peek() == "." and isDigit(self.peekNext())) {
            self.advance()  // consume .
            while (!self.isAtEnd() and isDigit(self.peek())) {
                self.advance()
            }
            return self.makeToken(TokenType.DecimalLiteral)
        }

        return self.makeToken(TokenType.IntegerLiteral)
    }

    // Scan an identifier or keyword
    fn scanIdentifier(self: *Lexer) Token {
        while (!self.isAtEnd() and isAlphaNumeric(self.peek())) {
            self.advance()
        }

        var text: string = self.currentLexeme()
        var token_type: TokenType = identifierType(text)
        return self.makeToken(token_type)
    }

    // Check if string contains ${ interpolation
    fn stringContainsInterpolation(self: *Lexer) bool {
        var quote: string = char(34)  // double quote
        var pos: i64 = self.current
        while (pos < len(self.source)) {
            var ch: string = self.source[pos..pos + 1]
            if (ch == quote) {
                return false  // End of string, no interpolation found
            }
            // Check for ${
            if (ch == "$" and pos + 1 < len(self.source)) {
                var next: string = self.source[pos + 1..pos + 2]
                if (next == "{") {
                    // Check if escaped by counting backslashes
                    var backslash_count: i64 = 0
                    var check_pos: i64 = pos - 1
                    while (check_pos >= self.current) {
                        var prev: string = self.source[check_pos..check_pos + 1]
                        if (prev == char(92)) {  // backslash
                            backslash_count = backslash_count + 1
                            check_pos = check_pos - 1
                        } else {
                            break
                        }
                    }
                    // If even number of backslashes, this is real interpolation
                    if (backslash_count % 2 == 0) {
                        return true
                    }
                }
            }
            pos = pos + 1
        }
        return false
    }

    // Scan content inside an interpolated string: "Hello ${name}!"
    fn scanInterpStringContent(self: *Lexer) Token {
        self.start = self.current
        self.start_column = self.column
        var quote: string = char(34)

        // If we're inside an interpolation ${...}, scan normal tokens
        if (self.interp_brace_depth > 0) {
            // Skip whitespace inside interpolation
            self.skipWhitespace()
            self.start = self.current
            self.start_column = self.column

            if (self.isAtEnd()) {
                self.in_interp_string = false
                return self.errorToken("Unterminated interpolated string")
            }

            var ch: string = self.peek()

            // Check for nested braces
            if (ch == "{") {
                self.advance()
                self.interp_brace_depth = self.interp_brace_depth + 1
                return self.makeToken(TokenType.LeftBrace)
            }

            // Check for closing brace - end of interpolation
            if (ch == "}") {
                self.advance()
                self.interp_brace_depth = self.interp_brace_depth - 1
                if (self.interp_brace_depth == 0) {
                    return self.makeToken(TokenType.InterpExprEnd)
                }
                return self.makeToken(TokenType.RightBrace)
            }

            // Otherwise scan a normal token for the expression
            ch = self.advance()

            // Handle common expression tokens
            if (isAlpha(ch)) {
                return self.scanIdentifier()
            }
            if (isDigit(ch)) {
                return self.scanNumber()
            }

            switch (ch) {
                "(" => { return self.makeToken(TokenType.LeftParen) }
                ")" => { return self.makeToken(TokenType.RightParen) }
                "[" => { return self.makeToken(TokenType.LeftBracket) }
                "]" => { return self.makeToken(TokenType.RightBracket) }
                "," => { return self.makeToken(TokenType.Comma) }
                "." => { return self.makeToken(TokenType.Dot) }
                "+" => { return self.makeToken(TokenType.Plus) }
                "-" => { return self.makeToken(TokenType.Minus) }
                "*" => { return self.makeToken(TokenType.Star) }
                "/" => { return self.makeToken(TokenType.Slash) }
            }

            // Handle string inside interpolation
            if (ch == quote) {
                return self.scanString()
            }

            return self.errorToken("Unexpected character in interpolation: " + ch)
        }

        // We're in string content mode (not inside ${})
        if (self.isAtEnd()) {
            self.in_interp_string = false
            return self.errorToken("Unterminated interpolated string")
        }

        var ch: string = self.peek()

        // Check for closing quote - end of interpolated string
        if (ch == quote) {
            self.advance()
            self.in_interp_string = false
            return self.makeToken(TokenType.StringInterpEnd)
        }

        // Check for interpolation start: ${
        if (ch == "$" and self.current + 1 < len(self.source)) {
            var next: string = self.source[self.current + 1..self.current + 2]
            if (next == "{") {
                self.advance()  // $
                self.advance()  // {
                self.interp_brace_depth = 1
                return self.makeToken(TokenType.InterpExprStart)
            }
        }

        // Scan string content until ${ or closing quote
        var backslash: string = char(92)
        while (!self.isAtEnd()) {
            var next_ch: string = self.peek()
            if (next_ch == quote) {
                break
            }
            // Check for ${ interpolation start
            if (next_ch == "$" and self.current + 1 < len(self.source)) {
                var after: string = self.source[self.current + 1..self.current + 2]
                if (after == "{") {
                    break
                }
            }
            // Handle escape sequences
            if (next_ch == backslash and self.current + 1 < len(self.source)) {
                self.advance()  // skip backslash
            }
            self.advance()
        }

        return self.makeToken(TokenType.StringContent)
    }

    // Scan a single token - main entry point
    fn scanToken(self: *Lexer) Token {
        // If we're inside an interpolated string, handle it specially
        if (self.in_interp_string) {
            return self.scanInterpStringContent()
        }

        self.skipWhitespace()
        self.start = self.current
        self.start_column = self.column

        if (self.isAtEnd()) {
            return self.makeToken(TokenType.Eof)
        }

        var ch: string = self.advance()

        // Identifiers and keywords
        if (isAlpha(ch)) {
            return self.scanIdentifier()
        }

        // Numbers
        if (isDigit(ch)) {
            return self.scanNumber()
        }

        // String literal - check for interpolation
        var quote: string = char(34)
        if (ch == quote) {
            // Check if this string contains ${ for interpolation
            if (self.stringContainsInterpolation()) {
                self.in_interp_string = true
                self.interp_brace_depth = 0
                return self.makeToken(TokenType.StringInterpStart)
            }
            return self.scanString()
        }

        // Punctuation and operators
        switch (ch) {
            // Simple single-character tokens
            "(" => { return self.makeToken(TokenType.LeftParen) }
            ")" => { return self.makeToken(TokenType.RightParen) }
            "[" => { return self.makeToken(TokenType.LeftBracket) }
            "]" => { return self.makeToken(TokenType.RightBracket) }
            "{" => { return self.makeToken(TokenType.LeftBrace) }
            "}" => { return self.makeToken(TokenType.RightBrace) }
            "," => { return self.makeToken(TokenType.Comma) }
            ";" => { return self.makeToken(TokenType.Semicolon) }
            "@" => { return self.makeToken(TokenType.At) }
            "%" => { return self.makeToken(TokenType.Percent) }
            "^" => { return self.makeToken(TokenType.Caret) }
            "~" => { return self.makeToken(TokenType.Tilde) }
            "#" => {
                if (self.match("#")) {
                    return self.makeToken(TokenType.HashHash)
                }
                return self.makeToken(TokenType.Hash)
            }

            // Dot and range
            "." => {
                if (self.match(".")) {
                    if (self.match("=")) {
                        return self.makeToken(TokenType.RangeInclusive)
                    }
                    return self.makeToken(TokenType.Range)
                }
                return self.makeToken(TokenType.Dot)
            }

            // Colon variants
            ":" => {
                if (self.match(":")) {
                    return self.makeToken(TokenType.DoubleColon)
                } else if (self.match("=")) {
                    return self.makeToken(TokenType.Walrus)
                }
                return self.makeToken(TokenType.Colon)
            }

            // Plus variants
            "+" => {
                if (self.match("+")) {
                    return self.makeToken(TokenType.PlusPlus)
                } else if (self.match("=")) {
                    return self.makeToken(TokenType.PlusEquals)
                }
                return self.makeToken(TokenType.Plus)
            }

            // Minus and arrow
            "-" => {
                if (self.match(">")) {
                    return self.makeToken(TokenType.Arrow)
                } else if (self.match("=")) {
                    return self.makeToken(TokenType.MinusEquals)
                }
                return self.makeToken(TokenType.Minus)
            }

            // Star
            "*" => {
                if (self.match("=")) {
                    return self.makeToken(TokenType.StarEquals)
                }
                return self.makeToken(TokenType.Star)
            }

            // Slash
            "/" => {
                if (self.match("=")) {
                    return self.makeToken(TokenType.SlashEquals)
                }
                return self.makeToken(TokenType.Slash)
            }

            // Equals and fat arrow
            "=" => {
                if (self.match("=")) {
                    return self.makeToken(TokenType.EqualEqual)
                } else if (self.match(">")) {
                    return self.makeToken(TokenType.FatArrow)
                }
                return self.makeToken(TokenType.Equals)
            }

            // Bang
            "!" => {
                if (self.match("=")) {
                    return self.makeToken(TokenType.BangEqual)
                }
                return self.makeToken(TokenType.Bang)
            }

            // Less than and left shift
            "<" => {
                if (self.match("<")) {
                    return self.makeToken(TokenType.LessLess)
                } else if (self.match("=")) {
                    return self.makeToken(TokenType.LessEqual)
                }
                return self.makeToken(TokenType.Less)
            }

            // Greater than and right shift
            ">" => {
                if (self.match(">")) {
                    return self.makeToken(TokenType.GreaterGreater)
                } else if (self.match("=")) {
                    return self.makeToken(TokenType.GreaterEqual)
                }
                return self.makeToken(TokenType.Greater)
            }

            // Ampersand
            "&" => {
                if (self.match("&")) {
                    return self.makeToken(TokenType.AmpAmp)
                } else if (self.match("=")) {
                    return self.makeToken(TokenType.AmpEquals)
                }
                return self.makeToken(TokenType.Ampersand)
            }

            // Pipe
            "|" => {
                if (self.match("|")) {
                    return self.makeToken(TokenType.PipePipe)
                } else if (self.match("=")) {
                    return self.makeToken(TokenType.PipeEquals)
                }
                return self.makeToken(TokenType.Pipe)
            }

            // Question mark variants
            "?" => {
                if (self.match(".")) {
                    return self.makeToken(TokenType.QuestionDot)
                } else if (self.match("?")) {
                    return self.makeToken(TokenType.QuestionQuestion)
                } else if (self.match("[")) {
                    return self.makeToken(TokenType.QuestionBracket)
                }
                return self.makeToken(TokenType.Question)
            }
        }

        return self.errorToken("Unexpected character: " + ch)
    }
}

// =============================================================================
// Character Classification Helpers
// =============================================================================

fn isDigit(ch: string) bool {
    return ch >= "0" and ch <= "9"
}

fn isAlpha(ch: string) bool {
    return (ch >= "a" and ch <= "z") or (ch >= "A" and ch <= "Z") or ch == "_"
}

fn isAlphaNumeric(ch: string) bool {
    return isAlpha(ch) or isDigit(ch)
}

fn isHexDigit(ch: string) bool {
    return isDigit(ch) or (ch >= "a" and ch <= "f") or (ch >= "A" and ch <= "F")
}

// =============================================================================
// Keyword Lookup
// =============================================================================

fn identifierType(text: string) TokenType {
    switch (text) {
        // Declaration keywords
        "fn" => { return TokenType.KwFn }
        "struct" => { return TokenType.KwStruct }
        "union" => { return TokenType.KwUnion }
        "view" => { return TokenType.KwView }
        "enum" => { return TokenType.KwEnum }
        "const" => { return TokenType.KwConst }
        "var" => { return TokenType.KwVar }
        "let" => { return TokenType.KwVar }  // let is alias for var
        "type" => { return TokenType.KwType }
        "impl" => { return TokenType.KwImpl }
        "trait" => { return TokenType.KwTrait }
        "dyn" => { return TokenType.KwDyn }
        "pub" => { return TokenType.KwPub }
        "static" => { return TokenType.KwStatic }

        // Control flow keywords
        "if" => { return TokenType.KwIf }
        "else" => { return TokenType.KwElse }
        "switch" => { return TokenType.KwSwitch }
        "for" => { return TokenType.KwFor }
        "in" => { return TokenType.KwIn }
        "while" => { return TokenType.KwWhile }
        "loop" => { return TokenType.KwLoop }
        "break" => { return TokenType.KwBreak }
        "continue" => { return TokenType.KwContinue }
        "return" => { return TokenType.KwReturn }

        // Error handling keywords
        "try" => { return TokenType.KwTry }
        "catch" => { return TokenType.KwCatch }
        "throw" => { return TokenType.KwThrow }
        "finally" => { return TokenType.KwFinally }
        "defer" => { return TokenType.KwDefer }

        // Other keywords
        "import" => { return TokenType.KwImport }
        "as" => { return TokenType.KwAs }
        "is" => { return TokenType.KwIs }
        "self" => { return TokenType.KwSelf }
        "true" => { return TokenType.KwTrue }
        "false" => { return TokenType.KwFalse }
        "null" => { return TokenType.KwNull }
        "nil" => { return TokenType.KwNull }
        "and" => { return TokenType.KwAnd }
        "or" => { return TokenType.KwOr }
        "not" => { return TokenType.KwNot }
        "weak" => { return TokenType.KwWeak }
        "async" => { return TokenType.KwAsync }
        "await" => { return TokenType.KwAwait }
        "comptime" => { return TokenType.KwComptime }
        "test" => { return TokenType.KwTest }
    }

    return TokenType.Identifier
}
