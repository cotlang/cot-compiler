// Type system definitions for the Cot self-hosted compiler
//
// Uses index-based references instead of pointers since Cot doesn't have
// heap allocation. Types are stored in a TypeRegistry and referenced by ID.

// =============================================================================
// Type Tags
// =============================================================================

enum TypeTag {
    // Primitive types
    Void,           // void / unit type
    Bool,           // bool
    I8,             // i8
    I16,            // i16
    I32,            // i32
    I64,            // i64
    U8,             // u8
    U16,            // u16
    U32,            // u32
    U64,            // u64
    F32,            // f32
    F64,            // f64
    StringType,     // string (immutable)
    Char,           // char (single character)

    // Compound types
    Pointer,        // *T
    Optional,       // ?T
    Array,          // [N]T (fixed size)
    Slice,          // []T (dynamic)
    Range,          // start..end or start..=end

    // User-defined types
    StructType,     // struct { fields }
    EnumType,       // enum { variants }

    // Function type
    FunctionType,   // fn(A, B) -> C

    // Special types
    Never,          // ! (never returns)
    Any,            // any (for type erasure)
    ErrorType,      // Type error sentinel
    Unresolved,     // Not yet resolved (placeholder)

    // Generic types
    GenericType,    // Generic type definition (List[T])
    GenericParam,   // Type parameter placeholder (T)
}

// =============================================================================
// Type Struct
// =============================================================================

// Type ID - index into TypeRegistry.types
// -1 means no type / null

struct TypeInfo {
    tag: TypeTag,

    // For Pointer, Optional, Array, Slice - the element type ID
    element_type_id: i64,

    // For Array - the fixed size
    array_size: i64,

    // For Range - whether it's inclusive (..=)
    range_inclusive: bool,

    // For Struct - name and fields
    struct_name: string,
    struct_fields: List<TypeField>,

    // For Enum - name and variants
    enum_name: string,
    enum_variants: List<TypeVariant>,

    // For Function - parameter type IDs and return type ID
    fn_param_ids: List<i64>,
    fn_return_id: i64,
    fn_variadic: bool,

    // For Generic types
    generic_params: List<string>,     // Type parameter names ["T", "U"]
    generic_arg_ids: List<i64>,       // Concrete type arguments for instantiation
    generic_base_id: i64,             // Base generic type ID (for instances)

    // For named types - the original name (for error messages)
    name: string,
}

impl TypeInfo {
    fn init(tag: TypeTag, name: string) TypeInfo {
        return TypeInfo{
            .tag = tag,
            .element_type_id = -1,
            .array_size = 0,
            .range_inclusive = false,
            .struct_name = "",
            .struct_fields = new List<TypeField>,
            .enum_name = "",
            .enum_variants = new List<TypeVariant>,
            .fn_param_ids = new List<i64>,
            .fn_return_id = -1,
            .fn_variadic = false,
            .generic_params = new List<string>,
            .generic_arg_ids = new List<i64>,
            .generic_base_id = -1,
            .name = name,
        }
    }

    fn isNumeric(self: TypeInfo) bool {
        switch (self.tag) {
            TypeTag.I8 => { return true }
            TypeTag.I16 => { return true }
            TypeTag.I32 => { return true }
            TypeTag.I64 => { return true }
            TypeTag.U8 => { return true }
            TypeTag.U16 => { return true }
            TypeTag.U32 => { return true }
            TypeTag.U64 => { return true }
            TypeTag.F32 => { return true }
            TypeTag.F64 => { return true }
            else => { return false }
        }
    }

    fn isInteger(self: TypeInfo) bool {
        switch (self.tag) {
            TypeTag.I8 => { return true }
            TypeTag.I16 => { return true }
            TypeTag.I32 => { return true }
            TypeTag.I64 => { return true }
            TypeTag.U8 => { return true }
            TypeTag.U16 => { return true }
            TypeTag.U32 => { return true }
            TypeTag.U64 => { return true }
            else => { return false }
        }
    }

    fn isFloat(self: TypeInfo) bool {
        switch (self.tag) {
            TypeTag.F32 => { return true }
            TypeTag.F64 => { return true }
            else => { return false }
        }
    }

    fn isSigned(self: TypeInfo) bool {
        switch (self.tag) {
            TypeTag.I8 => { return true }
            TypeTag.I16 => { return true }
            TypeTag.I32 => { return true }
            TypeTag.I64 => { return true }
            TypeTag.F32 => { return true }
            TypeTag.F64 => { return true }
            else => { return false }
        }
    }

    fn isPrimitive(self: TypeInfo) bool {
        switch (self.tag) {
            TypeTag.Void => { return true }
            TypeTag.Bool => { return true }
            TypeTag.I8 => { return true }
            TypeTag.I16 => { return true }
            TypeTag.I32 => { return true }
            TypeTag.I64 => { return true }
            TypeTag.U8 => { return true }
            TypeTag.U16 => { return true }
            TypeTag.U32 => { return true }
            TypeTag.U64 => { return true }
            TypeTag.F32 => { return true }
            TypeTag.F64 => { return true }
            TypeTag.StringType => { return true }
            TypeTag.Char => { return true }
            else => { return false }
        }
    }

    fn isError(self: TypeInfo) bool {
        return self.tag == TypeTag.ErrorType
    }

    fn isGeneric(self: TypeInfo) bool {
        return self.tag == TypeTag.GenericType or self.tag == TypeTag.GenericParam
    }

    fn isGenericInstance(self: TypeInfo) bool {
        return self.tag == TypeTag.GenericType and self.generic_arg_ids.len() > 0
    }
}

// =============================================================================
// Supporting Structs
// =============================================================================

// Field in a struct type
struct TypeField {
    name: string,
    field_type_id: i64,
    offset: i64,        // Byte offset (for codegen)
}

// Variant in an enum type
struct TypeVariant {
    name: string,
    value: i64,         // Discriminant value
    payload_type_id: i64,  // -1 for no payload
}

// =============================================================================
// Type Registry
// =============================================================================

struct TypeRegistry {
    types: List<TypeInfo>,

    // Cache of primitive type IDs for quick access
    void_id: i64,
    bool_id: i64,
    i8_id: i64,
    i16_id: i64,
    i32_id: i64,
    i64_id: i64,
    u8_id: i64,
    u16_id: i64,
    u32_id: i64,
    u64_id: i64,
    f32_id: i64,
    f64_id: i64,
    string_id: i64,
    char_id: i64,
    error_id: i64,

    // Generic type definitions by name (e.g., "List" -> type ID)
    generic_defs: Map<string, i64>,

    // Cache of generic instantiations: "List[i64]" -> type ID
    generic_instances: Map<string, i64>,
}

impl TypeRegistry {
    fn init() TypeRegistry {
        var reg = TypeRegistry{
            .types = new List<TypeInfo>,
            .void_id = -1,
            .bool_id = -1,
            .i8_id = -1,
            .i16_id = -1,
            .i32_id = -1,
            .i64_id = -1,
            .u8_id = -1,
            .u16_id = -1,
            .u32_id = -1,
            .u64_id = -1,
            .f32_id = -1,
            .f64_id = -1,
            .string_id = -1,
            .char_id = -1,
            .error_id = -1,
            .generic_defs = new Map<string, i64>,
            .generic_instances = new Map<string, i64>,
        }

        // Register primitive types
        reg.void_id = reg.addPrimitiveType(TypeTag.Void, "void")
        reg.bool_id = reg.addPrimitiveType(TypeTag.Bool, "bool")
        reg.i8_id = reg.addPrimitiveType(TypeTag.I8, "i8")
        reg.i16_id = reg.addPrimitiveType(TypeTag.I16, "i16")
        reg.i32_id = reg.addPrimitiveType(TypeTag.I32, "i32")
        reg.i64_id = reg.addPrimitiveType(TypeTag.I64, "i64")
        reg.u8_id = reg.addPrimitiveType(TypeTag.U8, "u8")
        reg.u16_id = reg.addPrimitiveType(TypeTag.U16, "u16")
        reg.u32_id = reg.addPrimitiveType(TypeTag.U32, "u32")
        reg.u64_id = reg.addPrimitiveType(TypeTag.U64, "u64")
        reg.f32_id = reg.addPrimitiveType(TypeTag.F32, "f32")
        reg.f64_id = reg.addPrimitiveType(TypeTag.F64, "f64")
        reg.string_id = reg.addPrimitiveType(TypeTag.StringType, "string")
        reg.char_id = reg.addPrimitiveType(TypeTag.Char, "char")
        reg.error_id = reg.addPrimitiveType(TypeTag.ErrorType, "<error>")

        return reg
    }

    fn addPrimitiveType(self: TypeRegistry, tag: TypeTag, name: string) i64 {
        const id = self.types.len()
        const t = TypeInfo.init(tag, name)
        self.types.push(t)
        return id
    }

    fn getType(self: TypeRegistry, id: i64) TypeInfo {
        return self.types.get(id)
    }

    fn addPointerType(self: TypeRegistry, inner_id: i64) i64 {
        const id = self.types.len()
        const inner = self.getType(inner_id)
        var t = TypeInfo.init(TypeTag.Pointer, "*${inner.name}")
        t.element_type_id = inner_id
        self.types.push(t)
        return id
    }

    fn addOptionalType(self: TypeRegistry, inner_id: i64) i64 {
        const id = self.types.len()
        const inner = self.getType(inner_id)
        var t = TypeInfo.init(TypeTag.Optional, "?${inner.name}")
        t.element_type_id = inner_id
        self.types.push(t)
        return id
    }

    fn addArrayType(self: TypeRegistry, inner_id: i64, size: i64) i64 {
        const id = self.types.len()
        const inner = self.getType(inner_id)
        var t = TypeInfo.init(TypeTag.Array, "[${size}]${inner.name}")
        t.element_type_id = inner_id
        t.array_size = size
        self.types.push(t)
        return id
    }

    fn addSliceType(self: TypeRegistry, inner_id: i64) i64 {
        const id = self.types.len()
        const inner = self.getType(inner_id)
        var t = TypeInfo.init(TypeTag.Slice, "[]${inner.name}")
        t.element_type_id = inner_id
        self.types.push(t)
        return id
    }

    fn addStructType(self: TypeRegistry, name: string) i64 {
        const id = self.types.len()
        var t = TypeInfo.init(TypeTag.StructType, name)
        t.struct_name = name
        self.types.push(t)
        return id
    }

    fn addEnumType(self: TypeRegistry, name: string) i64 {
        const id = self.types.len()
        var t = TypeInfo.init(TypeTag.EnumType, name)
        t.enum_name = name
        self.types.push(t)
        return id
    }

    fn addFunctionType(self: TypeRegistry, param_ids: List<i64>, return_id: i64) i64 {
        const id = self.types.len()
        var t = TypeInfo.init(TypeTag.FunctionType, "fn(...)")
        t.fn_param_ids = param_ids
        t.fn_return_id = return_id
        self.types.push(t)
        return id
    }

    fn addGenericType(self: TypeRegistry, name: string, params: List<string>) i64 {
        const id = self.types.len()
        var t = TypeInfo.init(TypeTag.GenericType, name)
        t.struct_name = name
        t.generic_params = params
        self.types.push(t)
        self.generic_defs.set(name, id)
        return id
    }

    fn addGenericInstance(self: TypeRegistry, base_name: string, arg_ids: List<i64>) i64 {
        // Build cache key: "List[i64]" or "Map[string, i64]"
        var cache_key = "${base_name}["
        for i in 0..arg_ids.len() {
            if (i > 0) {
                cache_key = "${cache_key}, "
            }
            const arg_type = self.getType(arg_ids.get(i))
            cache_key = "${cache_key}${arg_type.name}"
        }
        cache_key = "${cache_key}]"

        // Check cache
        if (self.generic_instances.has(cache_key)) {
            return self.generic_instances.get(cache_key)
        }

        // Create new instance
        const id = self.types.len()

        // Get base generic type ID
        var base_id: i64 = -1
        if (self.generic_defs.has(base_name)) {
            base_id = self.generic_defs.get(base_name)
        }

        var t = TypeInfo.init(TypeTag.GenericType, cache_key)
        t.struct_name = base_name
        t.generic_arg_ids = arg_ids
        t.generic_base_id = base_id

        self.types.push(t)
        self.generic_instances.set(cache_key, id)
        return id
    }

    fn addTypeParam(self: TypeRegistry, name: string) i64 {
        const id = self.types.len()
        const t = TypeInfo.init(TypeTag.GenericParam, name)
        self.types.push(t)
        return id
    }

    fn isErrorTypeId(self: TypeRegistry, id: i64) bool {
        if (id < 0) {
            return true
        }
        const t = self.getType(id)
        return t.tag == TypeTag.ErrorType
    }

    fn typesEqual(self: TypeRegistry, a_id: i64, b_id: i64) bool {
        // Same ID = same type
        if (a_id == b_id) {
            return true
        }

        // Handle -1 (null) cases
        if (a_id < 0 or b_id < 0) {
            return false
        }

        const a = self.getType(a_id)
        const b = self.getType(b_id)

        // Different tags = different types
        if (a.tag != b.tag) {
            return false
        }

        switch (a.tag) {
            // Primitive types - tag equality is sufficient
            TypeTag.Void => { return true }
            TypeTag.Bool => { return true }
            TypeTag.I8 => { return true }
            TypeTag.I16 => { return true }
            TypeTag.I32 => { return true }
            TypeTag.I64 => { return true }
            TypeTag.U8 => { return true }
            TypeTag.U16 => { return true }
            TypeTag.U32 => { return true }
            TypeTag.U64 => { return true }
            TypeTag.F32 => { return true }
            TypeTag.F64 => { return true }
            TypeTag.StringType => { return true }
            TypeTag.Char => { return true }
            TypeTag.Never => { return true }
            TypeTag.Any => { return true }
            TypeTag.ErrorType => { return true }

            // Compound types - check element types
            TypeTag.Pointer => {
                return self.typesEqual(a.element_type_id, b.element_type_id)
            }
            TypeTag.Optional => {
                return self.typesEqual(a.element_type_id, b.element_type_id)
            }
            TypeTag.Slice => {
                return self.typesEqual(a.element_type_id, b.element_type_id)
            }
            TypeTag.Array => {
                if (a.array_size != b.array_size) {
                    return false
                }
                return self.typesEqual(a.element_type_id, b.element_type_id)
            }

            // Named types - compare by name
            TypeTag.StructType => {
                return a.struct_name == b.struct_name
            }
            TypeTag.EnumType => {
                return a.enum_name == b.enum_name
            }

            // Function types - compare params and return
            TypeTag.FunctionType => {
                if (a.fn_param_ids.len() != b.fn_param_ids.len()) {
                    return false
                }
                for i in 0..a.fn_param_ids.len() {
                    const pa = a.fn_param_ids.get(i)
                    const pb = b.fn_param_ids.get(i)
                    if (not self.typesEqual(pa, pb)) {
                        return false
                    }
                }
                return self.typesEqual(a.fn_return_id, b.fn_return_id)
            }

            // Generic types - compare by name and type args
            TypeTag.GenericType => {
                if (a.struct_name != b.struct_name) {
                    return false
                }
                if (a.generic_arg_ids.len() != b.generic_arg_ids.len()) {
                    return false
                }
                for i in 0..a.generic_arg_ids.len() {
                    if (not self.typesEqual(a.generic_arg_ids.get(i), b.generic_arg_ids.get(i))) {
                        return false
                    }
                }
                return true
            }

            // Generic params - compare by name
            TypeTag.GenericParam => {
                return a.name == b.name
            }

            // Unresolved types are never equal
            TypeTag.Unresolved => { return false }

            else => { return false }
        }
    }

    fn typeToString(self: TypeRegistry, type_id: i64) string {
        if (type_id < 0) {
            return "<null>"
        }

        const t = self.getType(type_id)

        // Use the precomputed name if available
        if (t.name != "") {
            return t.name
        }

        switch (t.tag) {
            TypeTag.Void => { return "void" }
            TypeTag.Bool => { return "bool" }
            TypeTag.I8 => { return "i8" }
            TypeTag.I16 => { return "i16" }
            TypeTag.I32 => { return "i32" }
            TypeTag.I64 => { return "i64" }
            TypeTag.U8 => { return "u8" }
            TypeTag.U16 => { return "u16" }
            TypeTag.U32 => { return "u32" }
            TypeTag.U64 => { return "u64" }
            TypeTag.F32 => { return "f32" }
            TypeTag.F64 => { return "f64" }
            TypeTag.StringType => { return "string" }
            TypeTag.Char => { return "char" }
            TypeTag.Never => { return "!" }
            TypeTag.Any => { return "any" }
            TypeTag.ErrorType => { return "<error>" }
            TypeTag.Unresolved => { return "<unresolved>" }

            TypeTag.Pointer => {
                return "*${self.typeToString(t.element_type_id)}"
            }
            TypeTag.Optional => {
                return "?${self.typeToString(t.element_type_id)}"
            }
            TypeTag.Slice => {
                return "[]${self.typeToString(t.element_type_id)}"
            }
            TypeTag.Array => {
                return "[${t.array_size}]${self.typeToString(t.element_type_id)}"
            }

            TypeTag.StructType => { return t.struct_name }
            TypeTag.EnumType => { return t.enum_name }

            TypeTag.FunctionType => {
                var result = "fn("
                for i in 0..t.fn_param_ids.len() {
                    if (i > 0) {
                        result = "${result}, "
                    }
                    result = "${result}${self.typeToString(t.fn_param_ids.get(i))}"
                }
                result = "${result})"
                if (t.fn_return_id >= 0) {
                    result = "${result} ${self.typeToString(t.fn_return_id)}"
                }
                return result
            }

            TypeTag.GenericType => {
                var result = t.struct_name
                if (t.generic_arg_ids.len() > 0) {
                    result = "${result}["
                    for i in 0..t.generic_arg_ids.len() {
                        if (i > 0) {
                            result = "${result}, "
                        }
                        result = "${result}${self.typeToString(t.generic_arg_ids.get(i))}"
                    }
                    result = "${result}]"
                }
                return result
            }

            TypeTag.GenericParam => { return t.name }

            else => { return "<unknown>" }
        }
    }

    fn isAssignableTo(self: TypeRegistry, from_id: i64, to_id: i64) bool {
        // Same type is always assignable
        if (self.typesEqual(from_id, to_id)) {
            return true
        }

        // Handle null types
        if (from_id < 0 or to_id < 0) {
            return false
        }

        const from = self.getType(from_id)
        const to = self.getType(to_id)

        // Error type is assignable to anything (to allow error recovery)
        if (from.tag == TypeTag.ErrorType or to.tag == TypeTag.ErrorType) {
            return true
        }

        // Any type accepts anything
        if (to.tag == TypeTag.Any) {
            return true
        }

        // Never type can be assigned to anything
        if (from.tag == TypeTag.Never) {
            return true
        }

        // Null (void) can be assigned to optional types
        if (from.tag == TypeTag.Void and to.tag == TypeTag.Optional) {
            return true
        }

        // T can be assigned to ?T
        if (to.tag == TypeTag.Optional and to.element_type_id >= 0) {
            if (self.typesEqual(from_id, to.element_type_id)) {
                return true
            }
        }

        // Integer widening: smaller to larger signed
        if (from.isInteger() and to.isInteger()) {
            // Allow implicit widening (i8 -> i16 -> i32 -> i64)
            if (from.tag == TypeTag.I32 and to.tag == TypeTag.I64) {
                return true
            }
            if (from.tag == TypeTag.I16 and (to.tag == TypeTag.I32 or to.tag == TypeTag.I64)) {
                return true
            }
            if (from.tag == TypeTag.I8 and (to.tag == TypeTag.I16 or to.tag == TypeTag.I32 or to.tag == TypeTag.I64)) {
                return true
            }
        }

        return false
    }
}

// =============================================================================
// Legacy Compatibility (to be removed after all callers updated)
// =============================================================================

fn newTypeRegistry() TypeRegistry {
    return TypeRegistry.init()
}

fn regAddPrimitiveType(reg: TypeRegistry, tag: TypeTag, name: string) i64 {
    return reg.addPrimitiveType(tag, name)
}

fn regGetType(reg: TypeRegistry, id: i64) TypeInfo {
    return reg.getType(id)
}

fn regAddPointerType(reg: TypeRegistry, inner_id: i64) i64 {
    return reg.addPointerType(inner_id)
}

fn regAddOptionalType(reg: TypeRegistry, inner_id: i64) i64 {
    return reg.addOptionalType(inner_id)
}

fn regAddArrayType(reg: TypeRegistry, inner_id: i64, size: i64) i64 {
    return reg.addArrayType(inner_id, size)
}

fn regAddSliceType(reg: TypeRegistry, inner_id: i64) i64 {
    return reg.addSliceType(inner_id)
}

fn regAddStructType(reg: TypeRegistry, name: string) i64 {
    return reg.addStructType(name)
}

fn regAddEnumType(reg: TypeRegistry, name: string) i64 {
    return reg.addEnumType(name)
}

fn regAddFunctionType(reg: TypeRegistry, param_ids: List<i64>, return_id: i64) i64 {
    return reg.addFunctionType(param_ids, return_id)
}

fn regAddGenericType(reg: TypeRegistry, name: string, params: List<string>) i64 {
    return reg.addGenericType(name, params)
}

fn regAddGenericInstance(reg: TypeRegistry, base_name: string, arg_ids: List<i64>) i64 {
    return reg.addGenericInstance(base_name, arg_ids)
}

fn regAddTypeParam(reg: TypeRegistry, name: string) i64 {
    return reg.addTypeParam(name)
}

fn isGenericType(t: TypeInfo) bool {
    return t.isGeneric()
}

fn isGenericInstance(t: TypeInfo) bool {
    return t.isGenericInstance()
}

fn isNumericType(t: TypeInfo) bool {
    return t.isNumeric()
}

fn isIntegerType(t: TypeInfo) bool {
    return t.isInteger()
}

fn isFloatType(t: TypeInfo) bool {
    return t.isFloat()
}

fn isSignedType(t: TypeInfo) bool {
    return t.isSigned()
}

fn isPrimitiveType(t: TypeInfo) bool {
    return t.isPrimitive()
}

fn isErrorType(t: TypeInfo) bool {
    return t.isError()
}

fn isErrorTypeId(reg: TypeRegistry, id: i64) bool {
    return reg.isErrorTypeId(id)
}

fn typesEqualById(reg: TypeRegistry, a_id: i64, b_id: i64) bool {
    return reg.typesEqual(a_id, b_id)
}

fn typeToString(reg: TypeRegistry, type_id: i64) string {
    return reg.typeToString(type_id)
}

fn isAssignableToById(reg: TypeRegistry, from_id: i64, to_id: i64) bool {
    return reg.isAssignableTo(from_id, to_id)
}
