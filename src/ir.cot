// Intermediate Representation for the Cot self-hosted compiler
//
// This module defines the IR used between type checking and bytecode emission.
// The IR uses SSA (Static Single Assignment) form with basic blocks.

// =============================================================================
// IR Type System
// =============================================================================

// IR type tags
enum IRTypeTag {
    // Primitives
    Void,
    Bool,
    I8,
    I16,
    I32,
    I64,
    U8,
    U16,
    U32,
    U64,
    F32,
    F64,
    String,
    Char,

    // Pointer types
    Ptr,
    Optional,
    Slice,
    Array,

    // Composite types
    StructType,
    UnionType,
    EnumType,
    FunctionType,

    // Special
    AnyType,
    ErrorType,
}

// IR type representation
struct IRType {
    tag: IRTypeTag,
    name: string,
    element_type_id: i64,
    array_size: i64,
}

impl IRType {
    fn init(tag: IRTypeTag, name: string) IRType {
        return IRType{
            .tag = tag,
            .name = name,
            .element_type_id = -1,
            .array_size = 0,
        }
    }

    fn isInteger(self: IRType) bool {
        switch (self.tag) {
            IRTypeTag.I8 => { return true }
            IRTypeTag.I16 => { return true }
            IRTypeTag.I32 => { return true }
            IRTypeTag.I64 => { return true }
            IRTypeTag.U8 => { return true }
            IRTypeTag.U16 => { return true }
            IRTypeTag.U32 => { return true }
            IRTypeTag.U64 => { return true }
            else => { return false }
        }
    }

    fn isFloat(self: IRType) bool {
        switch (self.tag) {
            IRTypeTag.F32 => { return true }
            IRTypeTag.F64 => { return true }
            else => { return false }
        }
    }

    fn isNumeric(self: IRType) bool {
        return self.isInteger() or self.isFloat()
    }

    fn isSigned(self: IRType) bool {
        switch (self.tag) {
            IRTypeTag.I8 => { return true }
            IRTypeTag.I16 => { return true }
            IRTypeTag.I32 => { return true }
            IRTypeTag.I64 => { return true }
            IRTypeTag.F32 => { return true }
            IRTypeTag.F64 => { return true }
            else => { return false }
        }
    }

    fn isPointer(self: IRType) bool {
        switch (self.tag) {
            IRTypeTag.Ptr => { return true }
            IRTypeTag.Optional => { return true }
            IRTypeTag.Slice => { return true }
            else => { return false }
        }
    }
}

// =============================================================================
// IR Values (SSA)
// =============================================================================

struct IRValue {
    id: i64,
    type_id: i64,
}

impl IRValue {
    fn init(id: i64, type_id: i64) IRValue {
        return IRValue{
            .id = id,
            .type_id = type_id,
        }
    }

    fn invalid() IRValue {
        return IRValue{
            .id = -1,
            .type_id = -1,
        }
    }
}

// =============================================================================
// IR Instructions
// =============================================================================

enum IROp {
    // Memory
    Alloca,
    Load,
    Store,
    FieldPtr,
    IndexPtr,

    // Arithmetic
    IAdd,
    ISub,
    IMul,
    SDiv,
    UDiv,
    SRem,
    URem,
    INeg,
    FAdd,
    FSub,
    FMul,
    FDiv,
    FNeg,

    // Bitwise
    BAnd,
    BOr,
    BXor,
    BNot,
    IShl,
    SShr,
    UShr,

    // Comparison
    ICmp,
    FCmp,

    // Logical
    LogAnd,
    LogOr,
    LogNot,

    // Control flow
    Jump,
    BrIf,
    BrTable,
    Ret,
    Call,

    // Constants
    IConst,
    FConst,
    StrConst,
    BoolConst,
    NullConst,

    // Conversions
    Bitcast,
    SExtend,
    UExtend,
    IReduce,
    IntToFloat,
    FloatToInt,

    // String
    StrConcat,
    StrCompare,
    StrLen,

    // Optional
    WrapOptional,
    UnwrapOptional,
    IsNull,

    // Array/Slice
    ArrayLoad,
    ArrayStore,
    ArrayLen,

    // List
    ListNew,
    ListPush,
    ListPop,
    ListGet,
    ListSet,
    ListLen,

    // Map
    MapNew,
    MapSet,
    MapGet,
    MapHas,
    MapDelete,
    MapLen,

    // Select
    Select,

    // Debug
    DebugLine,

    // Slicing
    SliceNew,        // Create slice from array/slice[start..end]

    // Error handling
    SetHandler,      // Set error handler (target block for catch)
    ClearHandler,    // Clear/pop error handler (end of try block)
    ErrThrow,        // Throw an error

    // Sum type (variant) operations
    VariantConstruct,  // Construct variant with tag and payload values
    VariantGetTag,     // Extract the discriminant tag from a variant
    VariantGetPayload, // Extract payload field from a variant

    // Closure operations
    MakeClosure,       // Create closure from function name and environment map
}

impl IROp {
    fn isTerminator(self: IROp) bool {
        switch (self) {
            IROp.Jump => { return true }
            IROp.BrIf => { return true }
            IROp.BrTable => { return true }
            IROp.Ret => { return true }
            IROp.ErrThrow => { return true }
            else => { return false }
        }
    }

    fn producesValue(self: IROp) bool {
        switch (self) {
            IROp.Store => { return false }
            IROp.Jump => { return false }
            IROp.BrIf => { return false }
            IROp.BrTable => { return false }
            IROp.Ret => { return false }
            IROp.SetHandler => { return false }
            IROp.ClearHandler => { return false }
            IROp.ErrThrow => { return false }
            IROp.ArrayStore => { return false }
            IROp.ListPush => { return false }
            IROp.ListSet => { return false }
            IROp.MapSet => { return false }
            IROp.MapDelete => { return false }
            IROp.DebugLine => { return false }
            else => { return true }
        }
    }
}

// Comparison condition codes
enum CondCode {
    Eq,
    Ne,
    Slt,
    Sle,
    Sgt,
    Sge,
    Ult,
    Ule,
    Ugt,
    Uge,
}

// IR instruction
struct IRInst {
    op: IROp,
    result_id: i64,
    result_type_id: i64,
    op1_id: i64,
    op2_id: i64,
    op3_id: i64,
    int_val: i64,
    str_val: string,
    bool_val: bool,
    cond: CondCode,
    target_block: i64,
    else_block: i64,
    callee: string,
    field_name: string,
    field_index: i64,
    line: i64,
}

impl IRInst {
    fn init(op: IROp) IRInst {
        return IRInst{
            .op = op,
            .result_id = -1,
            .result_type_id = -1,
            .op1_id = -1,
            .op2_id = -1,
            .op3_id = -1,
            .int_val = 0,
            .str_val = "",
            .bool_val = false,
            .cond = CondCode.Eq,
            .target_block = -1,
            .else_block = -1,
            .callee = "",
            .field_name = "",
            .field_index = -1,
            .line = 0,
        }
    }
}

// =============================================================================
// Basic Blocks
// =============================================================================

struct IRBlock {
    id: i64,
    label: string,
    insts: List<IRInst>,
    preds: List<i64>,
    succs: List<i64>,
}

impl IRBlock {
    fn init(id: i64, label: string) IRBlock {
        return IRBlock{
            .id = id,
            .label = label,
            .insts = new List<IRInst>,
            .preds = new List<i64>,
            .succs = new List<i64>,
        }
    }

    fn append(self: IRBlock, inst: IRInst) {
        self.insts.push(inst)
    }

    fn isTerminated(self: IRBlock) bool {
        if (self.insts.len() == 0) {
            return false
        }
        const last = self.insts.get(self.insts.len() - 1)
        return last.op.isTerminator()
    }
}

// =============================================================================
// Functions
// =============================================================================

struct IRFunction {
    name: string,
    export_name: string,
    is_public: bool,
    param_names: List<string>,
    param_type_ids: List<i64>,
    return_type_id: i64,
    entry_block: i64,
    blocks: List<IRBlock>,
    next_value_id: i64,
    next_block_id: i64,
    locals: Map<string, i64>,
}

impl IRFunction {
    fn init(name: string) IRFunction {
        return IRFunction{
            .name = name,
            .export_name = "",
            .is_public = false,
            .param_names = new List<string>,
            .param_type_ids = new List<i64>,
            .return_type_id = -1,
            .entry_block = -1,
            .blocks = new List<IRBlock>,
            .next_value_id = 0,
            .next_block_id = 0,
            .locals = new Map<string, i64>,
        }
    }

    fn newValue(self: IRFunction) i64 {
        const id = self.next_value_id
        self.next_value_id = self.next_value_id + 1
        return id
    }

    fn createBlock(self: IRFunction, label: string) i64 {
        const id = self.next_block_id
        self.next_block_id = self.next_block_id + 1
        const block = IRBlock.init(id, label)
        self.blocks.push(block)
        return id
    }

    fn getBlock(self: IRFunction, id: i64) IRBlock {
        return self.blocks.get(id)
    }
}

// =============================================================================
// Module
// =============================================================================

struct IRGlobal {
    name: string,
    type_id: i64,
    is_const: bool,
}

struct IRModule {
    name: string,
    types: List<IRType>,
    globals: List<IRGlobal>,
    functions: List<IRFunction>,
    strings: List<string>,
}

impl IRModule {
    fn init(name: string) IRModule {
        return IRModule{
            .name = name,
            .types = new List<IRType>,
            .globals = new List<IRGlobal>,
            .functions = new List<IRFunction>,
            .strings = new List<string>,
        }
    }

    fn addFunction(self: IRModule, func: IRFunction) i64 {
        const id = self.functions.len()
        self.functions.push(func)
        return id
    }

    fn addGlobal(self: IRModule, global: IRGlobal) i64 {
        const id = self.globals.len()
        self.globals.push(global)
        return id
    }

    fn addString(self: IRModule, s: string) i64 {
        // Check if string already exists
        for i in 0..self.strings.len() {
            if (self.strings.get(i) == s) {
                return i
            }
        }
        const id = self.strings.len()
        self.strings.push(s)
        return id
    }
}

// =============================================================================
// IR Type Registry
// =============================================================================

struct IRTypeRegistry {
    types: List<IRType>,
    void_id: i64,
    bool_id: i64,
    i8_id: i64,
    i16_id: i64,
    i32_id: i64,
    i64_id: i64,
    u8_id: i64,
    u16_id: i64,
    u32_id: i64,
    u64_id: i64,
    f32_id: i64,
    f64_id: i64,
    string_id: i64,
    char_id: i64,
    error_id: i64,
}

impl IRTypeRegistry {
    fn init() IRTypeRegistry {
        var reg = IRTypeRegistry{
            .types = new List<IRType>,
            .void_id = -1,
            .bool_id = -1,
            .i8_id = -1,
            .i16_id = -1,
            .i32_id = -1,
            .i64_id = -1,
            .u8_id = -1,
            .u16_id = -1,
            .u32_id = -1,
            .u64_id = -1,
            .f32_id = -1,
            .f64_id = -1,
            .string_id = -1,
            .char_id = -1,
            .error_id = -1,
        }

        // Register primitive types
        reg.void_id = reg.addType(IRTypeTag.Void, "void")
        reg.bool_id = reg.addType(IRTypeTag.Bool, "bool")
        reg.i8_id = reg.addType(IRTypeTag.I8, "i8")
        reg.i16_id = reg.addType(IRTypeTag.I16, "i16")
        reg.i32_id = reg.addType(IRTypeTag.I32, "i32")
        reg.i64_id = reg.addType(IRTypeTag.I64, "i64")
        reg.u8_id = reg.addType(IRTypeTag.U8, "u8")
        reg.u16_id = reg.addType(IRTypeTag.U16, "u16")
        reg.u32_id = reg.addType(IRTypeTag.U32, "u32")
        reg.u64_id = reg.addType(IRTypeTag.U64, "u64")
        reg.f32_id = reg.addType(IRTypeTag.F32, "f32")
        reg.f64_id = reg.addType(IRTypeTag.F64, "f64")
        reg.string_id = reg.addType(IRTypeTag.String, "string")
        reg.char_id = reg.addType(IRTypeTag.Char, "char")
        reg.error_id = reg.addType(IRTypeTag.ErrorType, "<error>")

        return reg
    }

    fn addType(self: IRTypeRegistry, tag: IRTypeTag, name: string) i64 {
        const id = self.types.len()
        const t = IRType.init(tag, name)
        self.types.push(t)
        return id
    }

    fn getType(self: IRTypeRegistry, id: i64) IRType {
        return self.types.get(id)
    }

    fn addPointer(self: IRTypeRegistry, inner_id: i64) i64 {
        const inner = self.types.get(inner_id)
        const id = self.types.len()
        var t = IRType.init(IRTypeTag.Ptr, "*${inner.name}")
        t.element_type_id = inner_id
        self.types.push(t)
        return id
    }

    fn addOptional(self: IRTypeRegistry, inner_id: i64) i64 {
        const inner = self.types.get(inner_id)
        const id = self.types.len()
        var t = IRType.init(IRTypeTag.Optional, "?${inner.name}")
        t.element_type_id = inner_id
        self.types.push(t)
        return id
    }

    fn addSlice(self: IRTypeRegistry, inner_id: i64) i64 {
        const inner = self.types.get(inner_id)
        const id = self.types.len()
        var t = IRType.init(IRTypeTag.Slice, "[]${inner.name}")
        t.element_type_id = inner_id
        self.types.push(t)
        return id
    }

    fn addArray(self: IRTypeRegistry, inner_id: i64, size: i64) i64 {
        const inner = self.types.get(inner_id)
        const id = self.types.len()
        var t = IRType.init(IRTypeTag.Array, "[${size}]${inner.name}")
        t.element_type_id = inner_id
        t.array_size = size
        self.types.push(t)
        return id
    }
}

// =============================================================================
// Legacy Compatibility (to be removed after all callers updated)
// =============================================================================

// These functions maintain backwards compatibility during the transition.
// They will be removed once all call sites are updated to use impl methods.

fn newIRType(tag: IRTypeTag, name: string) IRType {
    return IRType.init(tag, name)
}

fn newIRValue(id: i64, type_id: i64) IRValue {
    return IRValue.init(id, type_id)
}

fn invalidValue() IRValue {
    return IRValue.invalid()
}

fn newIRInst(op: IROp) IRInst {
    return IRInst.init(op)
}

fn isTerminator(op: IROp) bool {
    return op.isTerminator()
}

fn producesValue(op: IROp) bool {
    return op.producesValue()
}

fn newIRBlock(id: i64, label: string) IRBlock {
    return IRBlock.init(id, label)
}

fn blockAppend(block: IRBlock, inst: IRInst) {
    block.append(inst)
}

fn blockIsTerminated(block: IRBlock) bool {
    return block.isTerminated()
}

fn newIRFunction(name: string) IRFunction {
    return IRFunction.init(name)
}

fn fnNewValue(func: IRFunction) i64 {
    return func.newValue()
}

fn fnCreateBlock(func: IRFunction, label: string) i64 {
    return func.createBlock(label)
}

fn fnGetBlock(func: IRFunction, id: i64) IRBlock {
    return func.getBlock(id)
}

fn newIRModule(name: string) IRModule {
    return IRModule.init(name)
}

fn modAddFunction(mod: IRModule, func: IRFunction) i64 {
    return mod.addFunction(func)
}

fn modAddGlobal(mod: IRModule, global: IRGlobal) i64 {
    return mod.addGlobal(global)
}

fn modAddString(mod: IRModule, s: string) i64 {
    return mod.addString(s)
}

fn newIRTypeRegistry() IRTypeRegistry {
    return IRTypeRegistry.init()
}

fn irRegAddType(reg: IRTypeRegistry, tag: IRTypeTag, name: string) i64 {
    return reg.addType(tag, name)
}

fn irRegGetType(reg: IRTypeRegistry, id: i64) IRType {
    return reg.getType(id)
}

fn irRegAddPointer(reg: IRTypeRegistry, inner_id: i64) i64 {
    return reg.addPointer(inner_id)
}

fn irRegAddOptional(reg: IRTypeRegistry, inner_id: i64) i64 {
    return reg.addOptional(inner_id)
}

fn irRegAddSlice(reg: IRTypeRegistry, inner_id: i64) i64 {
    return reg.addSlice(inner_id)
}

fn irRegAddArray(reg: IRTypeRegistry, inner_id: i64, size: i64) i64 {
    return reg.addArray(inner_id, size)
}

fn irTypeIsInteger(t: IRType) bool {
    return t.isInteger()
}

fn irTypeIsFloat(t: IRType) bool {
    return t.isFloat()
}

fn irTypeIsNumeric(t: IRType) bool {
    return t.isNumeric()
}

fn irTypeIsSigned(t: IRType) bool {
    return t.isSigned()
}

fn irTypeIsPointer(t: IRType) bool {
    return t.isPointer()
}
