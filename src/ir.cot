// Intermediate Representation for the Cot self-hosted compiler
//
// This module defines the IR used between type checking and bytecode emission.
// The IR uses SSA (Static Single Assignment) form with basic blocks.

// =============================================================================
// IR Type System
// =============================================================================

// IR type tags
enum IRTypeTag {
    // Primitives
    Void,
    Bool,
    I8,
    I16,
    I32,
    I64,
    U8,
    U16,
    U32,
    U64,
    F32,
    F64,
    String,
    Char,

    // Pointer types
    Ptr,
    Optional,
    Slice,
    Array,

    // Composite types
    StructType,
    UnionType,
    EnumType,
    FunctionType,

    // Special
    AnyType,
    ErrorType,
}

// IR type representation
struct IRType {
    tag: IRTypeTag,
    name: string,
    element_type_id: i64,
    array_size: i64,
}

fn newIRType(tag: IRTypeTag, name: string) IRType {
    return IRType{
        .tag = tag,
        .name = name,
        .element_type_id = -1,
        .array_size = 0,
    }
}

// =============================================================================
// IR Values (SSA)
// =============================================================================

struct IRValue {
    id: i64,
    type_id: i64,
}

fn newIRValue(id: i64, type_id: i64) IRValue {
    return IRValue{
        .id = id,
        .type_id = type_id,
    }
}

fn invalidValue() IRValue {
    return IRValue{
        .id = -1,
        .type_id = -1,
    }
}

// =============================================================================
// IR Instructions
// =============================================================================

enum IROp {
    // Memory
    Alloca,
    Load,
    Store,
    FieldPtr,
    IndexPtr,

    // Arithmetic
    IAdd,
    ISub,
    IMul,
    SDiv,
    UDiv,
    SRem,
    URem,
    INeg,
    FAdd,
    FSub,
    FMul,
    FDiv,
    FNeg,

    // Bitwise
    BAnd,
    BOr,
    BXor,
    BNot,
    IShl,
    SShr,
    UShr,

    // Comparison
    ICmp,
    FCmp,

    // Logical
    LogAnd,
    LogOr,
    LogNot,

    // Control flow
    Jump,
    BrIf,
    BrTable,
    Ret,
    Call,

    // Constants
    IConst,
    FConst,
    StrConst,
    BoolConst,
    NullConst,

    // Conversions
    Bitcast,
    SExtend,
    UExtend,
    IReduce,
    IntToFloat,
    FloatToInt,

    // String
    StrConcat,
    StrCompare,
    StrLen,

    // Optional
    WrapOptional,
    UnwrapOptional,
    IsNull,

    // Array/Slice
    ArrayLoad,
    ArrayStore,
    ArrayLen,

    // List
    ListNew,
    ListPush,
    ListPop,
    ListGet,
    ListSet,
    ListLen,

    // Map
    MapNew,
    MapSet,
    MapGet,
    MapHas,
    MapDelete,
    MapLen,

    // Select
    Select,

    // Debug
    DebugLine,
}

// Comparison condition codes
enum CondCode {
    Eq,
    Ne,
    Slt,
    Sle,
    Sgt,
    Sge,
    Ult,
    Ule,
    Ugt,
    Uge,
}

// IR instruction
struct IRInst {
    op: IROp,
    result_id: i64,
    result_type_id: i64,
    op1_id: i64,
    op2_id: i64,
    op3_id: i64,
    int_val: i64,
    str_val: string,
    bool_val: bool,
    cond: CondCode,
    target_block: i64,
    else_block: i64,
    callee: string,
    field_name: string,
    field_index: i64,
    line: i64,
}

fn newIRInst(op: IROp) IRInst {
    return IRInst{
        .op = op,
        .result_id = -1,
        .result_type_id = -1,
        .op1_id = -1,
        .op2_id = -1,
        .op3_id = -1,
        .int_val = 0,
        .str_val = "",
        .bool_val = false,
        .cond = CondCode.Eq,
        .target_block = -1,
        .else_block = -1,
        .callee = "",
        .field_name = "",
        .field_index = -1,
        .line = 0,
    }
}

fn isTerminator(op: IROp) bool {
    switch (op) {
        IROp.Jump => { return true }
        IROp.BrIf => { return true }
        IROp.BrTable => { return true }
        IROp.Ret => { return true }
        else => { return false }
    }
}

fn producesValue(op: IROp) bool {
    switch (op) {
        IROp.Store => { return false }
        IROp.Jump => { return false }
        IROp.BrIf => { return false }
        IROp.BrTable => { return false }
        IROp.Ret => { return false }
        IROp.ArrayStore => { return false }
        IROp.ListPush => { return false }
        IROp.ListSet => { return false }
        IROp.MapSet => { return false }
        IROp.MapDelete => { return false }
        IROp.DebugLine => { return false }
        else => { return true }
    }
}

// =============================================================================
// Basic Blocks
// =============================================================================

struct IRBlock {
    id: i64,
    label: string,
    insts: List<IRInst>,
    preds: List<i64>,
    succs: List<i64>,
}

fn newIRBlock(id: i64, label: string) IRBlock {
    const insts: List<IRInst> = List.new()
    const preds: List<i64> = List.new()
    const succs: List<i64> = List.new()
    return IRBlock{
        .id = id,
        .label = label,
        .insts = insts,
        .preds = preds,
        .succs = succs,
    }
}

fn blockAppend(block: IRBlock, inst: IRInst) {
    block.insts.push(inst)
}

fn blockIsTerminated(block: IRBlock) bool {
    if (block.insts.len() == 0) {
        return false
    }
    const last = block.insts.get(block.insts.len() - 1)
    return isTerminator(last.op)
}

// =============================================================================
// Functions
// =============================================================================

struct IRFunction {
    name: string,
    export_name: string,
    is_public: bool,
    param_names: List<string>,
    param_type_ids: List<i64>,
    return_type_id: i64,
    entry_block: i64,
    blocks: List<IRBlock>,
    next_value_id: i64,
    next_block_id: i64,
    locals: Map<string, i64>,
}

fn newIRFunction(name: string) IRFunction {
    const param_names: List<string> = List.new()
    const param_type_ids: List<i64> = List.new()
    const blocks: List<IRBlock> = List.new()
    const locals: Map<string, i64> = Map.new()

    return IRFunction{
        .name = name,
        .export_name = "",
        .is_public = false,
        .param_names = param_names,
        .param_type_ids = param_type_ids,
        .return_type_id = -1,
        .entry_block = -1,
        .blocks = blocks,
        .next_value_id = 0,
        .next_block_id = 0,
        .locals = locals,
    }
}

fn fnNewValue(func: IRFunction) i64 {
    const id = func.next_value_id
    func.next_value_id = func.next_value_id + 1
    return id
}

fn fnCreateBlock(func: IRFunction, label: string) i64 {
    const id = func.next_block_id
    func.next_block_id = func.next_block_id + 1
    const block = newIRBlock(id, label)
    func.blocks.push(block)
    return id
}

fn fnGetBlock(func: IRFunction, id: i64) IRBlock {
    return func.blocks.get(id)
}

// =============================================================================
// Module
// =============================================================================

struct IRGlobal {
    name: string,
    type_id: i64,
    is_const: bool,
}

struct IRModule {
    name: string,
    types: List<IRType>,
    globals: List<IRGlobal>,
    functions: List<IRFunction>,
    strings: List<string>,
}

fn newIRModule(name: string) IRModule {
    const types: List<IRType> = List.new()
    const globals: List<IRGlobal> = List.new()
    const functions: List<IRFunction> = List.new()
    const strings: List<string> = List.new()

    return IRModule{
        .name = name,
        .types = types,
        .globals = globals,
        .functions = functions,
        .strings = strings,
    }
}

fn modAddFunction(mod: IRModule, func: IRFunction) i64 {
    const id = mod.functions.len()
    mod.functions.push(func)
    return id
}

fn modAddGlobal(mod: IRModule, global: IRGlobal) i64 {
    const id = mod.globals.len()
    mod.globals.push(global)
    return id
}

fn modAddString(mod: IRModule, s: string) i64 {
    var i: i64 = 0
    while (i < mod.strings.len()) {
        if (mod.strings.get(i) == s) {
            return i
        }
        i = i + 1
    }
    const id = mod.strings.len()
    mod.strings.push(s)
    return id
}

// =============================================================================
// IR Type Registry
// =============================================================================

struct IRTypeRegistry {
    types: List<IRType>,
    void_id: i64,
    bool_id: i64,
    i8_id: i64,
    i16_id: i64,
    i32_id: i64,
    i64_id: i64,
    u8_id: i64,
    u16_id: i64,
    u32_id: i64,
    u64_id: i64,
    f32_id: i64,
    f64_id: i64,
    string_id: i64,
    char_id: i64,
    error_id: i64,
}

fn newIRTypeRegistry() IRTypeRegistry {
    const types: List<IRType> = List.new()
    var reg = IRTypeRegistry{
        .types = types,
        .void_id = -1,
        .bool_id = -1,
        .i8_id = -1,
        .i16_id = -1,
        .i32_id = -1,
        .i64_id = -1,
        .u8_id = -1,
        .u16_id = -1,
        .u32_id = -1,
        .u64_id = -1,
        .f32_id = -1,
        .f64_id = -1,
        .string_id = -1,
        .char_id = -1,
        .error_id = -1,
    }

    reg.void_id = irRegAddType(reg, IRTypeTag.Void, "void")
    reg.bool_id = irRegAddType(reg, IRTypeTag.Bool, "bool")
    reg.i8_id = irRegAddType(reg, IRTypeTag.I8, "i8")
    reg.i16_id = irRegAddType(reg, IRTypeTag.I16, "i16")
    reg.i32_id = irRegAddType(reg, IRTypeTag.I32, "i32")
    reg.i64_id = irRegAddType(reg, IRTypeTag.I64, "i64")
    reg.u8_id = irRegAddType(reg, IRTypeTag.U8, "u8")
    reg.u16_id = irRegAddType(reg, IRTypeTag.U16, "u16")
    reg.u32_id = irRegAddType(reg, IRTypeTag.U32, "u32")
    reg.u64_id = irRegAddType(reg, IRTypeTag.U64, "u64")
    reg.f32_id = irRegAddType(reg, IRTypeTag.F32, "f32")
    reg.f64_id = irRegAddType(reg, IRTypeTag.F64, "f64")
    reg.string_id = irRegAddType(reg, IRTypeTag.String, "string")
    reg.char_id = irRegAddType(reg, IRTypeTag.Char, "char")
    reg.error_id = irRegAddType(reg, IRTypeTag.ErrorType, "<error>")

    return reg
}

fn irRegAddType(reg: IRTypeRegistry, tag: IRTypeTag, name: string) i64 {
    const id = reg.types.len()
    const t = newIRType(tag, name)
    reg.types.push(t)
    return id
}

fn irRegGetType(reg: IRTypeRegistry, id: i64) IRType {
    return reg.types.get(id)
}

fn irRegAddPointer(reg: IRTypeRegistry, inner_id: i64) i64 {
    const inner = reg.types.get(inner_id)
    const id = reg.types.len()
    var t = newIRType(IRTypeTag.Ptr, "*${inner.name}")
    t.element_type_id = inner_id
    reg.types.push(t)
    return id
}

fn irRegAddOptional(reg: IRTypeRegistry, inner_id: i64) i64 {
    const inner = reg.types.get(inner_id)
    const id = reg.types.len()
    var t = newIRType(IRTypeTag.Optional, "?${inner.name}")
    t.element_type_id = inner_id
    reg.types.push(t)
    return id
}

fn irRegAddSlice(reg: IRTypeRegistry, inner_id: i64) i64 {
    const inner = reg.types.get(inner_id)
    const id = reg.types.len()
    var t = newIRType(IRTypeTag.Slice, "[]${inner.name}")
    t.element_type_id = inner_id
    reg.types.push(t)
    return id
}

fn irRegAddArray(reg: IRTypeRegistry, inner_id: i64, size: i64) i64 {
    const inner = reg.types.get(inner_id)
    const id = reg.types.len()
    var t = newIRType(IRTypeTag.Array, "[${size}]${inner.name}")
    t.element_type_id = inner_id
    t.array_size = size
    reg.types.push(t)
    return id
}

// =============================================================================
// Type Predicates
// =============================================================================

fn irTypeIsInteger(t: IRType) bool {
    switch (t.tag) {
        IRTypeTag.I8 => { return true }
        IRTypeTag.I16 => { return true }
        IRTypeTag.I32 => { return true }
        IRTypeTag.I64 => { return true }
        IRTypeTag.U8 => { return true }
        IRTypeTag.U16 => { return true }
        IRTypeTag.U32 => { return true }
        IRTypeTag.U64 => { return true }
        else => { return false }
    }
}

fn irTypeIsFloat(t: IRType) bool {
    switch (t.tag) {
        IRTypeTag.F32 => { return true }
        IRTypeTag.F64 => { return true }
        else => { return false }
    }
}

fn irTypeIsNumeric(t: IRType) bool {
    return irTypeIsInteger(t) or irTypeIsFloat(t)
}

fn irTypeIsSigned(t: IRType) bool {
    switch (t.tag) {
        IRTypeTag.I8 => { return true }
        IRTypeTag.I16 => { return true }
        IRTypeTag.I32 => { return true }
        IRTypeTag.I64 => { return true }
        IRTypeTag.F32 => { return true }
        IRTypeTag.F64 => { return true }
        else => { return false }
    }
}

fn irTypeIsPointer(t: IRType) bool {
    switch (t.tag) {
        IRTypeTag.Ptr => { return true }
        IRTypeTag.Optional => { return true }
        IRTypeTag.Slice => { return true }
        else => { return false }
    }
}
