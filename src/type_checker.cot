// Type Checker for the Cot self-hosted compiler
//
// Performs semantic analysis:
// - Type inference and checking
// - Scope/symbol management
// - Type resolution (TypeRef -> Type)
//
// Uses index-based references since Cot doesn't have heap allocation.
// Note: Imports commented out - compile with types.cot together or inline dependencies

import "types"
import "ast"
import "token"

// =============================================================================
// Symbol Table Entry
// =============================================================================

enum SymbolKind {
    Variable,       // Local or global variable
    Constant,       // Const binding
    FunctionDef,    // Function definition
    StructDef,      // Struct type definition
    EnumDef,        // Enum type definition
    EnumVariantDef, // Enum variant (for EnumName.Variant)
    Parameter,      // Function parameter
    TypeAliasDef,   // Type alias
}

struct Symbol {
    name: string,
    kind: SymbolKind,
    type_id: i64,       // Index into TypeRegistry
    mutable: bool,      // For variables - can be reassigned
    line: i64,          // Source line for error messages
    valid: bool,        // Sentinel for lookup results
}

impl Symbol {
    fn invalid() Symbol {
        return Symbol{
            .name = "",
            .kind = SymbolKind.Variable,
            .type_id = -1,
            .mutable = false,
            .line = 0,
            .valid = false,
        }
    }

    fn init(name: string, kind: SymbolKind, type_id: i64, mutable: bool, line: i64) Symbol {
        return Symbol{
            .name = name,
            .kind = kind,
            .type_id = type_id,
            .mutable = mutable,
            .line = line,
            .valid = true,
        }
    }
}

// =============================================================================
// Trait Definitions
// =============================================================================

// Method signature in a trait
struct TraitMethodSig {
    name: string,
    param_type_ids: List<i64>,
    return_type_id: i64,
}

// Trait definition with method signatures
struct TraitDef {
    name: string,
    methods: List<TraitMethodSig>,
}

impl TraitDef {
    fn init(name: string) TraitDef {
        return TraitDef{
            .name = name,
            .methods = new List<TraitMethodSig>,
        }
    }
}

// =============================================================================
// Scope Management
// =============================================================================

struct Scope {
    parent_id: i64,     // -1 for no parent
    symbols: Map<string, Symbol>,
    return_type_id: i64,    // Expected return type (-1 if not function scope)
    in_loop: bool,          // For break/continue validation
}

struct ScopeManager {
    scopes: List<Scope>,
    current_id: i64,
}

impl ScopeManager {
    fn init() ScopeManager {
        var scopes = new List<Scope>

        // Create global scope at index 0
        const global = Scope{
            .parent_id = -1,
            .symbols = new Map<string, Symbol>,
            .return_type_id = -1,
            .in_loop = false,
        }
        scopes.push(global)

        return ScopeManager{
            .scopes = scopes,
            .current_id = 0,
        }
    }

    fn currentScope(self: ScopeManager) Scope {
        return self.scopes.get(self.current_id)
    }

    fn enterScope(self: ScopeManager) i64 {
        const current = self.scopes.get(self.current_id)
        const new_scope = Scope{
            .parent_id = self.current_id,
            .symbols = new Map<string, Symbol>,
            .return_type_id = current.return_type_id,  // Inherit return type
            .in_loop = current.in_loop,                // Inherit loop context
        }
        const new_id = self.scopes.len()
        self.scopes.push(new_scope)
        self.current_id = new_id
        return new_id
    }

    fn enterFunctionScope(self: ScopeManager, return_type_id: i64) i64 {
        const new_scope = Scope{
            .parent_id = self.current_id,
            .symbols = new Map<string, Symbol>,
            .return_type_id = return_type_id,
            .in_loop = false,
        }
        const new_id = self.scopes.len()
        self.scopes.push(new_scope)
        self.current_id = new_id
        return new_id
    }

    fn enterLoopScope(self: ScopeManager) i64 {
        const current = self.scopes.get(self.current_id)
        const new_scope = Scope{
            .parent_id = self.current_id,
            .symbols = new Map<string, Symbol>,
            .return_type_id = current.return_type_id,
            .in_loop = true,
        }
        const new_id = self.scopes.len()
        self.scopes.push(new_scope)
        self.current_id = new_id
        return new_id
    }

    fn exitScope(self: ScopeManager) {
        const current = self.scopes.get(self.current_id)
        if (current.parent_id >= 0) {
            self.current_id = current.parent_id
        }
    }

    fn define(self: ScopeManager, name: string, sym: Symbol) bool {
        const scope = self.scopes.get(self.current_id)
        if (scope.symbols.has(name)) {
            return false  // Already defined in this scope
        }
        scope.symbols.set(name, sym)
        return true
    }

    fn lookup(self: ScopeManager, name: string) Symbol {
        var scope_id = self.current_id
        while (scope_id >= 0) {
            const scope = self.scopes.get(scope_id)
            if (scope.symbols.has(name)) {
                var sym = scope.symbols.get(name)
                sym.valid = true
                return sym
            }
            scope_id = scope.parent_id
        }
        return Symbol.invalid()
    }

    fn lookupLocal(self: ScopeManager, name: string) Symbol {
        const scope = self.scopes.get(self.current_id)
        if (scope.symbols.has(name)) {
            var sym = scope.symbols.get(name)
            sym.valid = true
            return sym
        }
        return Symbol.invalid()
    }

    fn inLoop(self: ScopeManager) bool {
        return self.scopes.get(self.current_id).in_loop
    }

    fn returnTypeId(self: ScopeManager) i64 {
        return self.scopes.get(self.current_id).return_type_id
    }
}

// =============================================================================
// Type Checker State
// =============================================================================

struct TypeChecker {
    // Type registry (from types.cot)
    reg: TypeRegistry,

    // Scope management
    scopes: ScopeManager,

    // User-defined types by name -> type ID
    struct_types: Map<string, i64>,
    enum_types: Map<string, i64>,

    // Trait definitions by name
    traits: Map<string, TraitDef>,

    // Method return types: "TypeName.methodName" -> return type ID
    method_returns: Map<string, i64>,

    // Error tracking
    errors: List<string>,
    had_error: bool,
}

impl TypeChecker {
    fn init() TypeChecker {
        var tc = TypeChecker{
            .reg = newTypeRegistry(),
            .scopes = ScopeManager.init(),
            .struct_types = new Map<string, i64>,
            .enum_types = new Map<string, i64>,
            .traits = new Map<string, TraitDef>,
            .method_returns = new Map<string, i64>,
            .errors = new List<string>,
            .had_error = false,
        }
        // Register built-in/native functions
        tc.registerBuiltins()
        return tc
    }

    // Register built-in native functions in the global scope
    fn registerBuiltins(self: TypeChecker) {
        // Phase 1: Register generic type definitions
        self.registerGenericTypes()

        // Phase 2: Register method signatures for generic types
        self.registerGenericMethods()

        // Phase 3: Register native functions with proper signatures
        self.registerNativeFunctions()
    }

    // Register List<T> and other built-in generic type definitions
    fn registerGenericTypes(self: TypeChecker) {
        // Register List<T> generic type definition
        var list_params = new List<string>
        list_params.push("T")
        const list_generic_id = regAddGenericType(self.reg, "List", list_params)
        self.reg.generic_defs.set("List", list_generic_id)

        // Register Map<K, V> generic type definition
        var map_params = new List<string>
        map_params.push("K")
        map_params.push("V")
        const map_generic_id = regAddGenericType(self.reg, "Map", map_params)
        self.reg.generic_defs.set("Map", map_generic_id)
    }

    // Create a List<T> instance with concrete element type
    fn createListInstance(self: TypeChecker, element_type_id: i64) i64 {
        var arg_ids = new List<i64>
        arg_ids.push(element_type_id)
        return regAddGenericInstance(self.reg, "List", arg_ids)
    }

    // Register method signatures for generic types
    // Special return types: -2 = element type, -3 = key type, -4 = value type
    fn registerGenericMethods(self: TypeChecker) {
        // List<T> methods
        self.method_returns.set("List.get", -2)      // get(i64) -> T (element type)
        self.method_returns.set("List.len", self.reg.i64_id)  // len() -> i64
        self.method_returns.set("List.push", self.reg.void_id) // push(T) -> void
        self.method_returns.set("List.to_slice", -2)  // to_slice() -> []T (simplified as T)

        // Map<K, V> methods
        self.method_returns.set("Map.get", -4)       // get(K) -> V (value type)
        self.method_returns.set("Map.has", self.reg.bool_id)  // has(K) -> bool
        self.method_returns.set("Map.set", self.reg.void_id)  // set(K, V) -> void
    }

    // Register native functions with proper function type signatures
    fn registerNativeFunctions(self: TypeChecker) {
        // Create common generic instances
        const list_string_id = self.createListInstance(self.reg.string_id)
        const list_i64_id = self.createListInstance(self.reg.i64_id)

        // process_args() -> List<string>
        var process_args_params = new List<i64>
        const process_args_fn = regAddFunctionType(self.reg, process_args_params, list_string_id)
        self.scopes.define("process_args", Symbol.init("process_args", SymbolKind.FunctionDef, process_args_fn, false, 0))

        // read_file(path: string) -> string
        var read_file_params = new List<i64>
        read_file_params.push(self.reg.string_id)
        const read_file_fn = regAddFunctionType(self.reg, read_file_params, self.reg.string_id)
        self.scopes.define("read_file", Symbol.init("read_file", SymbolKind.FunctionDef, read_file_fn, false, 0))

        // write_bytes(path: string, bytes: List<i64>) -> bool
        var write_bytes_params = new List<i64>
        write_bytes_params.push(self.reg.string_id)
        write_bytes_params.push(list_i64_id)
        const write_bytes_fn = regAddFunctionType(self.reg, write_bytes_params, self.reg.bool_id)
        self.scopes.define("write_bytes", Symbol.init("write_bytes", SymbolKind.FunctionDef, write_bytes_fn, false, 0))

        // write_file(path: string, content: string) -> bool
        var write_file_params = new List<i64>
        write_file_params.push(self.reg.string_id)
        write_file_params.push(self.reg.string_id)
        const write_file_fn = regAddFunctionType(self.reg, write_file_params, self.reg.bool_id)
        self.scopes.define("write_file", Symbol.init("write_file", SymbolKind.FunctionDef, write_file_fn, false, 0))

        // println(msg: string) -> void
        var println_params = new List<i64>
        println_params.push(self.reg.string_id)
        const println_fn = regAddFunctionType(self.reg, println_params, self.reg.void_id)
        self.scopes.define("println", Symbol.init("println", SymbolKind.FunctionDef, println_fn, false, 0))

        // print(msg: string) -> void
        var print_params = new List<i64>
        print_params.push(self.reg.string_id)
        const print_fn = regAddFunctionType(self.reg, print_params, self.reg.void_id)
        self.scopes.define("print", Symbol.init("print", SymbolKind.FunctionDef, print_fn, false, 0))

        // string(n: i64) -> string
        var string_params = new List<i64>
        string_params.push(self.reg.i64_id)
        const string_fn = regAddFunctionType(self.reg, string_params, self.reg.string_id)
        self.scopes.define("string", Symbol.init("string", SymbolKind.FunctionDef, string_fn, false, 0))

        // len(s: string) -> i64
        var len_params = new List<i64>
        len_params.push(self.reg.string_id)
        const len_fn = regAddFunctionType(self.reg, len_params, self.reg.i64_id)
        self.scopes.define("len", Symbol.init("len", SymbolKind.FunctionDef, len_fn, false, 0))
    }

    fn error(self: TypeChecker, line: i64, message: string) {
        const err = "Error at line ${line}: ${message}"
        self.errors.push(err)
        self.had_error = true
    }

    // =========================================================================
    // Type Resolution (TypeRef -> Type ID)
    // =========================================================================

    fn resolveType(self: TypeChecker, type_ref: TypeRef) i64 {
        switch (type_ref.kind) {
            TypeKind.Named => { return self.resolveNamedType(type_ref.name) }
            TypeKind.Pointer => {
                if (type_ref.inner != null) {
                    const inner_id = self.resolveType(type_ref.inner.*)
                    return regAddPointerType(self.reg, inner_id)
                }
                return self.reg.error_id
            }
            TypeKind.Optional => {
                if (type_ref.inner != null) {
                    const inner_id = self.resolveType(type_ref.inner.*)
                    return regAddOptionalType(self.reg, inner_id)
                }
                return self.reg.error_id
            }
            TypeKind.Array => {
                if (type_ref.inner != null) {
                    const inner_id = self.resolveType(type_ref.inner.*)
                    return regAddArrayType(self.reg, inner_id, type_ref.array_size)
                }
                return self.reg.error_id
            }
            TypeKind.Slice => {
                if (type_ref.inner != null) {
                    const inner_id = self.resolveType(type_ref.inner.*)
                    return regAddSliceType(self.reg, inner_id)
                }
                return self.reg.error_id
            }
            TypeKind.Function => {
                const param_ids = new List<i64>
                var i: i64 = 0
                while (i < len(type_ref.param_types)) {
                    param_ids.push(self.resolveType(type_ref.param_types[i].*))
                    i = i + 1
                }
                var return_id = self.reg.void_id
                if (type_ref.return_type != null) {
                    return_id = self.resolveType(type_ref.return_type.*)
                }
                return regAddFunctionType(self.reg, param_ids, return_id)
            }
            TypeKind.Generic => { return self.resolveGenericType(type_ref) }
            TypeKind.Inferred => { return self.reg.error_id }
            else => { return self.reg.error_id }
        }
    }

    fn resolveNamedType(self: TypeChecker, name: string) i64 {
        // Check primitives
        switch (name) {
            "void" => { return self.reg.void_id }
            "bool" => { return self.reg.bool_id }
            "i8" => { return self.reg.i8_id }
            "i16" => { return self.reg.i16_id }
            "i32" => { return self.reg.i32_id }
            "i64" => { return self.reg.i64_id }
            "u8" => { return self.reg.u8_id }
            "u16" => { return self.reg.u16_id }
            "u32" => { return self.reg.u32_id }
            "u64" => { return self.reg.u64_id }
            "f32" => { return self.reg.f32_id }
            "f64" => { return self.reg.f64_id }
            "string" => { return self.reg.string_id }
            "char" => { return self.reg.char_id }
            else => {
                // Check user-defined types
                if (self.struct_types.has(name)) {
                    return self.struct_types.get(name)
                }
                if (self.enum_types.has(name)) {
                    return self.enum_types.get(name)
                }
                // Unknown type
                return self.reg.error_id
            }
        }
    }

    fn resolveGenericType(self: TypeChecker, type_ref: TypeRef) i64 {
        // Get the base type name (e.g., "List" from "List[i64]")
        const base_name = type_ref.name

        // Resolve all type arguments
        const arg_ids = new List<i64>
        var i: i64 = 0
        while (i < len(type_ref.type_args)) {
            const arg_ref = type_ref.type_args[i]
            const arg_id = self.resolveType(arg_ref.*)
            arg_ids.push(arg_id)
            i = i + 1
        }

        // If no type arguments, this might be a generic definition being referenced
        if (arg_ids.len() == 0) {
            // Check if it's a registered generic definition
            if (self.reg.generic_defs.has(base_name)) {
                return self.reg.generic_defs.get(base_name)
            }
            // Otherwise treat as a named type
            return self.resolveNamedType(base_name)
        }

        // Create or retrieve a cached generic instance
        return regAddGenericInstance(self.reg, base_name, arg_ids)
    }

    // =========================================================================
    // Declaration Checking (First Pass - Collect Type Definitions)
    // =========================================================================

    fn collectDeclarations(self: TypeChecker, stmts: []*Stmt) {
        var i: i64 = 0
        while (i < len(stmts)) {
            const stmt = stmts[i].*
            switch (stmt.kind) {
                StmtKind.StructDecl => { self.collectStructDecl(stmt) }
                StmtKind.EnumDecl => { self.collectEnumDecl(stmt) }
                StmtKind.FunctionDecl => { self.collectFunctionDecl(stmt) }
                StmtKind.UnionDecl => { self.collectUnionDecl(stmt) }
                StmtKind.TraitDecl => { self.collectTraitDecl(stmt) }
                StmtKind.TypeAliasDecl => { self.collectTypeAliasDecl(stmt) }
                else => {}
            }
            i = i + 1
        }
    }

    fn collectStructDecl(self: TypeChecker, stmt: Stmt) {
        const name = stmt.struct_name

        // Check for redefinition
        if (self.struct_types.has(name)) {
            self.error(stmt.loc.line, "Struct '${name}' already defined")
            return
        }

        // Create struct type
        const struct_id = regAddStructType(self.reg, name)
        self.struct_types.set(name, struct_id)

        // Resolve and add fields
        const struct_type = regGetType(self.reg, struct_id)
        var i: i64 = 0
        while (i < len(stmt.struct_fields)) {
            const field = stmt.struct_fields[i]
            var field_type_id = self.reg.error_id
            if (field.field_type != null) {
                field_type_id = self.resolveType(field.field_type.*)
            }

            const tf = TypeField{
                .name = field.name,
                .field_type_id = field_type_id,
                .offset = i,
            }
            struct_type.struct_fields.push(tf)
            i = i + 1
        }

        // Register in global scope
        const sym = Symbol.init(name, SymbolKind.StructDef, struct_id, false, stmt.loc.line)
        self.scopes.define(name, sym)
    }

    fn collectEnumDecl(self: TypeChecker, stmt: Stmt) {
        const name = stmt.enum_name

        // Check for redefinition
        if (self.enum_types.has(name)) {
            self.error(stmt.loc.line, "Enum '${name}' already defined")
            return
        }

        // Create enum type
        const enum_id = regAddEnumType(self.reg, name)
        self.enum_types.set(name, enum_id)

        // Resolve and add variants
        const enum_type = regGetType(self.reg, enum_id)
        var i: i64 = 0
        while (i < len(stmt.enum_variants)) {
            const variant = stmt.enum_variants[i]

            // Resolve payload type if present
            var payload_type_id: i64 = -1
            if (variant.has_payload) {
                if (len(variant.payload_types) == 1) {
                    // Single payload: use that type directly
                    payload_type_id = self.resolveType(variant.payload_types[0].*)
                } else if (len(variant.payload_types) > 1) {
                    // Multiple payloads: create anonymous struct type
                    const anon_name = "${name}_${variant.name}_payload"
                    const struct_id = regAddStructType(self.reg, anon_name)
                    const struct_type = regGetType(self.reg, struct_id)
                    var j: i64 = 0
                    while (j < len(variant.payload_types)) {
                        const field_type_id = self.resolveType(variant.payload_types[j].*)
                        const tf = TypeField{
                            .name = "_${j}",  // Anonymous field names
                            .type_id = field_type_id,
                            .offset = j,
                        }
                        struct_type.struct_fields.push(tf)
                        j = j + 1
                    }
                    payload_type_id = struct_id
                } else if (len(variant.payload_fields) > 0) {
                    // Struct-style payload: create struct type with named fields
                    const anon_name = "${name}_${variant.name}_payload"
                    const struct_id = regAddStructType(self.reg, anon_name)
                    const struct_type = regGetType(self.reg, struct_id)
                    var j: i64 = 0
                    while (j < len(variant.payload_fields)) {
                        const field = variant.payload_fields[j]
                        var field_type_id = self.reg.error_id
                        if (field.field_type != null) {
                            field_type_id = self.resolveType(field.field_type.*)
                        }
                        const tf = TypeField{
                            .name = field.name,
                            .type_id = field_type_id,
                            .offset = j,
                        }
                        struct_type.struct_fields.push(tf)
                        j = j + 1
                    }
                    payload_type_id = struct_id
                }
            }

            const tv = TypeVariant{
                .name = variant.name,
                .value = i,
                .payload_type_id = payload_type_id,
            }
            enum_type.enum_variants.push(tv)

            // Register variant as EnumName.Variant
            const variant_sym = Symbol.init("${name}.${variant.name}", SymbolKind.EnumVariantDef, enum_id, false, variant.loc.line)
            self.scopes.define("${name}.${variant.name}", variant_sym)

            i = i + 1
        }

        // Register in global scope
        const sym = Symbol.init(name, SymbolKind.EnumDef, enum_id, false, stmt.loc.line)
        self.scopes.define(name, sym)
    }

    fn collectFunctionDecl(self: TypeChecker, stmt: Stmt) {
        const name = stmt.fn_name

        // Build function type
        const param_ids = new List<i64>
        var i: i64 = 0
        while (i < len(stmt.fn_params)) {
            const param = stmt.fn_params[i]
            var param_type_id = self.reg.error_id
            if (param.param_type != null) {
                param_type_id = self.resolveType(param.param_type.*)
            }
            param_ids.push(param_type_id)
            i = i + 1
        }

        var return_id = self.reg.void_id
        if (stmt.fn_return_type != null) {
            return_id = self.resolveType(stmt.fn_return_type.*)
        }

        const fn_type_id = regAddFunctionType(self.reg, param_ids, return_id)

        // Register in global scope
        const sym = Symbol.init(name, SymbolKind.FunctionDef, fn_type_id, false, stmt.loc.line)

        if (not self.scopes.define(name, sym)) {
            self.error(stmt.loc.line, "Function '${name}' already defined")
        }
    }

    fn collectUnionDecl(self: TypeChecker, stmt: Stmt) {
        const name = stmt.union_name

        // Check for redefinition
        if (self.struct_types.has(name)) {
            self.error(stmt.loc.line, "Union '${name}' already defined")
            return
        }

        // Create union type (use struct type internally, all fields share memory)
        const union_id = regAddStructType(self.reg, name)
        self.struct_types.set(name, union_id)

        // Resolve and add fields
        const union_type = regGetType(self.reg, union_id)
        var i: i64 = 0
        while (i < len(stmt.union_fields)) {
            const field = stmt.union_fields[i]
            var field_type_id = self.reg.error_id
            if (field.field_type != null) {
                field_type_id = self.resolveType(field.field_type.*)
            }

            const tf = TypeField{
                .name = field.name,
                .field_type_id = field_type_id,
                .offset = 0,  // All union fields share offset 0
            }
            union_type.struct_fields.push(tf)
            i = i + 1
        }

        // Register in global scope
        const sym = Symbol.init(name, SymbolKind.StructDef, union_id, false, stmt.loc.line)
        self.scopes.define(name, sym)
    }

    fn collectTraitDecl(self: TypeChecker, stmt: Stmt) {
        const name = stmt.trait_name

        // Check for redefinition
        if (self.traits.has(name)) {
            self.error(stmt.loc.line, "Trait '${name}' already defined")
            return
        }

        // Create trait definition and collect method signatures
        var trait_def = TraitDef.init(name)

        // Collect method signatures from trait methods
        var i: i64 = 0
        while (i < len(stmt.trait_methods)) {
            const method = stmt.trait_methods[i]
            if (method.kind == StmtKind.FunctionDecl) {
                // Build parameter type IDs
                const param_ids = new List<i64>
                var j: i64 = 0
                while (j < len(method.fn_params)) {
                    const param = method.fn_params[j]
                    var param_type_id = self.reg.error_id
                    if (param.param_type != null) {
                        param_type_id = self.resolveType(param.param_type.*)
                    }
                    param_ids.push(param_type_id)
                    j = j + 1
                }

                // Get return type
                var return_type_id = self.reg.void_id
                if (method.fn_return_type != null) {
                    return_type_id = self.resolveType(method.fn_return_type.*)
                }

                // Add method signature
                const sig = TraitMethodSig{
                    .name = method.fn_name,
                    .param_type_ids = param_ids,
                    .return_type_id = return_type_id,
                }
                trait_def.methods.push(sig)
            }
            i = i + 1
        }

        // Store trait definition
        self.traits.set(name, trait_def)

        // Register trait name in symbol table
        const sym = Symbol.init(name, SymbolKind.StructDef, self.reg.void_id, false, stmt.loc.line)
        self.scopes.define(name, sym)
    }

    fn collectTypeAliasDecl(self: TypeChecker, stmt: Stmt) {
        const name = stmt.alias_name

        // Resolve the aliased type
        var aliased_type_id = self.reg.error_id
        if (stmt.alias_type != null) {
            aliased_type_id = self.resolveType(stmt.alias_type.*)
        }

        // Register the alias in symbol table
        const sym = Symbol.init(name, SymbolKind.TypeAliasDef, aliased_type_id, false, stmt.loc.line)
        self.scopes.define(name, sym)

        // Also register in struct_types map so it can be resolved as a type
        self.struct_types.set(name, aliased_type_id)
    }

    // =========================================================================
    // Statement Checking
    // =========================================================================

    fn checkStatement(self: TypeChecker, stmt: Stmt) {
        switch (stmt.kind) {
            StmtKind.ExpressionStmt => {
                if (stmt.expr != null) {
                    self.checkExpr(stmt.expr.*)
                }
            }
            StmtKind.VarDecl => { self.checkVarDecl(stmt, true) }
            StmtKind.ConstDecl => { self.checkVarDecl(stmt, false) }
            StmtKind.ReturnStmt => { self.checkReturnStmt(stmt) }
            StmtKind.IfStmt => { self.checkIfStmt(stmt) }
            StmtKind.WhileStmt => { self.checkWhileStmt(stmt) }
            StmtKind.ForStmt => { self.checkForStmt(stmt) }
            StmtKind.BlockStmt => { self.checkBlockStmt(stmt) }
            StmtKind.FunctionDecl => { self.checkFunctionDecl(stmt) }
            StmtKind.BreakStmt => {
                if (not self.scopes.inLoop()) {
                    self.error(stmt.loc.line, "'break' outside of loop")
                }
            }
            StmtKind.ContinueStmt => {
                if (not self.scopes.inLoop()) {
                    self.error(stmt.loc.line, "'continue' outside of loop")
                }
            }
            StmtKind.SwitchStmt => { self.checkSwitchStmt(stmt) }
            StmtKind.ImplDecl => { self.checkImplDecl(stmt) }
            StmtKind.LoopStmt => { self.checkLoopStmt(stmt) }
            StmtKind.DeferStmt => { self.checkDeferStmt(stmt) }
            StmtKind.TryStmt => { self.checkTryStmt(stmt) }
            StmtKind.ThrowStmt => { self.checkThrowStmt(stmt) }
            StmtKind.TestDecl => { self.checkTestDecl(stmt) }
            StmtKind.ViewDecl => { self.checkViewDecl(stmt) }
            StmtKind.ComptimeStmt => { self.checkComptimeStmt(stmt) }
            StmtKind.ImportStmt => {}  // Handled at module level
            else => {}  // StructDecl, EnumDecl, etc. handled in first pass
        }
    }

    fn checkVarDecl(self: TypeChecker, stmt: Stmt, mutable: bool) {
        const name = stmt.var_name

        // Check for redefinition in current scope
        if (self.scopes.lookupLocal(name).valid) {
            self.error(stmt.loc.line, "Variable '${name}' already defined in this scope")
            return
        }

        // Resolve declared type (if any)
        var declared_type_id: i64 = -1
        if (stmt.var_type != null) {
            declared_type_id = self.resolveType(stmt.var_type.*)
        }

        // Check initializer
        var init_type_id = self.reg.error_id
        if (stmt.var_init != null) {
            init_type_id = self.checkExpr(stmt.var_init.*)
        }

        // Determine final type
        var final_type_id = self.reg.error_id
        if (declared_type_id >= 0) {
            final_type_id = declared_type_id
            // Check assignment compatibility
            if (stmt.var_init != null and not isErrorTypeId(self.reg, init_type_id)) {
                if (not isAssignableToById(self.reg, init_type_id, declared_type_id)) {
                    self.error(stmt.loc.line, "Cannot assign ${typeToString(self.reg, init_type_id)} to variable of type ${typeToString(self.reg, declared_type_id)}")
                }
            }
        } else if (stmt.var_init != null) {
            // Type inference
            final_type_id = init_type_id
        } else {
            self.error(stmt.loc.line, "Variable '${name}' requires type annotation or initializer")
        }

        // Register variable
        const sym = Symbol.init(name, SymbolKind.Variable, final_type_id, mutable, stmt.loc.line)
        self.scopes.define(name, sym)
    }

    fn checkReturnStmt(self: TypeChecker, stmt: Stmt) {
        // Find expected return type from enclosing function scope
        const expected_id = self.scopes.returnTypeId()

        if (stmt.return_value != null) {
            const actual_id = self.checkExpr(stmt.return_value.*)
            if (not isAssignableToById(self.reg, actual_id, expected_id)) {
                self.error(stmt.loc.line, "Return type mismatch: expected ${typeToString(self.reg, expected_id)}, got ${typeToString(self.reg, actual_id)}")
            }
        } else {
            if (expected_id != self.reg.void_id) {
                self.error(stmt.loc.line, "Return statement requires value of type ${typeToString(self.reg, expected_id)}")
            }
        }
    }

    fn checkIfStmt(self: TypeChecker, stmt: Stmt) {
        // Check condition
        if (stmt.if_cond != null) {
            const cond_type_id = self.checkExpr(stmt.if_cond.*)
            if (cond_type_id != self.reg.bool_id and not isErrorTypeId(self.reg, cond_type_id)) {
                self.error(stmt.loc.line, "If condition must be bool, got ${typeToString(self.reg, cond_type_id)}")
            }
        }

        // Check then branch
        if (stmt.if_then != null) {
            self.scopes.enterScope()
            self.checkStatement(stmt.if_then.*)
            self.scopes.exitScope()
        }

        // Check else branch
        if (stmt.if_else != null) {
            self.scopes.enterScope()
            self.checkStatement(stmt.if_else.*)
            self.scopes.exitScope()
        }
    }

    fn checkWhileStmt(self: TypeChecker, stmt: Stmt) {
        // Check condition
        if (stmt.while_cond != null) {
            const cond_type_id = self.checkExpr(stmt.while_cond.*)
            if (cond_type_id != self.reg.bool_id and not isErrorTypeId(self.reg, cond_type_id)) {
                self.error(stmt.loc.line, "While condition must be bool, got ${typeToString(self.reg, cond_type_id)}")
            }
        }

        // Check body in loop scope
        if (stmt.while_body != null) {
            self.scopes.enterLoopScope()
            self.checkStatement(stmt.while_body.*)
            self.scopes.exitScope()
        }
    }

    fn checkForStmt(self: TypeChecker, stmt: Stmt) {
        self.scopes.enterLoopScope()

        // Check iterator expression
        var element_type_id = self.reg.error_id
        if (stmt.for_iter != null) {
            const iter_type_id = self.checkExpr(stmt.for_iter.*)
            const iter_type = regGetType(self.reg, iter_type_id)

            // Infer element type from slice/array
            if (iter_type.tag == TypeTag.Slice or iter_type.tag == TypeTag.Array) {
                if (iter_type.element_type_id >= 0) {
                    element_type_id = iter_type.element_type_id
                }
            } else if (not isErrorTypeId(self.reg, iter_type_id)) {
                self.error(stmt.loc.line, "For loop requires iterable, got ${typeToString(self.reg, iter_type_id)}")
            }
        }

        // Register loop variable
        const sym = Symbol.init(stmt.for_var, SymbolKind.Variable, element_type_id, false, stmt.loc.line)
        self.scopes.define(stmt.for_var, sym)

        // Check body
        if (stmt.for_body != null) {
            self.checkStatement(stmt.for_body.*)
        }

        self.scopes.exitScope()
    }

    fn checkBlockStmt(self: TypeChecker, stmt: Stmt) {
        self.scopes.enterScope()

        var i: i64 = 0
        while (i < len(stmt.block_stmts)) {
            self.checkStatement(stmt.block_stmts[i].*)
            i = i + 1
        }

        self.scopes.exitScope()
    }

    fn checkFunctionDecl(self: TypeChecker, stmt: Stmt) {
        // Get function type (already registered)
        const fn_sym = self.scopes.lookup(stmt.fn_name)
        if (not fn_sym.valid) {
            return  // Error already reported
        }

        const fn_type_id = fn_sym.type_id
        const fn_type = regGetType(self.reg, fn_type_id)
        const return_id = fn_type.fn_return_id

        // Enter function scope
        self.scopes.enterFunctionScope(return_id)

        // Register parameters
        var i: i64 = 0
        while (i < len(stmt.fn_params)) {
            const param = stmt.fn_params[i]
            var param_type_id = self.reg.error_id
            if (i < fn_type.fn_param_ids.len()) {
                param_type_id = fn_type.fn_param_ids.get(i)
            }

            const sym = Symbol.init(param.name, SymbolKind.Parameter, param_type_id, false, param.loc.line)
            self.scopes.define(param.name, sym)
            i = i + 1
        }

        // Check body
        if (stmt.fn_body != null) {
            self.checkStatement(stmt.fn_body.*)
        }

        self.scopes.exitScope()
    }

    fn checkSwitchStmt(self: TypeChecker, stmt: Stmt) {
        // Check switch expression
        var switch_type_id = self.reg.error_id
        if (stmt.switch_expr != null) {
            switch_type_id = self.checkExpr(stmt.switch_expr.*)
        }

        // Check arms
        var has_default = false
        var i: i64 = 0
        while (i < len(stmt.switch_arms)) {
            const arm = stmt.switch_arms[i]

            if (arm.is_default) {
                if (has_default) {
                    self.error(arm.loc.line, "Multiple default arms in switch")
                }
                has_default = true
            } else if (arm.pattern != null) {
                const pattern_type_id = self.checkExpr(arm.pattern.*)
                if (not isAssignableToById(self.reg, pattern_type_id, switch_type_id) and not isErrorTypeId(self.reg, pattern_type_id)) {
                    self.error(arm.loc.line, "Pattern type ${typeToString(self.reg, pattern_type_id)} does not match switch type ${typeToString(self.reg, switch_type_id)}")
                }
            }

            // Check arm body with bindings in scope
            if (arm.body != null) {
                self.scopes.enterScope()

                // If pattern is a call-like form with bindings, add them to scope
                if (arm.pattern != null and len(arm.binding_names) > 0) {
                    self.bindPatternVariables(arm)
                }

                self.checkExpr(arm.body.*)
                self.scopes.exitScope()
            }

            i = i + 1
        }
    }

    // Bind pattern variables from switch arm (e.g., Option.Some(val) => ...)
    fn bindPatternVariables(self: TypeChecker, arm: SwitchArm) {
        if (arm.pattern == null) {
            return
        }
        const pattern = arm.pattern.*
        if (pattern.kind != ExprKind.CallExpr or pattern.callee == null) {
            return
        }

        const callee = pattern.callee.*
        if (callee.kind != ExprKind.FieldExpr or callee.object == null) {
            return
        }

        const callee_obj = callee.object.*
        const enum_name = callee_obj.name
        const variant_name = callee.field_name
        const full_name = "${enum_name}.${variant_name}"

        const maybe_sym = self.scopes.lookup(full_name)
        if (maybe_sym == null) {
            return
        }

        const sym = maybe_sym.*
        const enum_type = regGetType(self.reg, sym.type_id)

        // Find the matching variant
        var j: i64 = 0
        while (j < enum_type.enum_variants.len()) {
            const tv = enum_type.enum_variants.get(j)
            if (tv.name != variant_name or tv.payload_type_id == -1) {
                j = j + 1
                continue
            }

            // Found variant with payload - bind names
            const payload_type = regGetType(self.reg, tv.payload_type_id)

            // Multi-field payload
            var k: i64 = 0
            while (k < len(arm.binding_names) and k < payload_type.struct_fields.len()) {
                const binding = arm.binding_names[k]
                const field = payload_type.struct_fields.get(k)
                const bind_sym = Symbol.init(binding, SymbolKind.Variable, field.field_type_id, true, arm.loc.line)
                self.scopes.define(binding, bind_sym)
                k = k + 1
            }

            // Single payload (not struct)
            if (payload_type.struct_fields.len() == 0 and len(arm.binding_names) == 1) {
                const binding = arm.binding_names[0]
                const bind_sym = Symbol.init(binding, SymbolKind.Variable, tv.payload_type_id, true, arm.loc.line)
                self.scopes.define(binding, bind_sym)
            }
            return
        }
    }

    fn checkImplDecl(self: TypeChecker, stmt: Stmt) {
        // Resolve the target type
        var target_type_id = self.reg.error_id
        var type_name = ""
        if (stmt.impl_type != null) {
            const impl_ref = stmt.impl_type.*
            target_type_id = self.resolveType(impl_ref)
            type_name = impl_ref.name
        }

        if (isErrorTypeId(self.reg, target_type_id)) {
            self.error(stmt.loc.line, "Unknown type in impl block")
            return
        }

        // Check if this is a trait implementation
        var trait_name = ""
        if (stmt.impl_trait != null) {
            const trait_ref = stmt.impl_trait.*
            trait_name = trait_ref.name
        }

        // Check each method and register return types
        var i: i64 = 0
        while (i < len(stmt.impl_methods)) {
            const method = stmt.impl_methods[i]
            self.checkFunctionDecl(method.*)

            // Register method return type for method resolution
            if (type_name != "") {
                var return_type_id = self.reg.void_id
                if (method.fn_return_type != null) {
                    return_type_id = self.resolveType(method.fn_return_type.*)
                }
                const key = "${type_name}.${method.fn_name}"
                self.method_returns.set(key, return_type_id)
            }
            i += 1
        }

        // If implementing a trait, validate all required methods are present
        if (trait_name != "" and self.traits.has(trait_name)) {
            const trait_def = self.traits.get(trait_name)
            self.validateTraitImpl(stmt, trait_def)
        }
    }

    fn validateTraitImpl(self: TypeChecker, stmt: Stmt, trait_def: TraitDef) {
        // Build a map of implemented method names
        const impl_methods = new Map<string, bool>
        var i: i64 = 0
        while (i < len(stmt.impl_methods)) {
            const method = stmt.impl_methods[i]
            impl_methods.set(method.fn_name, true)
            i = i + 1
        }

        // Check each required trait method
        var j: i64 = 0
        while (j < trait_def.methods.len()) {
            const trait_method = trait_def.methods.get(j)
            if (not impl_methods.has(trait_method.name)) {
                self.error(stmt.loc.line, "Missing implementation of '${trait_method.name}' required by trait '${trait_def.name}'")
            }
            j = j + 1
        }
        // Optionally: Check method signatures match (param types and return type)
    }

    // =========================================================================
    // Expression Checking
    // =========================================================================

    fn checkExpr(self: TypeChecker, expr: Expr) i64 {
        switch (expr.kind) {
            ExprKind.IntLiteral => { return self.reg.i64_id }
            ExprKind.DecLiteral => { return self.reg.f64_id }
            ExprKind.StrLiteral => { return self.reg.string_id }
            ExprKind.BoolLiteral => { return self.reg.bool_id }
            ExprKind.NullLiteral => { return regAddOptionalType(self.reg, self.reg.void_id) }
            ExprKind.IdentifierExpr => { return self.checkIdentifier(expr) }
            ExprKind.BinaryExpr => { return self.checkBinaryExpr(expr) }
            ExprKind.UnaryExpr => { return self.checkUnaryExpr(expr) }
            ExprKind.CallExpr => { return self.checkCallExpr(expr) }
            ExprKind.FieldExpr => { return self.checkFieldExpr(expr) }
            ExprKind.IndexExpr => { return self.checkIndexExpr(expr) }
            ExprKind.StructInitExpr => { return self.checkStructInit(expr) }
            ExprKind.ArrayInitExpr => { return self.checkArrayInit(expr) }
            ExprKind.MethodCallExpr => { return self.checkMethodCallExpr(expr) }
            ExprKind.IfExpr => { return self.checkIfExpr(expr) }
            ExprKind.BlockExpr => { return self.checkBlockExpr(expr) }
            ExprKind.SwitchExpr => { return self.checkSwitchExpr(expr) }
            ExprKind.LambdaExpr => { return self.checkLambdaExpr(expr) }
            ExprKind.RangeExpr => { return self.checkRangeExpr(expr) }
            ExprKind.CastExpr => { return self.checkCastExpr(expr) }
            ExprKind.SliceExpr => { return self.checkSliceExpr(expr) }
            ExprKind.InterpStringExpr => { return self.checkInterpStringExpr(expr) }
            else => {
                self.error(expr.loc.line, "Unhandled expression kind")
                return self.reg.error_id
            }
        }
    }

    fn checkIdentifier(self: TypeChecker, expr: Expr) i64 {
        const name = expr.name

        // Look up in scope chain
        const sym = self.scopes.lookup(name)
        if (not sym.valid) {
            // Check for enum type
            if (self.enum_types.has(name)) {
                return self.enum_types.get(name)
            }

            self.error(expr.loc.line, "Undefined identifier '${name}'")
            return self.reg.error_id
        }

        return sym.type_id
    }

    fn checkBinaryExpr(self: TypeChecker, expr: Expr) i64 {
    var left_id = self.reg.error_id
    var right_id = self.reg.error_id

    if (expr.left != null) {
        left_id = self.checkExpr( expr.left.*)
    }
    if (expr.right != null) {
        right_id = self.checkExpr( expr.right.*)
    }

    // Handle error propagation
    if (isErrorTypeId(self.reg, left_id) or isErrorTypeId(self.reg, right_id)) {
        return self.reg.error_id
    }

    const left_type = regGetType(self.reg, left_id)
    const right_type = regGetType(self.reg, right_id)

    // Arithmetic: +, -, *, /, %
    if (expr.op == TokenType.Plus) {
        // String concatenation
        if (left_id == self.reg.string_id and right_id == self.reg.string_id) {
            return self.reg.string_id
        }
        // Numeric addition
        if (isNumericType(left_type) and isNumericType(right_type)) {
            return self.numericPromotion( left_type, right_type)
        }
        self.error( expr.loc.line, "Cannot add ${typeToString(self.reg, left_id)} and ${typeToString(self.reg, right_id)}")
        return self.reg.error_id
    }
    if (expr.op == TokenType.Minus) {
        if (isNumericType(left_type) and isNumericType(right_type)) {
            return self.numericPromotion( left_type, right_type)
        }
        self.error( expr.loc.line, "Cannot subtract non-numeric types")
        return self.reg.error_id
    }
    if (expr.op == TokenType.Star) {
        if (isNumericType(left_type) and isNumericType(right_type)) {
            return self.numericPromotion( left_type, right_type)
        }
        self.error( expr.loc.line, "Cannot multiply non-numeric types")
        return self.reg.error_id
    }
    if (expr.op == TokenType.Slash) {
        if (isNumericType(left_type) and isNumericType(right_type)) {
            return self.numericPromotion( left_type, right_type)
        }
        self.error( expr.loc.line, "Cannot divide non-numeric types")
        return self.reg.error_id
    }
    if (expr.op == TokenType.Percent) {
        if (isIntegerType(left_type) and isIntegerType(right_type)) {
            return self.numericPromotion( left_type, right_type)
        }
        self.error( expr.loc.line, "Modulo requires integer types")
        return self.reg.error_id
    }

    // Comparison: ==, !=, <, <=, >, >=
    if (expr.op == TokenType.EqualEqual or expr.op == TokenType.BangEqual) {
        if (typesEqualById(self.reg, left_id, right_id) or isAssignableToById(self.reg, left_id, right_id)) {
            return self.reg.bool_id
        }
        self.error( expr.loc.line, "Cannot compare ${typeToString(self.reg, left_id)} with ${typeToString(self.reg, right_id)}")
        return self.reg.error_id
    }
    if (expr.op == TokenType.Less or expr.op == TokenType.LessEqual or
        expr.op == TokenType.Greater or expr.op == TokenType.GreaterEqual) {
        if (isNumericType(left_type) and isNumericType(right_type)) {
            return self.reg.bool_id
        }
        self.error( expr.loc.line, "Comparison requires numeric types")
        return self.reg.error_id
    }

    // Logical: and, or
    if (expr.op == TokenType.KwAnd or expr.op == TokenType.KwOr) {
        if (left_id == self.reg.bool_id and right_id == self.reg.bool_id) {
            return self.reg.bool_id
        }
        self.error( expr.loc.line, "'and'/'or' requires bool operands")
        return self.reg.error_id
    }

    // Assignment: =
    if (expr.op == TokenType.Equals) {
        if (not isAssignableToById(self.reg, right_id, left_id)) {
            self.error( expr.loc.line, "Cannot assign ${typeToString(self.reg, right_id)} to ${typeToString(self.reg, left_id)}")
        }
        return left_id
    }

    self.error( expr.loc.line, "Unknown binary operator")
    return self.reg.error_id
}

    fn checkUnaryExpr(self: TypeChecker, expr: Expr) i64 {
    var operand_id = self.reg.error_id
    if (expr.operand != null) {
        operand_id = self.checkExpr( expr.operand.*)
    }

    if (isErrorTypeId(self.reg, operand_id)) {
        return self.reg.error_id
    }

    const operand_type = regGetType(self.reg, operand_id)

    if (expr.op == TokenType.Minus) {
        if (isNumericType(operand_type)) {
            return operand_id
        }
        self.error( expr.loc.line, "Cannot negate non-numeric type")
        return self.reg.error_id
    }
    if (expr.op == TokenType.Bang) {
        if (operand_id == self.reg.bool_id) {
            return self.reg.bool_id
        }
        self.error( expr.loc.line, "'not' requires bool operand")
        return self.reg.error_id
    }
    if (expr.op == TokenType.Ampersand) {
        return regAddPointerType(self.reg, operand_id)
    }
    if (expr.op == TokenType.Star) {
        if (operand_type.tag == TypeTag.Pointer and operand_type.element_type_id >= 0) {
            return operand_type.element_type_id
        }
        self.error( expr.loc.line, "Cannot dereference non-pointer type")
        return self.reg.error_id
    }

    self.error( expr.loc.line, "Unknown unary operator")
    return self.reg.error_id
}

    fn checkCallExpr(self: TypeChecker, expr: Expr) i64 {
    if (expr.callee == null) {
        return self.reg.error_id
    }

    const callee_id = self.checkExpr( expr.callee.*)

    if (isErrorTypeId(self.reg, callee_id)) {
        return self.reg.error_id
    }

    const callee_type = regGetType(self.reg, callee_id)

    // Check for enum variant construction with payload
    if (callee_type.tag == TypeTag.EnumType) {
        return self.checkEnumVariantCall(expr, callee_id)
    }

    if (callee_type.tag != TypeTag.FunctionType) {
        self.error( expr.loc.line, "Cannot call non-function type ${typeToString(self.reg, callee_id)}")
        return self.reg.error_id
    }

    // Check argument count
    const expected_count = callee_type.fn_param_ids.len()
    const actual_count = len(expr.args)

    if (actual_count != expected_count and not callee_type.fn_variadic) {
        self.error( expr.loc.line, "Expected ${expected_count} arguments, got ${actual_count}")
    }

    // Check argument types
    var i: i64 = 0
    while (i < actual_count and i < expected_count) {
        const arg_id = self.checkExpr( expr.args[i].*)
        const param_id = callee_type.fn_param_ids.get(i)
        if (not isAssignableToById(self.reg, arg_id, param_id) and not isErrorTypeId(self.reg, arg_id)) {
            self.error( expr.loc.line, "Argument ${i + 1}: expected ${typeToString(self.reg, param_id)}, got ${typeToString(self.reg, arg_id)}")
        }
        i = i + 1
    }

    // Return type
    if (callee_type.fn_return_id >= 0) {
        return callee_type.fn_return_id
    }
    return self.reg.void_id
}

    fn checkFieldExpr(self: TypeChecker, expr: Expr) i64 {
    if (expr.object == null) {
        return self.reg.error_id
    }

    const obj_id = self.checkExpr( expr.object.*)

    if (isErrorTypeId(self.reg, obj_id)) {
        return self.reg.error_id
    }

    const obj_type = regGetType(self.reg, obj_id)

    // Check for struct field
    if (obj_type.tag == TypeTag.StructType) {
        var i: i64 = 0
        while (i < obj_type.struct_fields.len()) {
            const field = obj_type.struct_fields.get(i)
            if (field.name == expr.field_name) {
                return field.field_type_id
            }
            i = i + 1
        }
        self.error( expr.loc.line, "Struct '${obj_type.struct_name}' has no field '${expr.field_name}'")
        return self.reg.error_id
    }

    // Check for pointer dereference (ptr.field -> (*ptr).field)
    if (obj_type.tag == TypeTag.Pointer and obj_type.element_type_id >= 0) {
        const inner = regGetType(self.reg, obj_type.element_type_id)
        if (inner.tag == TypeTag.StructType) {
            var i: i64 = 0
            while (i < inner.struct_fields.len()) {
                const field = inner.struct_fields.get(i)
                if (field.name == expr.field_name) {
                    return field.field_type_id
                }
                i = i + 1
            }
            self.error( expr.loc.line, "Struct '${inner.struct_name}' has no field '${expr.field_name}'")
            return self.reg.error_id
        }
    }

    // Check for enum variant (EnumType.Variant)
    if (obj_type.tag == TypeTag.EnumType) {
        var i: i64 = 0
        while (i < obj_type.enum_variants.len()) {
            const variant = obj_type.enum_variants.get(i)
            if (variant.name == expr.field_name) {
                return obj_id  // Variant has the enum type
            }
            i = i + 1
        }
        self.error( expr.loc.line, "Enum '${obj_type.enum_name}' has no variant '${expr.field_name}'")
        return self.reg.error_id
    }

    self.error( expr.loc.line, "Cannot access field on ${typeToString(self.reg, obj_id)}")
    return self.reg.error_id
}

    // Check enum variant construction: Message.Move(10, 20)
    fn checkEnumVariantCall(self: TypeChecker, expr: Expr, enum_id: i64) i64 {
        if (expr.callee == null) {
            return enum_id
        }
        const callee = expr.callee.*
        if (callee.kind != ExprKind.FieldExpr) {
            return enum_id
        }

        const variant_name = callee.field_name
        const enum_type = regGetType(self.reg, enum_id)

        // Find the matching variant
        var i: i64 = 0
        while (i < enum_type.enum_variants.len()) {
            const variant = enum_type.enum_variants.get(i)
            if (variant.name != variant_name) {
                i = i + 1
                continue
            }

            // No payload variant
            if (variant.payload_type_id == -1) {
                if (len(expr.args) > 0) {
                    self.error(expr.loc.line, "Variant '${variant_name}' takes no arguments")
                }
                return enum_id
            }

            // Check payload args
            const payload_type = regGetType(self.reg, variant.payload_type_id)
            const field_count = payload_type.struct_fields.len()

            if (field_count > 0) {
                // Multi-field payload
                self.checkPayloadArgs(expr, payload_type, variant_name)
            } else {
                // Single-value payload
                self.checkSinglePayloadArg(expr, variant.payload_type_id, variant_name)
            }
            return enum_id
        }
        return enum_id
    }

    fn checkPayloadArgs(self: TypeChecker, expr: Expr, payload_type: TypeInfo, variant_name: string) {
        const expected = payload_type.struct_fields.len()
        const actual = len(expr.args)

        if (actual != expected) {
            self.error(expr.loc.line, "Variant '${variant_name}' expects ${expected} args, got ${actual}")
            return
        }

        var i: i64 = 0
        while (i < actual) {
            const arg_id = self.checkExpr(expr.args[i].*)
            const field = payload_type.struct_fields.get(i)
            if (not isAssignableToById(self.reg, arg_id, field.field_type_id) and not isErrorTypeId(self.reg, arg_id)) {
                self.error(expr.loc.line, "Arg ${i + 1}: expected ${typeToString(self.reg, field.field_type_id)}, got ${typeToString(self.reg, arg_id)}")
            }
            i = i + 1
        }
    }

    fn checkSinglePayloadArg(self: TypeChecker, expr: Expr, payload_id: i64, variant_name: string) {
        if (len(expr.args) != 1) {
            self.error(expr.loc.line, "Variant '${variant_name}' expects 1 arg, got ${len(expr.args)}")
            return
        }
        const arg_id = self.checkExpr(expr.args[0].*)
        if (not isAssignableToById(self.reg, arg_id, payload_id) and not isErrorTypeId(self.reg, arg_id)) {
            self.error(expr.loc.line, "Expected ${typeToString(self.reg, payload_id)}, got ${typeToString(self.reg, arg_id)}")
        }
    }

    fn checkIndexExpr(self: TypeChecker, expr: Expr) i64 {
    if (expr.object == null) {
        return self.reg.error_id
    }

    const obj_id = self.checkExpr( expr.object.*)

    if (isErrorTypeId(self.reg, obj_id)) {
        return self.reg.error_id
    }

    // Check index type
    if (expr.index != null) {
        const idx_id = self.checkExpr( expr.index.*)
        const idx_type = regGetType(self.reg, idx_id)
        if (not isIntegerType(idx_type) and not isErrorTypeId(self.reg, idx_id)) {
            self.error( expr.loc.line, "Index must be integer, got ${typeToString(self.reg, idx_id)}")
        }
    }

    const obj_type = regGetType(self.reg, obj_id)

    // Get element type
    if (obj_type.tag == TypeTag.Array or obj_type.tag == TypeTag.Slice) {
        if (obj_type.element_type_id >= 0) {
            return obj_type.element_type_id
        }
        return self.reg.error_id
    }

    // String indexing returns char
    if (obj_id == self.reg.string_id) {
        return self.reg.char_id
    }

    self.error( expr.loc.line, "Cannot index ${typeToString(self.reg, obj_id)}")
    return self.reg.error_id
}

    fn checkStructInit(self: TypeChecker, expr: Expr) i64 {
    if (expr.struct_type == null) {
        return self.reg.error_id
    }

    const struct_id = self.resolveType( expr.struct_type.*)

    if (isErrorTypeId(self.reg, struct_id)) {
        return self.reg.error_id
    }

    const struct_type = regGetType(self.reg, struct_id)

    if (struct_type.tag != TypeTag.StructType) {
        self.error( expr.loc.line, "Cannot initialize non-struct type ${typeToString(self.reg, struct_id)}")
        return self.reg.error_id
    }

    // Track which fields are initialized
    const initialized = new Map<string, bool>

    // Check each field initializer
    var i: i64 = 0
    while (i < len(expr.field_inits)) {
        const init = expr.field_inits[i]
        const field_name = init.name

        // Check for duplicate
        if (initialized.has(field_name)) {
            self.error( init.loc.line, "Field '${field_name}' initialized multiple times")
            i = i + 1
            continue
        }
        initialized.set(field_name, true)

        // Find field in struct
        var found = false
        var expected_id = self.reg.error_id
        var j: i64 = 0
        while (j < struct_type.struct_fields.len()) {
            const field = struct_type.struct_fields.get(j)
            if (field.name == field_name) {
                found = true
                expected_id = field.field_type_id
                break
            }
            j = j + 1
        }

        if (not found) {
            self.error( init.loc.line, "Unknown field '${field_name}' in struct ${struct_type.struct_name}")
            i = i + 1
            continue
        }

        // Check value type
        if (init.value != null) {
            const value_id = self.checkExpr( init.value.*)
            if (not isAssignableToById(self.reg, value_id, expected_id) and not isErrorTypeId(self.reg, value_id)) {
                self.error( init.loc.line, "Field '${field_name}' expects ${typeToString(self.reg, expected_id)}, got ${typeToString(self.reg, value_id)}")
            }
        }

        i = i + 1
    }

    // Check for missing required fields
    var k: i64 = 0
    while (k < struct_type.struct_fields.len()) {
        const field = struct_type.struct_fields.get(k)
        if (not initialized.has(field.name)) {
            self.error( expr.loc.line, "Missing field '${field.name}' in struct initializer")
        }
        k = k + 1
    }

    return struct_id
}

    fn checkArrayInit(self: TypeChecker, expr: Expr) i64 {
    if (len(expr.elements) == 0) {
        // Empty array - type must be inferred from context
        return regAddSliceType(self.reg, self.reg.error_id)
    }

    // Infer element type from first element
    const first_id = self.checkExpr( expr.elements[0].*)

    // Check all elements match
    var i: i64 = 1
    while (i < len(expr.elements)) {
        const elem_id = self.checkExpr( expr.elements[i].*)
        if (not isAssignableToById(self.reg, elem_id, first_id) and not isErrorTypeId(self.reg, elem_id)) {
            self.error( expr.loc.line, "Array element type mismatch: expected ${typeToString(self.reg, first_id)}, got ${typeToString(self.reg, elem_id)}")
        }
        i = i + 1
    }

    return regAddArrayType(self.reg, first_id, len(expr.elements))
}

// =============================================================================
// Type Utilities
// =============================================================================

    fn numericPromotion(self: TypeChecker, a: TypeInfo, b: TypeInfo) i64 {
    // Float takes precedence
    if (a.tag == TypeTag.F64 or b.tag == TypeTag.F64) {
        return self.reg.f64_id
    }
    if (a.tag == TypeTag.F32 or b.tag == TypeTag.F32) {
        return self.reg.f32_id
    }

    // Larger integer wins
    if (a.tag == TypeTag.I64 or b.tag == TypeTag.I64) {
        return self.reg.i64_id
    }
    if (a.tag == TypeTag.U64 or b.tag == TypeTag.U64) {
        return self.reg.u64_id
    }
    if (a.tag == TypeTag.I32 or b.tag == TypeTag.I32) {
        return self.reg.i32_id
    }
    if (a.tag == TypeTag.U32 or b.tag == TypeTag.U32) {
        return self.reg.u32_id
    }

    // Default to i64
    return self.reg.i64_id
}

// =============================================================================
// Additional Statement Checkers
// =============================================================================

// Check infinite loop: loop { body }
    fn checkLoopStmt(self: TypeChecker, stmt: Stmt) {
    if (stmt.loop_body != null) {
        self.scopes.enterLoopScope()
        self.checkStatement( stmt.loop_body.*)
        self.scopes.exitScope()
    }
}

// Check defer statement: defer expr
    fn checkDeferStmt(self: TypeChecker, stmt: Stmt) {
    if (stmt.defer_expr != null) {
        self.checkExpr( stmt.defer_expr.*)
    }
}

// Check try/catch: try { } catch { } or try { } catch (e) { }
    fn checkTryStmt(self: TypeChecker, stmt: Stmt) {
    // Check try body
    if (stmt.try_body != null) {
        self.scopes.enterScope()
        self.checkStatement( stmt.try_body.*)
        self.scopes.exitScope()
    }

    // Check catch body
    if (stmt.catch_body != null) {
        self.scopes.enterScope()

        // If there's a catch variable, register it
        if (stmt.catch_var != "") {
            const sym = Symbol{
                .name = stmt.catch_var,
                .kind = SymbolKind.Variable,
                .type_id = self.reg.error_id,
                .mutable = false,
                .line = stmt.loc.line,
                .valid = true,
            }
            self.scopes.define( stmt.catch_var, sym)
        }

        self.checkStatement( stmt.catch_body.*)
        self.scopes.exitScope()
    }
}

// Check throw statement: throw expr
    fn checkThrowStmt(self: TypeChecker, stmt: Stmt) {
    if (stmt.throw_expr != null) {
        self.checkExpr( stmt.throw_expr.*)
        // Note: In a full implementation, we'd verify the expression is an error type
        // and track that the function can throw
    }
}

// Check test declaration: test "name" { body }
    fn checkTestDecl(self: TypeChecker, stmt: Stmt) {
    if (stmt.test_body != null) {
        self.scopes.enterScope()
        self.checkStatement( stmt.test_body.*)
        self.scopes.exitScope()
    }
}

// Check view declaration: view name: Type = @base_field
    fn checkViewDecl(self: TypeChecker, stmt: Stmt) {
    // Resolve the view type
    if (stmt.view_type != null) {
        const type_id = self.resolveType( stmt.view_type.*)

        // Register the view in symbol table
        const sym = Symbol{
            .name = stmt.view_name,
            .kind = SymbolKind.Variable,
            .type_id = type_id,
            .mutable = false,
            .line = stmt.loc.line,
            .valid = true,
        }
        self.scopes.define( stmt.view_name, sym)
    }
    // Note: In a full implementation, we'd validate that the base field exists
    // and has compatible type for the view offset
}

// Check comptime statement: comptime { } or comptime if { }
    fn checkComptimeStmt(self: TypeChecker, stmt: Stmt) {
    // For bootstrap, just type check the body normally
    // Full comptime evaluation would happen in a later phase
    if (stmt.comptime_body != null) {
        self.scopes.enterScope()
        self.checkStatement( stmt.comptime_body.*)
        self.scopes.exitScope()
    }

    // Handle comptime if
    if (stmt.comptime_cond != null) {
        self.checkExpr( stmt.comptime_cond.*)
    }
    if (stmt.comptime_else != null) {
        self.checkStatement( stmt.comptime_else.*)
    }
}

// =============================================================================
// Additional Expression Checkers
// =============================================================================

// Check method call: obj.method(args)
    fn checkMethodCallExpr(self: TypeChecker, expr: Expr) i64 {
    // Get object type
    if (expr.object == null) {
        self.error(expr.loc.line, "Method call requires object")
        return self.reg.error_id
    }
    const obj_type_id = self.checkExpr(expr.object.*)

    // Get the type name for method lookup
    const obj_type = regGetType(self.reg, obj_type_id)
    var type_name = ""
    var is_generic = false

    if (obj_type.tag == TypeTag.StructType) {
        type_name = obj_type.struct_name
    } else if (obj_type.tag == TypeTag.GenericType) {
        // Generic type instance (e.g., List<string>)
        type_name = obj_type.struct_name
        is_generic = true
    } else if (obj_type.tag == TypeTag.Pointer and obj_type.element_type_id >= 0) {
        // Handle pointer to struct: (*T).method()
        const inner = regGetType(self.reg, obj_type.element_type_id)
        if (inner.tag == TypeTag.StructType) {
            type_name = inner.struct_name
        } else if (inner.tag == TypeTag.GenericType) {
            type_name = inner.struct_name
            is_generic = true
        }
    }

    const method_name = expr.field_name

    // Check arguments
    var i: i64 = 0
    while (i < len(expr.args)) {
        self.checkExpr(expr.args[i].*)
        i += 1
    }

    // Look up method return type
    if (type_name != "") {
        const key = type_name + "." + method_name
        if (self.method_returns.has(key)) {
            const ret_type_id = self.method_returns.get(key)

            // Handle special placeholder types for generics
            if (is_generic and ret_type_id < 0) {
                // -2 = element type (first generic argument)
                // -3 = key type (for Map)
                // -4 = value type (for Map, second generic argument)
                if (ret_type_id == -2 and obj_type.generic_arg_ids.len() > 0) {
                    return obj_type.generic_arg_ids.get(0)
                } else if (ret_type_id == -3 and obj_type.generic_arg_ids.len() > 0) {
                    return obj_type.generic_arg_ids.get(0)
                } else if (ret_type_id == -4 and obj_type.generic_arg_ids.len() > 1) {
                    return obj_type.generic_arg_ids.get(1)
                }
            }

            return ret_type_id
        }
    }

    // Default to i64 for unknown methods (for bootstrap compatibility)
    return self.reg.i64_id
}

// Check if expression: if (cond) a else b
    fn checkIfExpr(self: TypeChecker, expr: Expr) i64 {
    // Check condition is bool
    if (expr.condition != null) {
        const cond_type_id = self.checkExpr( expr.condition.*)
        if (cond_type_id != self.reg.bool_id and not isErrorTypeId(self.reg, cond_type_id)) {
            self.error( expr.loc.line, "If expression condition must be bool")
        }
    }

    // Check then branch
    var then_type_id = self.reg.void_id
    if (expr.then_branch != null) {
        then_type_id = self.checkExpr( expr.then_branch.*)
    }

    // Check else branch
    var else_type_id = self.reg.void_id
    if (expr.else_branch != null) {
        else_type_id = self.checkExpr( expr.else_branch.*)
    }

    // Both branches should have compatible types
    if (then_type_id != else_type_id) {
        // Allow if one is void
        if (then_type_id != self.reg.void_id and else_type_id != self.reg.void_id) {
            self.error( expr.loc.line, "If expression branches have different types")
        }
    }

    return then_type_id
}

// Check block expression: { stmts; result }
    fn checkBlockExpr(self: TypeChecker, expr: Expr) i64 {
    self.scopes.enterScope()

    // Check all statements in block
    var i: i64 = 0
    while (i < len(expr.stmts)) {
        self.checkStatement( expr.stmts[i].*)
        i = i + 1
    }

    // Check result expression
    var result_type_id = self.reg.void_id
    if (expr.result != null) {
        result_type_id = self.checkExpr( expr.result.*)
    }

    self.scopes.exitScope()
    return result_type_id
}

// Check switch expression
    fn checkSwitchExpr(self: TypeChecker, expr: Expr) i64 {
    // Check the match expression
    if (expr.condition != null) {
        self.checkExpr( expr.condition.*)
    }

    // Check each arm - would need to look at switch_arms field
    // For bootstrap, return i64 as default
    return self.reg.i64_id
}

// Check lambda expression: |params| { body }
    fn checkLambdaExpr(self: TypeChecker, expr: Expr) i64 {
    self.scopes.enterScope()

    // Register parameters
    var i: i64 = 0
    while (i < len(expr.params)) {
        const param = expr.params[i]
        var param_type_id = self.reg.i64_id  // Default
        if (param.param_type != null) {
            param_type_id = self.resolveType( param.param_type.*)
        }

        const sym = Symbol{
            .name = param.name,
            .kind = SymbolKind.Variable,
            .type_id = param_type_id,
            .mutable = false,
            .line = expr.loc.line,
            .valid = true,
        }
        self.scopes.define( param.name, sym)
        i = i + 1
    }

    // Check body
    var return_type_id = self.reg.void_id
    if (expr.body != null) {
        return_type_id = self.checkExpr( expr.body.*)
    }

    self.scopes.exitScope()

    // Return a function type (simplified for bootstrap)
    return self.reg.i64_id  // Would create proper function type
}

// Check range expression: start..end or start..=end
    fn checkRangeExpr(self: TypeChecker, expr: Expr) i64 {
    // Check start
    if (expr.range_start != null) {
        const start_type = self.checkExpr( expr.range_start.*)
        if (not regIsIntegerType(self.reg, start_type) and not isErrorTypeId(self.reg, start_type)) {
            self.error( expr.loc.line, "Range start must be integer")
        }
    }

    // Check end
    if (expr.range_end != null) {
        const end_type = self.checkExpr( expr.range_end.*)
        if (not regIsIntegerType(self.reg, end_type) and not isErrorTypeId(self.reg, end_type)) {
            self.error( expr.loc.line, "Range end must be integer")
        }
    }

    // Return i64 for range (would be a Range type in full impl)
    return self.reg.i64_id
}

// Check cast expression: expr as Type
    fn checkCastExpr(self: TypeChecker, expr: Expr) i64 {
    // Check the source expression
    if (expr.operand != null) {
        self.checkExpr( expr.operand.*)
    }

    // Resolve the target type
    if (expr.cast_type != null) {
        const target_type_id = self.resolveType( expr.cast_type.*)
        return target_type_id
    }

    return self.reg.error_id
}

// Check slice expression: expr[start..end]
    fn checkSliceExpr(self: TypeChecker, expr: Expr) i64 {
    // Check the source expression
    var src_type_id = self.reg.error_id
    if (expr.object != null) {
        src_type_id = self.checkExpr( expr.object.*)
    }

    // Check start index
    if (expr.slice_start != null) {
        const start_type = self.checkExpr( expr.slice_start.*)
        const start_type_info = regGetType(self.reg, start_type)
        if (not isIntegerType(start_type_info) and not isErrorTypeId(self.reg, start_type)) {
            self.error( expr.loc.line, "Slice start must be integer")
        }
    }

    // Check end index
    if (expr.slice_end != null) {
        const end_type = self.checkExpr( expr.slice_end.*)
        const end_type_info = regGetType(self.reg, end_type)
        if (not isIntegerType(end_type_info) and not isErrorTypeId(self.reg, end_type)) {
            self.error( expr.loc.line, "Slice end must be integer")
        }
    }

    // Determine result type - slicing produces a slice
    if (isErrorTypeId(self.reg, src_type_id)) {
        return self.reg.error_id
    }

    const src_type = regGetType(self.reg, src_type_id)

    // Array or slice -> slice of element type
    if (src_type.tag == TypeTag.Array or src_type.tag == TypeTag.Slice) {
        return regAddSliceType(self.reg, src_type.element_type_id)
    }

    // String -> string (substring)
    if (src_type_id == self.reg.string_id) {
        return self.reg.string_id
    }

    self.error( expr.loc.line, "Cannot slice ${typeToString(self.reg, src_type_id)}")
    return self.reg.error_id
}

// Check interpolated string expression: "Hello ${name}!"
    fn checkInterpStringExpr(self: TypeChecker, expr: Expr) i64 {
    // Check all interpolated parts
    var i: i64 = 0
    while (i < len(expr.elements)) {
        self.checkExpr( expr.elements[i].*)
        i = i + 1
    }

    // Interpolated strings always produce strings
    return self.reg.string_id
}

}

// =============================================================================
// Main Entry Point
// =============================================================================

fn newTypeChecker() TypeChecker {
    return TypeChecker{
        .reg = newTypeRegistry(),
        .scopes = ScopeManager.init(),
        .struct_types = new Map<string, i64>,
        .enum_types = new Map<string, i64>,
        .traits = new Map<string, TraitDef>,
        .errors = new List<string>,
        .had_error = false,
    }
}

fn typeCheck(stmts: []*Stmt) TypeChecker {
    var tc = newTypeChecker()

    // First pass: collect type declarations
    tc.collectDeclarations(stmts)

    // Second pass: check all statements
    var i: i64 = 0
    while (i < len(stmts)) {
        tc.checkStatement(stmts[i].*)
        i = i + 1
    }

    return tc
}
