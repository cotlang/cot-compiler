// AST node definitions for the Cot self-hosted compiler
//
// Defines the abstract syntax tree structure produced by the parser.
// Uses a tagged-union style with kind enums and flat structs.

import "token"

// =============================================================================
// Statement Types
// =============================================================================

enum StmtKind {
    ExpressionStmt,     // Expression statement (e.g., function call)
    VarDecl,            // Variable declaration: var x: T = expr
    ConstDecl,          // Constant declaration: const x: T = expr
    ReturnStmt,         // Return statement: return expr
    IfStmt,             // If statement: if (cond) { } else { }
    WhileStmt,          // While loop: while (cond) { }
    ForStmt,            // For loop: for (item in iter) { }
    LoopStmt,           // Infinite loop: loop { }
    BlockStmt,          // Block: { stmts... }
    FunctionDecl,       // Function declaration: fn name(params) RetType { }
    StructDecl,         // Struct declaration: struct Name { fields }
    UnionDecl,          // Union declaration: union Name { fields }
    EnumDecl,           // Enum declaration: enum Name { variants }
    ImplDecl,           // Impl block: impl Type { methods }
    ImportStmt,         // Import statement: import "module"
    BreakStmt,          // Break statement
    ContinueStmt,       // Continue statement
    SwitchStmt,         // Switch statement: switch (expr) { arms }
    TraitDecl,          // Trait declaration
    TypeAliasDecl,      // Type alias: type Name = Type
    DeferStmt,          // Defer statement: defer cleanup()
    TryStmt,            // Try/catch: try { } catch { }
    ThrowStmt,          // Throw: throw expr
    TestDecl,           // Test declaration: test "name" { }
    ViewDecl,           // View declaration: view name: Type = @base_field
    ComptimeStmt,       // Comptime block: comptime { } or comptime if { }
}

impl StmtKind {
    // Check if this is a declaration statement
    fn isDeclaration(self: StmtKind) bool {
        return self == StmtKind.VarDecl or self == StmtKind.ConstDecl or
               self == StmtKind.FunctionDecl or self == StmtKind.StructDecl or
               self == StmtKind.UnionDecl or self == StmtKind.EnumDecl or
               self == StmtKind.TraitDecl or self == StmtKind.TypeAliasDecl or
               self == StmtKind.ViewDecl
    }

    // Check if this is a control flow statement
    fn isControlFlow(self: StmtKind) bool {
        return self == StmtKind.IfStmt or self == StmtKind.WhileStmt or
               self == StmtKind.ForStmt or self == StmtKind.LoopStmt or
               self == StmtKind.SwitchStmt or self == StmtKind.TryStmt
    }

    // Check if this is a jump statement
    fn isJump(self: StmtKind) bool {
        return self == StmtKind.ReturnStmt or self == StmtKind.BreakStmt or
               self == StmtKind.ContinueStmt or self == StmtKind.ThrowStmt
    }

    // Get human-readable name
    fn name(self: StmtKind) string {
        switch (self) {
            StmtKind.ExpressionStmt => { return "expression" }
            StmtKind.VarDecl => { return "var" }
            StmtKind.ConstDecl => { return "const" }
            StmtKind.ReturnStmt => { return "return" }
            StmtKind.IfStmt => { return "if" }
            StmtKind.WhileStmt => { return "while" }
            StmtKind.ForStmt => { return "for" }
            StmtKind.LoopStmt => { return "loop" }
            StmtKind.BlockStmt => { return "block" }
            StmtKind.FunctionDecl => { return "fn" }
            StmtKind.StructDecl => { return "struct" }
            StmtKind.UnionDecl => { return "union" }
            StmtKind.EnumDecl => { return "enum" }
            StmtKind.ImplDecl => { return "impl" }
            StmtKind.ImportStmt => { return "import" }
            StmtKind.BreakStmt => { return "break" }
            StmtKind.ContinueStmt => { return "continue" }
            StmtKind.SwitchStmt => { return "switch" }
            StmtKind.TraitDecl => { return "trait" }
            StmtKind.TypeAliasDecl => { return "type" }
            StmtKind.DeferStmt => { return "defer" }
            StmtKind.TryStmt => { return "try" }
            StmtKind.ThrowStmt => { return "throw" }
            StmtKind.TestDecl => { return "test" }
            StmtKind.ViewDecl => { return "view" }
            StmtKind.ComptimeStmt => { return "comptime" }
            else => { return "unknown" }
        }
    }
}

// =============================================================================
// Expression Types
// =============================================================================

enum ExprKind {
    // Literals
    IntLiteral,     // Integer: 42, 0xFF, 0b1010
    DecLiteral,     // Decimal: 3.14
    StrLiteral,     // String: "hello"
    BoolLiteral,    // Boolean: true, false
    NullLiteral,    // Null: null

    // Names and access
    IdentifierExpr, // Variable/function name
    FieldExpr,      // Field access: expr.field
    IndexExpr,      // Index access: expr[index]

    // Operators
    BinaryExpr,     // Binary op: a + b, a == b
    UnaryExpr,      // Unary op: -x, !x, &x, x.*

    // Calls and construction
    CallExpr,       // Function call: fn(args)
    MethodCallExpr, // Method call: obj.method(args)
    StructInitExpr, // Struct init: Type{ .field = val }
    ArrayInitExpr,  // Array init: [1, 2, 3]

    // Control flow expressions
    IfExpr,         // If expression: if (c) a else b
    BlockExpr,      // Block expression: { stmts; expr }
    SwitchExpr,     // Switch expression

    // Other
    LambdaExpr,     // Lambda: |args| expr
    RangeExpr,      // Range: start..end
    CastExpr,       // Type cast: expr as Type
    SliceExpr,      // Slice: expr[start..end]
    InterpStringExpr, // Interpolated string: "Hello ${name}!"
}

impl ExprKind {
    // Check if this is a literal expression
    fn isLiteral(self: ExprKind) bool {
        return self == ExprKind.IntLiteral or self == ExprKind.DecLiteral or
               self == ExprKind.StrLiteral or self == ExprKind.BoolLiteral or
               self == ExprKind.NullLiteral
    }

    // Check if this is an lvalue (can appear on left of assignment)
    fn isLValue(self: ExprKind) bool {
        return self == ExprKind.IdentifierExpr or self == ExprKind.FieldExpr or
               self == ExprKind.IndexExpr
    }

    // Check if this requires sub-expressions
    fn hasChildren(self: ExprKind) bool {
        return !(self == ExprKind.IntLiteral or self == ExprKind.DecLiteral or
                 self == ExprKind.StrLiteral or self == ExprKind.BoolLiteral or
                 self == ExprKind.NullLiteral or self == ExprKind.IdentifierExpr)
    }

    // Get human-readable name
    fn name(self: ExprKind) string {
        switch (self) {
            ExprKind.IntLiteral => { return "integer" }
            ExprKind.DecLiteral => { return "decimal" }
            ExprKind.StrLiteral => { return "string" }
            ExprKind.BoolLiteral => { return "bool" }
            ExprKind.NullLiteral => { return "null" }
            ExprKind.IdentifierExpr => { return "identifier" }
            ExprKind.FieldExpr => { return "field" }
            ExprKind.IndexExpr => { return "index" }
            ExprKind.BinaryExpr => { return "binary" }
            ExprKind.UnaryExpr => { return "unary" }
            ExprKind.CallExpr => { return "call" }
            ExprKind.MethodCallExpr => { return "method_call" }
            ExprKind.StructInitExpr => { return "struct_init" }
            ExprKind.ArrayInitExpr => { return "array_init" }
            ExprKind.IfExpr => { return "if" }
            ExprKind.BlockExpr => { return "block" }
            ExprKind.SwitchExpr => { return "switch" }
            ExprKind.LambdaExpr => { return "lambda" }
            ExprKind.RangeExpr => { return "range" }
            ExprKind.CastExpr => { return "cast" }
            ExprKind.SliceExpr => { return "slice" }
            ExprKind.InterpStringExpr => { return "interp_string" }
            else => { return "unknown" }
        }
    }
}

// =============================================================================
// Type Reference Types
// =============================================================================

enum TypeKind {
    Named,          // Named type: i64, String, MyStruct
    Pointer,        // Pointer: *T
    Optional,       // Optional: ?T
    Array,          // Array: [N]T
    Slice,          // Slice: []T
    Function,       // Function type: fn(A, B) -> C
    Generic,        // Generic instantiation: Vec[T]
    Inferred,       // Type to be inferred: _
}

impl TypeKind {
    // Check if this type has an inner type
    fn hasInner(self: TypeKind) bool {
        return self == TypeKind.Pointer or self == TypeKind.Optional or
               self == TypeKind.Array or self == TypeKind.Slice
    }

    // Check if this is a compound type
    fn isCompound(self: TypeKind) bool {
        return self == TypeKind.Array or self == TypeKind.Slice or
               self == TypeKind.Function or self == TypeKind.Generic
    }

    // Get human-readable name
    fn name(self: TypeKind) string {
        switch (self) {
            TypeKind.Named => { return "named" }
            TypeKind.Pointer => { return "pointer" }
            TypeKind.Optional => { return "optional" }
            TypeKind.Array => { return "array" }
            TypeKind.Slice => { return "slice" }
            TypeKind.Function => { return "function" }
            TypeKind.Generic => { return "generic" }
            TypeKind.Inferred => { return "inferred" }
            else => { return "unknown" }
        }
    }
}

// =============================================================================
// AST Node Structs
// =============================================================================

// Source location for error reporting
struct SourceLoc {
    line: i64,
    column: i64,
    start: i64,
    end: i64,
}

impl SourceLoc {
    // Create a new source location
    fn init(line: i64, column: i64, start: i64, end: i64) SourceLoc {
        return SourceLoc{
            .line = line,
            .column = column,
            .start = start,
            .end = end,
        }
    }

    // Create source location from a token
    fn fromToken(tok: Token) SourceLoc {
        return SourceLoc{
            .line = tok.line,
            .column = tok.column,
            .start = tok.span.start,
            .end = tok.span.end,
        }
    }

    // Create a zero location (for synthetic nodes)
    fn zero() SourceLoc {
        return SourceLoc{
            .line = 0,
            .column = 0,
            .start = 0,
            .end = 0,
        }
    }

    // Format as "line:column" string
    fn display(self: SourceLoc) string {
        return str(self.line) + ":" + str(self.column)
    }
}

// Module - top-level container for all parsed statements
struct Module {
    statements: List<*Stmt>,
    errors: List<string>,
    has_errors: bool,
}

impl Module {
    // Create a new empty module
    fn init() Module {
        var stmts = new List<*Stmt>
        var errs = new List<string>
        return Module{
            .statements = stmts,
            .errors = errs,
            .has_errors = false,
        }
    }

    // Add a statement to the module
    fn addStatement(self: *Module, stmt: *Stmt) {
        self.statements.push(stmt)
    }

    // Mark the module as having errors
    fn markError(self: *Module) {
        self.has_errors = true
    }

    // Add an error message
    fn addError(self: *Module, msg: string) {
        self.errors.push(msg)
        self.has_errors = true
    }

    // Get the number of statements
    fn stmtCount(self: *Module) i64 {
        return self.statements.len()
    }
}

// Type reference node
struct TypeRef {
    kind: TypeKind,
    loc: SourceLoc,

    // Named type
    name: string,

    // Pointer, Optional, Array, Slice - inner type
    inner: ?*TypeRef,

    // Array size (for fixed arrays)
    array_size: i64,

    // Function type
    param_types: []*TypeRef,
    return_type: ?*TypeRef,

    // Generic type arguments
    type_args: []*TypeRef,
}

// Expression node
struct Expr {
    kind: ExprKind,
    loc: SourceLoc,

    // Literals
    int_value: i64,
    dec_value: string,      // Keep as string to preserve precision
    str_value: string,
    bool_value: bool,

    // Identifier
    name: string,

    // Binary/Unary operators
    op: TokenType,
    left: ?*Expr,
    right: ?*Expr,
    operand: ?*Expr,

    // Call
    callee: ?*Expr,
    args: []*Expr,

    // Field/Index access
    object: ?*Expr,
    field_name: string,
    index: ?*Expr,

    // Struct init
    struct_type: ?*TypeRef,
    field_inits: []FieldInit,

    // Array init
    elements: []*Expr,

    // If expression
    condition: ?*Expr,
    then_branch: ?*Expr,
    else_branch: ?*Expr,

    // Block expression
    stmts: []*Stmt,
    result: ?*Expr,

    // Lambda
    params: []Param,
    body: ?*Expr,

    // Range
    range_start: ?*Expr,
    range_end: ?*Expr,
    range_inclusive: bool,

    // Cast
    cast_type: ?*TypeRef,

    // Slice
    slice_start: ?*Expr,
    slice_end: ?*Expr,

    // Switch expression
    switch_expr: ?*Expr,
    switch_arms: []SwitchArm,
}

// Statement node
struct Stmt {
    kind: StmtKind,
    loc: SourceLoc,

    // Expression statement
    expr: ?*Expr,

    // Var/Const declaration
    var_name: string,
    var_type: ?*TypeRef,
    var_init: ?*Expr,
    var_mutable: bool,

    // Return
    return_value: ?*Expr,

    // If statement
    if_cond: ?*Expr,
    if_then: ?*Stmt,
    if_else: ?*Stmt,

    // While loop
    while_cond: ?*Expr,
    while_body: ?*Stmt,

    // For loop
    for_var: string,
    for_iter: ?*Expr,
    for_body: ?*Stmt,

    // Block
    block_stmts: []*Stmt,

    // Function
    fn_name: string,
    fn_params: []Param,
    fn_return_type: ?*TypeRef,
    fn_body: ?*Stmt,
    fn_public: bool,

    // Struct
    struct_name: string,
    struct_fields: []Field,

    // Enum
    enum_name: string,
    enum_variants: []EnumVariant,

    // Impl
    impl_type: ?*TypeRef,
    impl_trait: ?*TypeRef,
    impl_methods: []*Stmt,

    // Import
    import_path: string,

    // Switch
    switch_expr: ?*Expr,
    switch_arms: []SwitchArm,

    // TypeAlias
    alias_name: string,
    alias_type: ?*TypeRef,

    // Loop (infinite)
    loop_body: ?*Stmt,

    // Union (same structure as struct)
    union_name: string,
    union_fields: []Field,

    // Defer
    defer_expr: ?*Expr,

    // Try/Catch
    try_body: ?*Stmt,
    catch_body: ?*Stmt,
    catch_var: string,          // Optional error binding variable

    // Throw
    throw_expr: ?*Expr,

    // Test
    test_name: string,
    test_body: ?*Stmt,

    // View
    view_name: string,
    view_type: ?*TypeRef,
    view_base_field: string,
    view_offset: i64,

    // Trait
    trait_name: string,
    trait_methods: []*Stmt,

    // Comptime
    comptime_body: ?*Stmt,
    comptime_cond: ?*Expr,     // For comptime if
    comptime_else: ?*Stmt,     // For comptime if else branch
}

// =============================================================================
// Supporting Structs
// =============================================================================

// Function/method parameter
struct Param {
    name: string,
    param_type: ?*TypeRef,
    loc: SourceLoc,
}

// Struct field
struct Field {
    name: string,
    field_type: ?*TypeRef,
    loc: SourceLoc,
}

// Struct field initializer
struct FieldInit {
    name: string,
    value: ?*Expr,
    loc: SourceLoc,
}

// Enum variant
struct EnumVariant {
    name: string,
    value: ?*Expr,           // Optional explicit value (e.g., Foo = 1)
    loc: SourceLoc,
    // Sum type payloads
    payload_types: []*TypeRef,   // Tuple payload: Some(i64) -> [i64]
    payload_fields: []Field,     // Struct payload: Ok { value: i64 } -> [Field{name="value", type=i64}]
    has_payload: bool,           // True if this variant has any payload
}

// Switch arm
struct SwitchArm {
    pattern: ?*Expr,         // Pattern to match (or null for default)
    body: ?*Expr,            // Body expression
    is_default: bool,
    loc: SourceLoc,
    // Pattern binding for sum type payloads
    binding_names: []string, // Variable names bound from payload: Some(val) => bindings=["val"]
}

// =============================================================================
// Traits
// =============================================================================

// Trait for types that can produce a display string
trait Display {
    fn display(self: *Self) string
}

// Trait for AST nodes with location information
trait Located {
    fn location(self: *Self) SourceLoc
}

// =============================================================================
// Trait Implementations
// =============================================================================

// NOTE: Trait implementations commented out pending trait system improvements
// impl Display for SourceLoc {
//     fn display(self: *SourceLoc) string {
//         return str(self.line) + ":" + str(self.column)
//     }
// }

// impl Located for Expr {
//     fn location(self: *Expr) SourceLoc {
//         return self.loc
//     }
// }

// impl Located for Stmt {
//     fn location(self: *Stmt) SourceLoc {
//         return self.loc
//     }
// }

// impl Located for TypeRef {
//     fn location(self: *TypeRef) SourceLoc {
//         return self.loc
//     }
// }

// =============================================================================
// Expr Impl Block
// =============================================================================

impl Expr {
    // Create a new expression of the given kind at the given location
    fn init(kind: ExprKind, loc: SourceLoc) Expr {
        return Expr{
            .kind = kind,
            .loc = loc,
            .int_value = 0,
            .dec_value = "",
            .str_value = "",
            .bool_value = false,
            .name = "",
            .op = TokenType.Eof,
            .left = null,
            .right = null,
            .operand = null,
            .callee = null,
            .args = [],
            .object = null,
            .field_name = "",
            .index = null,
            .struct_type = null,
            .field_inits = [],
            .elements = [],
            .condition = null,
            .then_branch = null,
            .else_branch = null,
            .stmts = [],
            .result = null,
            .params = [],
            .body = null,
            .range_start = null,
            .range_end = null,
            .range_inclusive = false,
            .cast_type = null,
            .slice_start = null,
            .slice_end = null,
            .switch_expr = null,
            .switch_arms = [],
        }
    }
}

// =============================================================================
// Stmt Impl Block
// =============================================================================

impl Stmt {
    // Create a new statement of the given kind at the given location
    fn init(kind: StmtKind, loc: SourceLoc) Stmt {
        return Stmt{
            .kind = kind,
            .loc = loc,
            .expr = null,
            .var_name = "",
            .var_type = null,
            .var_init = null,
            .var_mutable = false,
            .return_value = null,
            .if_cond = null,
            .if_then = null,
            .if_else = null,
            .while_cond = null,
            .while_body = null,
            .for_var = "",
            .for_iter = null,
            .for_body = null,
            .block_stmts = [],
            .fn_name = "",
            .fn_params = [],
            .fn_return_type = null,
            .fn_body = null,
            .fn_public = false,
            .struct_name = "",
            .struct_fields = [],
            .enum_name = "",
            .enum_variants = [],
            .impl_type = null,
            .impl_trait = null,
            .impl_methods = [],
            .import_path = "",
            .switch_expr = null,
            .switch_arms = [],
            .alias_name = "",
            .alias_type = null,
            .loop_body = null,
            .union_name = "",
            .union_fields = [],
            .defer_expr = null,
            .try_body = null,
            .catch_body = null,
            .catch_var = "",
            .throw_expr = null,
            .test_name = "",
            .test_body = null,
            .view_name = "",
            .view_type = null,
            .view_base_field = "",
            .view_offset = 0,
            .trait_name = "",
            .trait_methods = [],
            .comptime_body = null,
            .comptime_cond = null,
            .comptime_else = null,
        }
    }
}

// =============================================================================
// TypeRef Impl Block
// =============================================================================

impl TypeRef {
    // Create a new type reference of the given kind
    fn init(kind: TypeKind, loc: SourceLoc) TypeRef {
        return TypeRef{
            .kind = kind,
            .loc = loc,
            .name = "",
            .inner = null,
            .array_size = 0,
            .param_types = [],
            .return_type = null,
            .type_args = [],
        }
    }

    // Create a named type
    fn named(n: string, loc: SourceLoc) TypeRef {
        var t: TypeRef = TypeRef.init(TypeKind.Named, loc)
        t.name = n
        return t
    }

    // Create a pointer type
    fn pointer(inner: *TypeRef, loc: SourceLoc) TypeRef {
        var t: TypeRef = TypeRef.init(TypeKind.Pointer, loc)
        t.inner = inner
        return t
    }

    // Create an optional type
    fn optional(inner: *TypeRef, loc: SourceLoc) TypeRef {
        var t: TypeRef = TypeRef.init(TypeKind.Optional, loc)
        t.inner = inner
        return t
    }
}

// =============================================================================
// Arena Allocation Infrastructure
// =============================================================================

// Global arenas for AST node allocation
var g_expr_arena = new List<Expr>
var g_stmt_arena = new List<Stmt>
var g_typeref_arena = new List<TypeRef>

// Allocate an expression in the arena and return a pointer
fn allocExpr(e: Expr) *Expr {
    g_expr_arena.push(e)
    return g_expr_arena.getPtr(g_expr_arena.len() - 1)
}

// Allocate a statement in the arena and return a pointer
fn allocStmt(s: Stmt) *Stmt {
    g_stmt_arena.push(s)
    return g_stmt_arena.getPtr(g_stmt_arena.len() - 1)
}

// Allocate a type reference in the arena and return a pointer
fn allocTypeRef(t: TypeRef) *TypeRef {
    g_typeref_arena.push(t)
    return g_typeref_arena.getPtr(g_typeref_arena.len() - 1)
}

// Clear all arenas (for starting fresh parse)
fn clearArenas() {
    g_expr_arena = new List<Expr>
    g_stmt_arena = new List<Stmt>
    g_typeref_arena = new List<TypeRef>
}

// Get arena statistics
fn arenaStats() string {
    return "Exprs: " + str(g_expr_arena.len()) +
           ", Stmts: " + str(g_stmt_arena.len()) +
           ", TypeRefs: " + str(g_typeref_arena.len())
}
