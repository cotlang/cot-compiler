// Cot Self-Hosted Compiler Driver
//
// Usage: cot-compiler compile <source.cot> [-o <output.cbo>]
//
// This driver orchestrates the compilation pipeline:
// 1. Parse command-line arguments
// 2. Load source file and all imports (multi-file support)
// 3. Type checking
// 4. AST -> IR lowering
// 5. IR -> Bytecode emission
// 6. Write bytecode to output file

import "token"
import "lexer"
import "ast"
import "parser"
import "types"
import "type_checker"
import "ir"
import "lower"
import "emit"
import "module"

fn main() i64 {
    println("[driver] Starting main...")
    // Get command-line arguments
    var args = process_args()

    // Find "compile" command in args (handles: driver.cbo compile foo.cot
    // or: cot trace driver.cbo -- compile foo.cot)
    var compile_idx: i64 = -1
    var i: i64 = 0
    while (i < args.len()) {
        if (args.get(i) == "compile") {
            compile_idx = i
        }
        i += 1
    }

    if (compile_idx < 0 or compile_idx + 1 >= args.len()) {
        printUsage()
        return 1
    }

    // Get source file (next arg after "compile")
    var source_file = args.get(compile_idx + 1)

    // Get output file (check remaining args for -o flag)
    var output_file = getOutputPathFrom(source_file, args, compile_idx + 2)

    println("[driver] === Cot Self-Hosted Compiler ===")
    println("[driver] Source: " + source_file)
    println("[driver] Output: " + output_file)
    println("[driver]")

    // Phase 1: Load all modules (parse source and imports)
    println("[driver] === Phase 1: Loading Modules ===")

    // Get base directory from source file path
    println("[driver] about to call dirname...")
    var base_dir = dirname(source_file)
    println("[driver] base_dir: " + base_dir)
    println("[driver] about to create cache...")
    var cache = ModuleCache.create(base_dir)
    println("[driver] cache created")

    // Get just the module name (without path and extension)
    println("[driver] about to call getModuleName...")
    var module_name = getModuleName(source_file)
    println("[driver] module_name: " + module_name)

    // Load root module and all dependencies
    if (!cache.loadWithDeps(module_name)) {
        println("[driver] Error loading modules:")
        var i: i64 = 0
        while (i < cache.errors.len()) {
            println("[driver]   " + cache.errors.get(i))
            i += 1
        }
        return 1
    }

    println("[driver]   Loaded " + string(cache.count()) + " module(s)")

    // Get compile order (dependencies first)
    var order = cache.getCompileOrder()

    if (cache.errors.len() > 0) {
        println("[driver] Import errors:")
        var i: i64 = 0
        while (i < cache.errors.len()) {
            println("[driver]   " + cache.errors.get(i))
            i += 1
        }
        return 1
    }

    // Collect all statements from all modules (in dependency order)
    var all_stmts = new List<*Stmt>
    var mod_idx: i64 = 0
    while (mod_idx < order.len()) {
        var path = order.get(mod_idx)
        // Get module and collect its non-import statements
        collectModuleStatements(cache, path, all_stmts)
        mod_idx += 1
    }

    println("[driver]   Collected " + string(all_stmts.len()) + " statements")

    // Phase 2: Type Check
    println("[driver]")
    println("[driver] === Phase 2: Type Checking ===")
    var stmts = all_stmts.to_slice()
    var tc = typeCheck(stmts)

    if (tc.had_error) {
        println("Type errors:")
        var i: i64 = 0
        while (i < tc.errors.len()) {
            println("  " + tc.errors.get(i))
            i += 1
        }
        return 1
    }

    println("  Type check passed")

    // Phase 3: Lower to IR
    println("")
    println("=== Phase 3: Lowering to IR ===")
    var lowerer = newLowerer(tc.reg)
    lowerModule(lowerer, stmts)

    if (lowerer.had_error) {
        println("Lowering errors:")
        var i: i64 = 0
        while (i < lowerer.errors.len()) {
            println("  " + lowerer.errors.get(i))
            i += 1
        }
        return 1
    }

    println("  Lowered " + string(lowerer.module.functions.len()) + " functions")

    // Phase 4: Emit bytecode
    println("")
    println("=== Phase 4: Emitting Bytecode ===")
    var emitter = newBytecodeEmitter()

    // Find main function for entry point
    var entry_point: i64 = -1
    var fn_idx: i64 = 0
    while (fn_idx < lowerer.module.functions.len()) {
        var func = lowerer.module.functions.get(fn_idx)
        if (func.name == "main") {
            entry_point = fn_idx
        }
        fn_idx += 1
    }

    if (entry_point < 0) {
        println("Warning: No main() function found")
    }

    // Build the bytecode module
    var bytecode = emitBuildModule(emitter, entry_point, 0)
    println("  Generated " + string(bytecode.len()) + " bytes of bytecode")

    // Phase 5: Write output
    println("")
    println("=== Phase 5: Writing Output ===")
    var success = write_bytes(output_file, bytecode)

    if (success) {
        println("  Wrote " + output_file)
        println("")
        println("Compilation successful!")
        return 0
    } else {
        println("Error: Failed to write " + output_file)
        return 1
    }
}

fn printUsage() {
    println("Usage: cot-compiler compile <source.cot> [-o <output.cbo>]")
    println("")
    println("Commands:")
    println("  compile    Compile source file to bytecode")
    println("")
    println("Options:")
    println("  -o <file>  Output file (default: <source>.cbo)")
}

fn getOutputPathFrom(source_file: string, args: List<string>, start_idx: i64) string {
    // Check for -o flag starting from start_idx
    var i: i64 = start_idx
    while (i < args.len()) {
        if (args.get(i) == "-o" and i + 1 < args.len()) {
            return args.get(i + 1)
        }
        i += 1
    }

    // Default: replace .cot with .cbo
    if (len(source_file) > 4) {
        var ext = source_file[len(source_file) - 4..len(source_file)]
        if (ext == ".cot") {
            return source_file[0..len(source_file) - 4] + ".cbo"
        }
    }

    return source_file + ".cbo"
}

// Collect statements from a module, skipping import statements
fn collectModuleStatements(cache: *ModuleCache, path: string, stmts: *List<*Stmt>) {
    var idx = cache.getIndex(path)
    if (idx < 0) {
        return
    }
    var mod = cache.modules.get(idx)
    var stmt_idx: i64 = 0
    while (stmt_idx < mod.statements.len()) {
        var stmt = mod.statements.get(stmt_idx)
        if (stmt.kind != StmtKind.ImportStmt) {
            stmts.push(stmt)
        }
        stmt_idx += 1
    }
}

// Get the module name from a file path (strip directory and .cot extension)
fn getModuleName(path: string) string {
    // Find last slash
    var start: i64 = 0
    var i: i64 = 0
    while (i < len(path)) {
        var ch = path[i..i + 1]
        if (ch == "/") {
            start = i + 1
        }
        i += 1
    }

    // Find .cot extension
    var end_pos = len(path)
    if (len(path) > 4) {
        var ext = path[len(path) - 4..len(path)]
        if (ext == ".cot") {
            end_pos = len(path) - 4
        }
    }

    return path[start..end_pos]
}
