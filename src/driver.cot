// Cot Self-Hosted Compiler Driver
//
// Usage: cot-compiler compile <source.cot> [-o <output.cbo>]
//
// This driver orchestrates the compilation pipeline:
// 1. Parse command-line arguments
// 2. Load source file and all imports (multi-file support)
// 3. Type checking
// 4. AST -> IR lowering
// 5. IR -> Bytecode emission
// 6. Write bytecode to output file

import "token"
import "lexer"
import "ast"
import "parser"
import "types"
import "type_checker"
import "ir"
import "lower"
import "emit"
import "module"
import "opcodes"
import "asm_arm64"
import "emit_native"
import "object_macho"

fn main() i64 {
    // Get command-line arguments
    var args = process_args()

    // Find "compile" command in args (handles: driver.cbo compile foo.cot
    // or: cot trace driver.cbo -- compile foo.cot)
    var compile_idx: i64 = -1
    var i: i64 = 0
    while (i < args.len()) {
        if (args.get(i) == "compile") {
            compile_idx = i
        }
        i += 1
    }

    if (compile_idx < 0 or compile_idx + 1 >= args.len()) {
        printUsage()
        return 1
    }

    // Get source file (next arg after "compile")
    var source_file = args.get(compile_idx + 1)

    // Check for --native flag
    var use_native = hasFlag(args, "--native")

    // Get output file (check remaining args for -o flag)
    var output_file = getOutputPathFrom(source_file, args, compile_idx + 2, use_native)

    // Phase 1: Load all modules (parse source and imports)
    var base_dir = dirname(source_file)
    var cache = ModuleCache.create(base_dir)
    var module_name = getModuleName(source_file)

    // Load root module and all dependencies
    println("DEBUG: Loading module: " + module_name + " from base_dir: " + base_dir)
    if (!cache.loadWithDeps(module_name)) {
        println("Error loading modules:")
        var i: i64 = 0
        while (i < cache.errors.len()) {
            println("  " + cache.errors.get(i))
            i += 1
        }
        return 1
    }

    // Get compile order (dependencies first)
    var order = cache.getCompileOrder()

    println("DEBUG: Compile order (" + string(order.len()) + " modules):")
    var debug_i: i64 = 0
    while (debug_i < order.len()) {
        println("  " + string(debug_i) + ": " + order.get(debug_i))
        debug_i += 1
    }

    if (cache.errors.len() > 0) {
        println("Import errors:")
        var i: i64 = 0
        while (i < cache.errors.len()) {
            println("  " + cache.errors.get(i))
            i += 1
        }
        return 1
    }

    // Collect all statements from all modules (in dependency order)
    var all_stmts = new List<*Stmt>
    var mod_idx: i64 = 0
    while (mod_idx < order.len()) {
        var path = order.get(mod_idx)
        // Get module and collect its non-import statements
        collectModuleStatements(cache, path, all_stmts)
        mod_idx += 1
    }

    // Phase 2: Type Check
    var stmts = all_stmts.to_slice()
    var tc = typeCheck(stmts)

    if (tc.had_error) {
        println("Type errors:")
        var i: i64 = 0
        while (i < tc.errors.len()) {
            println("  " + tc.errors.get(i))
            i += 1
        }
        return 1
    }

    // Phase 3: Lower to IR
    var lowerer = newLowerer(tc.reg)
    lowerModule(lowerer, stmts)

    if (lowerer.had_error) {
        println("Lowering errors:")
        var i: i64 = 0
        while (i < lowerer.errors.len()) {
            println("  " + lowerer.errors.get(i))
            i += 1
        }
        return 1
    }

    // Phase 4: Emit bytecode
    var emitter = newBytecodeEmitter()

    // Find main function for entry point
    var entry_point: i64 = -1
    var fn_idx: i64 = 0
    while (fn_idx < lowerer.module.functions.len()) {
        var func = lowerer.module.functions.get(fn_idx)
        if (func.name == "main") {
            entry_point = fn_idx
        }
        fn_idx += 1
    }

    // Build the bytecode module
    var bytecode = emitBuildModule(emitter, entry_point, 0)

    // Phase 5: Native compilation (if requested) or write bytecode
    if (use_native) {

        // Create native compiler and feed it bytecode
        var nc = NativeCompiler.init()

        // Transfer bytecode to native compiler
        var bc_idx: i64 = 0
        while (bc_idx < bytecode.len()) {
            nc.addBytecode(bytecode.get(bc_idx))
            bc_idx += 1
        }

        // Add routine info (main at entry_point)
        // For now, treat entire bytecode as one routine
        nc.addRoutine("_main", 0, bytecode.len(), 16)

        // Compile to native
        nc.compile()

        // Get native code
        var native_code = nc.getCode()

        // Build Mach-O object file
        var macho = MachOBuilder.create()

        // Set text section with code
        macho.setTextCode(native_code)

        // Add _main symbol (section 1 = __text, offset 0, external)
        macho.addSymbol("_main", 1, 0, true)

        // Build object file
        var object_data = macho.build()

        // Write output
        var success = write_bytes(output_file, object_data)

        if (success) {
            println("Wrote " + output_file)
            return 0
        } else {
            println("Error: Failed to write " + output_file)
            return 1
        }
    } else {
        // Write bytecode output
        var success = write_bytes(output_file, bytecode)

        if (success) {
            println("Wrote " + output_file)
            return 0
        } else {
            println("Error: Failed to write " + output_file)
            return 1
        }
    }
}

fn printUsage() {
    println("Usage: cot-compiler compile <source.cot> [-o <output>] [--native]")
    println("")
    println("Commands:")
    println("  compile    Compile source file")
    println("")
    println("Options:")
    println("  -o <file>  Output file (default: <source>.cbo or .o)")
    println("  --native   Generate native ARM64 code instead of bytecode")
}

// Check if a flag exists in args
fn hasFlag(args: List<string>, flag: string) bool {
    var i: i64 = 0
    while (i < args.len()) {
        if (args.get(i) == flag) {
            return true
        }
        i += 1
    }
    return false
}

// Get base name (strip extension from output file)
fn getBaseName(path: string) string {
    // Find last dot
    var dot_pos: i64 = -1
    var i: i64 = 0
    while (i < len(path)) {
        var ch = path[i..i + 1]
        if (ch == ".") {
            dot_pos = i
        }
        i += 1
    }
    if (dot_pos > 0) {
        return path[0..dot_pos]
    }
    return path
}

fn getOutputPathFrom(source_file: string, args: List<string>, start_idx: i64, use_native: bool) string {
    // Check for -o flag starting from start_idx
    var i: i64 = start_idx
    while (i < args.len()) {
        if (args.get(i) == "-o" and i + 1 < args.len()) {
            return args.get(i + 1)
        }
        i += 1
    }

    // Default extension depends on mode
    var default_ext = ".cbo"
    if (use_native) {
        default_ext = ".o"
    }

    // Default: replace .cot with appropriate extension
    if (len(source_file) > 4) {
        var ext = source_file[len(source_file) - 4..len(source_file)]
        if (ext == ".cot") {
            return source_file[0..len(source_file) - 4] + default_ext
        }
    }

    return source_file + default_ext
}

// Collect statements from a module, skipping import statements
fn collectModuleStatements(cache: *ModuleCache, path: string, stmts: *List<*Stmt>) {
    var idx = cache.getIndex(path)
    if (idx < 0) {
        return
    }
    var mod = cache.modules.get(idx)
    var stmt_idx: i64 = 0
    while (stmt_idx < mod.statements.len()) {
        var stmt = mod.statements.get(stmt_idx)
        if (stmt.kind != StmtKind.ImportStmt) {
            stmts.push(stmt)
        }
        stmt_idx += 1
    }
}

// Get the module name from a file path (strip directory and .cot extension)
fn getModuleName(path: string) string {
    // Find last slash
    var start: i64 = 0
    var i: i64 = 0
    while (i < len(path)) {
        var ch = path[i..i + 1]
        if (ch == "/") {
            start = i + 1
        }
        i += 1
    }

    // Find .cot extension
    var end_pos = len(path)
    if (len(path) > 4) {
        var ext = path[len(path) - 4..len(path)]
        if (ext == ".cot") {
            end_pos = len(path) - 4
        }
    }

    return path[start..end_pos]
}
